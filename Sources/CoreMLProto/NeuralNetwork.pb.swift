// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: NeuralNetwork.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017-2019, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

//
// A neural network is defined through a collection of layers
// and represents a directed acyclic graph (DAG).
// Each layer has a name, a layer type,
// a list of input names, a list of output names,
// and a collection of parameters specific to the layer type.
//
// The graph structure and connectivity of the neural network
// is inferred from the input and output names.
// A neural network starts with the layer
// whose input name is equal to the value specified in
// ``Model.description.input.name``,
// and ends with the layer
// whose output name is equal to the value specified in
// ``Model.description.output.name``.
// Layers must have unique input and output names,
// and a layer may not have input or output names that
// refer to layers that are not yet defined.
//
// For Core ML specification version <=3,
// all inputs are mapped to static rank 5 tensors, with axis notations
// [Sequence, Batch, Channel, Height, Width].
//
// From specification version 4 onwards (iOS >= 13, macOS >= 10.15), more options are available
// (see enums ``NeuralNetworkMultiArrayShapeMapping``, ``NeuralNetworkImageShapeMapping``)
// to map inputs to generic N-Dimensional (or N rank) tensors, where N >= 1.
//
// Each layer type may have specific constraints on the ranks of its inputs and outputs.
//
// Some of the layers (such as softmax, reduce, etc) have parameters that have been described in
// terms of notational axis "Channel", "Height", "Width" or "Sequence". They can be re-interpreted easily in
// the general ND setting by using the following rule:
// "width" is same as axis = -1 (i.e. the last axis from the end)
// "height" is same as axis = -2 (i.e. the second last axis from the end)
// "channel" is same as axis = -3 (i.e. the third last axis from the end)
// "sequence" is same as axis = -5 (i.e. the fifth last axis from the end)
//
// Several layers are available in 3 different variations, with the names ending
// in identifiers: ``like``, ``static`` and ``dynamic``. For instance, ``FillLike``,
// ``FillStatic`` and ``FillDynamic``. The ``static`` variation generally will have
// a property corresponding to the shape of the output. For instance, if the
// output of the ``FillStatic`` layer is desired to be of shape (10, 4), the
// property ``targetShape`` will have to be set to [10, 4]. In the ``dynamic`` case,
// the shape is an input, hence it can be changed at runtime. For instance, for
// a ``FillDynamic`` layer, the input would have to be an array containing the
// values 10 and 4, if the desired output is of shape (10, 4). Whereas in the
// ``like`` case, the additional input's shape is used as the output shape, ignoring
// its values. For instance, for a ``FillLike`` layer, for an input with shape
// (10, 4), the output generated will also be of shape (10, 4), values of the
// input will be ignored.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum NeuralNetworkMultiArrayShapeMapping: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///
  /// Default legacy value. Only supported for Core ML Specification version <= 3.
  ///
  /// The default legacy shape mapping resolves all input shapes to a rank 5 equivalent
  /// with axis notation of [Seq, Batch, Channel, Height, Width].
  ///
  /// When this enum value is selected,
  /// the repeated shape field in the message "ArrayFeatureType" in feature types proto,
  /// must be either length 1 or length 3.
  ///
  /// The following rule is used to map the values in the shape field to the actual tensor shape:
  /// rank 1 shape is mapped to shape [1,1,C,1,1]
  /// rank 3 shape is mapped to shape [1,1,C,H,W]
  /// At runtime, the first two dimensions (Seq or Batch) can be presented as well, with non-1 values.
  ///
  /// It is invalid to use this enum value if any of the layers added
  /// Specification version 4 (iOS >= 13, macOS >= 10.15) onwards are used in the network.
  /// Validator will raise an error in that case.
  case rank5ArrayMapping // = 0

  ///
  /// The exact shape and rank (i.e. number of dimensions in the shape) of the input,
  /// as specified in the message "ArrayFeatureType", is passed through to the layers.
  /// Supported only for Specification version >= 4 (iOS >= 13, macOS >= 10.15).
  case exactArrayMapping // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .rank5ArrayMapping
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rank5ArrayMapping
    case 1: self = .exactArrayMapping
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .rank5ArrayMapping: return 0
    case .exactArrayMapping: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NeuralNetworkMultiArrayShapeMapping: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [NeuralNetworkMultiArrayShapeMapping] = [
    .rank5ArrayMapping,
    .exactArrayMapping,
  ]
}

#endif  // swift(>=4.2)

public enum NeuralNetworkImageShapeMapping: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///
  /// In this case, image input is mapped to a rank 5 tensor.
  /// For Color images, input tensor is shaped as [1,1,3,H,W].
  /// For Gray images, input tensor is shaped as [1,1,1,H,W].
  case rank5ImageMapping // = 0

  ///
  /// For Color images, input tensor is shaped as [1,3,H,W].
  /// For Gray images, input tensor is shaped as [1,1,H,W].
  /// Supported only for Specification version >= 4 (iOS >= 13, macOS >= 10.15).
  case rank4ImageMapping // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .rank5ImageMapping
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rank5ImageMapping
    case 1: self = .rank4ImageMapping
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .rank5ImageMapping: return 0
    case .rank4ImageMapping: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NeuralNetworkImageShapeMapping: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [NeuralNetworkImageShapeMapping] = [
    .rank5ImageMapping,
    .rank4ImageMapping,
  ]
}

#endif  // swift(>=4.2)

///
/// Scatter accumulation mode.
public enum ScatterMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case scatterUpdate // = 0

  /// add
  case scatterAdd // = 1

  /// subtract
  case scatterSub // = 2

  /// multiply
  case scatterMul // = 3

  /// divide
  case scatterDiv // = 4

  /// maximum
  case scatterMax // = 5

  /// minimum
  case scatterMin // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .scatterUpdate
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .scatterUpdate
    case 1: self = .scatterAdd
    case 2: self = .scatterSub
    case 3: self = .scatterMul
    case 4: self = .scatterDiv
    case 5: self = .scatterMax
    case 6: self = .scatterMin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .scatterUpdate: return 0
    case .scatterAdd: return 1
    case .scatterSub: return 2
    case .scatterMul: return 3
    case .scatterDiv: return 4
    case .scatterMax: return 5
    case .scatterMin: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ScatterMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ScatterMode] = [
    .scatterUpdate,
    .scatterAdd,
    .scatterSub,
    .scatterMul,
    .scatterDiv,
    .scatterMax,
    .scatterMin,
  ]
}

#endif  // swift(>=4.2)

///
///A neural network.
public struct NeuralNetwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var layers: [NeuralNetworkLayer] = []

  public var preprocessing: [NeuralNetworkPreprocessing] = []

  /// use this enum value to determine the input tensor shapes to the neural network, for multiarray inputs
  public var arrayInputShapeMapping: NeuralNetworkMultiArrayShapeMapping = .rank5ArrayMapping

  /// use this enum value to determine the input tensor shapes to the neural network, for image inputs
  public var imageInputShapeMapping: NeuralNetworkImageShapeMapping = .rank5ImageMapping

  public var updateParams: NetworkUpdateParameters {
    get {return _updateParams ?? NetworkUpdateParameters()}
    set {_updateParams = newValue}
  }
  /// Returns true if `updateParams` has been explicitly set.
  public var hasUpdateParams: Bool {return self._updateParams != nil}
  /// Clears the value of `updateParams`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateParams() {self._updateParams = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateParams: NetworkUpdateParameters? = nil
}

///
/// A neural network preprocessor that
/// performs a scalar multiplication of an image
/// followed by addition of scalar biases to the channels.
///
/// Input: X
///    An image in BGR or RGB format with shape ``[3, H, W]``
///    or in grayscale format with shape ``[1, H, W]``.
/// Output: Y
///    An image with format and shape corresponding to the input.
///
/// If the input image is in BGR format:
///
/// .. code::
///
///     Y[0, :, :] = channelScale * X[0, :, :] + blueBias
///     Y[1, :, :] = channelScale * X[1, :, :] + greenBias
///     Y[2, :, :] = channelScale * X[2, :, :] + redBias
///
/// If the input image is in RGB format:
///
/// .. code::
///
///     Y[0, :, :] = channelScale * X[0, :, :] + redBias
///     Y[1, :, :] = channelScale * X[1, :, :] + greenBias
///     Y[2, :, :] = channelScale * X[2, :, :] + blueBias
///
/// If the input image is in grayscale format:
///
/// .. code::
///
///     Y[0, :, :] = channelScale * X[0, :, :] + grayBias
public struct NeuralNetworkImageScaler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Scalar to be multiplied.
  public var channelScale: Float = 0

  /// Scalar blue bias to be added.
  public var blueBias: Float = 0

  /// Scalar green bias to be added.
  public var greenBias: Float = 0

  /// Scalar red bias to be added.
  public var redBias: Float = 0

  /// Scalar bias to be added for grayscale images.
  public var grayBias: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A neural network preprocessor that
/// subtracts the provided mean image from the input image.
/// The mean image is subtracted from the input named
/// ``NeuralNetworkPreprocessing.featureName``.
public struct NeuralNetworkMeanImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Mean image stored as a flattened array of floats,
  /// representing shape [Channel,Height,Width].
  public var meanImage: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Preprocessing parameters for image inputs.
public struct NeuralNetworkPreprocessing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// must be equal to the input name to which the preprocessing is applied
  public var featureName: String = String()

  public var preprocessor: NeuralNetworkPreprocessing.OneOf_Preprocessor? = nil

  public var scaler: NeuralNetworkImageScaler {
    get {
      if case .scaler(let v)? = preprocessor {return v}
      return NeuralNetworkImageScaler()
    }
    set {preprocessor = .scaler(newValue)}
  }

  public var meanImage: NeuralNetworkMeanImage {
    get {
      if case .meanImage(let v)? = preprocessor {return v}
      return NeuralNetworkMeanImage()
    }
    set {preprocessor = .meanImage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Preprocessor: Equatable {
    case scaler(NeuralNetworkImageScaler)
    case meanImage(NeuralNetworkMeanImage)

  #if !swift(>=4.1)
    public static func ==(lhs: NeuralNetworkPreprocessing.OneOf_Preprocessor, rhs: NeuralNetworkPreprocessing.OneOf_Preprocessor) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.scaler, .scaler): return {
        guard case .scaler(let l) = lhs, case .scaler(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.meanImage, .meanImage): return {
        guard case .meanImage(let l) = lhs, case .meanImage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///
/// A rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{max}(0, x)
public struct ActivationReLU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A leaky rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x      & \text{if } x \geq 0 \\
///             \alpha x & \text{if } x < 0
///            \end{cases}
public struct ActivationLeakyReLU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///negative slope value for leakyReLU
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A hyperbolic tangent activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{1 - e^{-2x}}{1 + e^{-2x}}
public struct ActivationTanh {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A scaled hyperbolic tangent activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \alpha \tanh(\beta x)
public struct ActivationScaledTanh {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alpha: Float = 0

  public var beta: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A sigmoid activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{1}{1 + e^{-x}}
public struct ActivationSigmoid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A linear activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \alpha x + \beta
public struct ActivationLinear {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alpha: Float = 0

  public var beta: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A hard sigmoid activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{min}(\text{max}(\alpha x + \beta, 0), 1)
public struct ActivationSigmoidHard {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alpha: Float = 0

  public var beta: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A parameterized rectified linear unit (PReLU) activation function.
/// Input must be at least rank 3. Axis = -3 is denoted by "C", or channels.
/// "alpha" parameter can be a vector of length C.
///
/// This function has the following formula:
///
/// .. math::
///    f(x_i) = \begin{cases}
///                 x_i          & \text{if } x_i \geq 0 \\
///                 \alpha_i x_i & \text{if } x_i < 0
///             \end{cases} \;,\;i=1,...,C
public struct ActivationPReLU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// parameter of length C or 1.
  /// If length is 1, same value is used for all channels
  public var alpha: WeightParams {
    get {return _alpha ?? WeightParams()}
    set {_alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  public var hasAlpha: Bool {return self._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  public mutating func clearAlpha() {self._alpha = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _alpha: WeightParams? = nil
}

///
/// An exponential linear unit (ELU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x              & \text{if } x \geq 0 \\
///             \alpha (e^x - 1) & \text{if } x < 0
///            \end{cases}
public struct ActivationELU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A thresholded rectified linear unit (ReLU) activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///             x & \text{if } x \geq \alpha \\
///             0 & \text{if } x < \alpha
///            \end{cases}
public struct ActivationThresholdedReLU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A softsign activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \dfrac{x}{1 + |x|}
public struct ActivationSoftsign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A softplus activation function.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \text{log}(1 + e^x)
public struct ActivationSoftplus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A parametric softplus activation function.
/// Input must be at least rank 3. axis = -3 is denoted by "C", or channels.
/// "alpha"/"beta" parameter can be a vector of length C.
///
/// This function has the following formula:
///
/// .. math::
///     f(x_i) = \alpha_i \text{log}(1 + e^{\beta_i x_i}) \;,\;i=1,...,C
public struct ActivationParametricSoftplus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If length is 1, same value is used for all channels
  public var alpha: WeightParams {
    get {return _alpha ?? WeightParams()}
    set {_alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  public var hasAlpha: Bool {return self._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  public mutating func clearAlpha() {self._alpha = nil}

  ///parameter of length C or 1
  public var beta: WeightParams {
    get {return _beta ?? WeightParams()}
    set {_beta = newValue}
  }
  /// Returns true if `beta` has been explicitly set.
  public var hasBeta: Bool {return self._beta != nil}
  /// Clears the value of `beta`. Subsequent reads from it will return its default value.
  public mutating func clearBeta() {self._beta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _alpha: WeightParams? = nil
  fileprivate var _beta: WeightParams? = nil
}

public struct ActivationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nonlinearityType: ActivationParams.OneOf_NonlinearityType? = nil

  public var linear: ActivationLinear {
    get {
      if case .linear(let v)? = nonlinearityType {return v}
      return ActivationLinear()
    }
    set {nonlinearityType = .linear(newValue)}
  }

  public var reLu: ActivationReLU {
    get {
      if case .reLu(let v)? = nonlinearityType {return v}
      return ActivationReLU()
    }
    set {nonlinearityType = .reLu(newValue)}
  }

  public var leakyReLu: ActivationLeakyReLU {
    get {
      if case .leakyReLu(let v)? = nonlinearityType {return v}
      return ActivationLeakyReLU()
    }
    set {nonlinearityType = .leakyReLu(newValue)}
  }

  public var thresholdedReLu: ActivationThresholdedReLU {
    get {
      if case .thresholdedReLu(let v)? = nonlinearityType {return v}
      return ActivationThresholdedReLU()
    }
    set {nonlinearityType = .thresholdedReLu(newValue)}
  }

  public var preLu: ActivationPReLU {
    get {
      if case .preLu(let v)? = nonlinearityType {return v}
      return ActivationPReLU()
    }
    set {nonlinearityType = .preLu(newValue)}
  }

  public var tanh: ActivationTanh {
    get {
      if case .tanh(let v)? = nonlinearityType {return v}
      return ActivationTanh()
    }
    set {nonlinearityType = .tanh(newValue)}
  }

  public var scaledTanh: ActivationScaledTanh {
    get {
      if case .scaledTanh(let v)? = nonlinearityType {return v}
      return ActivationScaledTanh()
    }
    set {nonlinearityType = .scaledTanh(newValue)}
  }

  public var sigmoid: ActivationSigmoid {
    get {
      if case .sigmoid(let v)? = nonlinearityType {return v}
      return ActivationSigmoid()
    }
    set {nonlinearityType = .sigmoid(newValue)}
  }

  public var sigmoidHard: ActivationSigmoidHard {
    get {
      if case .sigmoidHard(let v)? = nonlinearityType {return v}
      return ActivationSigmoidHard()
    }
    set {nonlinearityType = .sigmoidHard(newValue)}
  }

  public var elu: ActivationELU {
    get {
      if case .elu(let v)? = nonlinearityType {return v}
      return ActivationELU()
    }
    set {nonlinearityType = .elu(newValue)}
  }

  public var softsign: ActivationSoftsign {
    get {
      if case .softsign(let v)? = nonlinearityType {return v}
      return ActivationSoftsign()
    }
    set {nonlinearityType = .softsign(newValue)}
  }

  public var softplus: ActivationSoftplus {
    get {
      if case .softplus(let v)? = nonlinearityType {return v}
      return ActivationSoftplus()
    }
    set {nonlinearityType = .softplus(newValue)}
  }

  public var parametricSoftplus: ActivationParametricSoftplus {
    get {
      if case .parametricSoftplus(let v)? = nonlinearityType {return v}
      return ActivationParametricSoftplus()
    }
    set {nonlinearityType = .parametricSoftplus(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_NonlinearityType: Equatable {
    case linear(ActivationLinear)
    case reLu(ActivationReLU)
    case leakyReLu(ActivationLeakyReLU)
    case thresholdedReLu(ActivationThresholdedReLU)
    case preLu(ActivationPReLU)
    case tanh(ActivationTanh)
    case scaledTanh(ActivationScaledTanh)
    case sigmoid(ActivationSigmoid)
    case sigmoidHard(ActivationSigmoidHard)
    case elu(ActivationELU)
    case softsign(ActivationSoftsign)
    case softplus(ActivationSoftplus)
    case parametricSoftplus(ActivationParametricSoftplus)

  #if !swift(>=4.1)
    public static func ==(lhs: ActivationParams.OneOf_NonlinearityType, rhs: ActivationParams.OneOf_NonlinearityType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.linear, .linear): return {
        guard case .linear(let l) = lhs, case .linear(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reLu, .reLu): return {
        guard case .reLu(let l) = lhs, case .reLu(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.leakyReLu, .leakyReLu): return {
        guard case .leakyReLu(let l) = lhs, case .leakyReLu(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.thresholdedReLu, .thresholdedReLu): return {
        guard case .thresholdedReLu(let l) = lhs, case .thresholdedReLu(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preLu, .preLu): return {
        guard case .preLu(let l) = lhs, case .preLu(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tanh, .tanh): return {
        guard case .tanh(let l) = lhs, case .tanh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scaledTanh, .scaledTanh): return {
        guard case .scaledTanh(let l) = lhs, case .scaledTanh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sigmoid, .sigmoid): return {
        guard case .sigmoid(let l) = lhs, case .sigmoid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sigmoidHard, .sigmoidHard): return {
        guard case .sigmoidHard(let l) = lhs, case .sigmoidHard(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.elu, .elu): return {
        guard case .elu(let l) = lhs, case .elu(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.softsign, .softsign): return {
        guard case .softsign(let l) = lhs, case .softsign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.softplus, .softplus): return {
        guard case .softplus(let l) = lhs, case .softplus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.parametricSoftplus, .parametricSoftplus): return {
        guard case .parametricSoftplus(let l) = lhs, case .parametricSoftplus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///
/// Representation of the intermediate tensors
public struct Tensor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of dimensions in the tensor shape
  public var rank: UInt32 = 0

  /// actual value of the tensor shape.
  /// must be of length "rank". Can contain -1s for unknown dimensions.
  public var dimValue: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A single neural network layer.
public struct NeuralNetworkLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///descriptive name of the layer
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var input: [String] {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  public var output: [String] {
    get {return _storage._output}
    set {_uniqueStorage()._output = newValue}
  }

  /// must be the same length as the "input" field
  public var inputTensor: [Tensor] {
    get {return _storage._inputTensor}
    set {_uniqueStorage()._inputTensor = newValue}
  }

  /// must be the same length as the "output" field
  public var outputTensor: [Tensor] {
    get {return _storage._outputTensor}
    set {_uniqueStorage()._outputTensor = newValue}
  }

  /// Must be set to true to mark the layer as updatable.
  /// If true, the weightParams in the layer's properties must also be set to updatable
  /// If false, the value of the isUpdatable parameter within the layer's weights are ignored
  public var isUpdatable: Bool {
    get {return _storage._isUpdatable}
    set {_uniqueStorage()._isUpdatable = newValue}
  }

  public var layer: OneOf_Layer? {
    get {return _storage._layer}
    set {_uniqueStorage()._layer = newValue}
  }

  /// Start at 100 here
  public var convolution: ConvolutionLayerParams {
    get {
      if case .convolution(let v)? = _storage._layer {return v}
      return ConvolutionLayerParams()
    }
    set {_uniqueStorage()._layer = .convolution(newValue)}
  }

  public var pooling: PoolingLayerParams {
    get {
      if case .pooling(let v)? = _storage._layer {return v}
      return PoolingLayerParams()
    }
    set {_uniqueStorage()._layer = .pooling(newValue)}
  }

  public var activation: ActivationParams {
    get {
      if case .activation(let v)? = _storage._layer {return v}
      return ActivationParams()
    }
    set {_uniqueStorage()._layer = .activation(newValue)}
  }

  public var innerProduct: InnerProductLayerParams {
    get {
      if case .innerProduct(let v)? = _storage._layer {return v}
      return InnerProductLayerParams()
    }
    set {_uniqueStorage()._layer = .innerProduct(newValue)}
  }

  public var embedding: EmbeddingLayerParams {
    get {
      if case .embedding(let v)? = _storage._layer {return v}
      return EmbeddingLayerParams()
    }
    set {_uniqueStorage()._layer = .embedding(newValue)}
  }

  /// Normalization-related Layers
  public var batchnorm: BatchnormLayerParams {
    get {
      if case .batchnorm(let v)? = _storage._layer {return v}
      return BatchnormLayerParams()
    }
    set {_uniqueStorage()._layer = .batchnorm(newValue)}
  }

  public var mvn: MeanVarianceNormalizeLayerParams {
    get {
      if case .mvn(let v)? = _storage._layer {return v}
      return MeanVarianceNormalizeLayerParams()
    }
    set {_uniqueStorage()._layer = .mvn(newValue)}
  }

  public var l2Normalize: L2NormalizeLayerParams {
    get {
      if case .l2Normalize(let v)? = _storage._layer {return v}
      return L2NormalizeLayerParams()
    }
    set {_uniqueStorage()._layer = .l2Normalize(newValue)}
  }

  public var softmax: SoftmaxLayerParams {
    get {
      if case .softmax(let v)? = _storage._layer {return v}
      return SoftmaxLayerParams()
    }
    set {_uniqueStorage()._layer = .softmax(newValue)}
  }

  public var lrn: LRNLayerParams {
    get {
      if case .lrn(let v)? = _storage._layer {return v}
      return LRNLayerParams()
    }
    set {_uniqueStorage()._layer = .lrn(newValue)}
  }

  public var crop: CropLayerParams {
    get {
      if case .crop(let v)? = _storage._layer {return v}
      return CropLayerParams()
    }
    set {_uniqueStorage()._layer = .crop(newValue)}
  }

  public var padding: PaddingLayerParams {
    get {
      if case .padding(let v)? = _storage._layer {return v}
      return PaddingLayerParams()
    }
    set {_uniqueStorage()._layer = .padding(newValue)}
  }

  public var upsample: UpsampleLayerParams {
    get {
      if case .upsample(let v)? = _storage._layer {return v}
      return UpsampleLayerParams()
    }
    set {_uniqueStorage()._layer = .upsample(newValue)}
  }

  public var resizeBilinear: ResizeBilinearLayerParams {
    get {
      if case .resizeBilinear(let v)? = _storage._layer {return v}
      return ResizeBilinearLayerParams()
    }
    set {_uniqueStorage()._layer = .resizeBilinear(newValue)}
  }

  public var cropResize: CropResizeLayerParams {
    get {
      if case .cropResize(let v)? = _storage._layer {return v}
      return CropResizeLayerParams()
    }
    set {_uniqueStorage()._layer = .cropResize(newValue)}
  }

  public var unary: UnaryFunctionLayerParams {
    get {
      if case .unary(let v)? = _storage._layer {return v}
      return UnaryFunctionLayerParams()
    }
    set {_uniqueStorage()._layer = .unary(newValue)}
  }

  /// Element-wise Operations
  public var add: AddLayerParams {
    get {
      if case .add(let v)? = _storage._layer {return v}
      return AddLayerParams()
    }
    set {_uniqueStorage()._layer = .add(newValue)}
  }

  public var multiply: MultiplyLayerParams {
    get {
      if case .multiply(let v)? = _storage._layer {return v}
      return MultiplyLayerParams()
    }
    set {_uniqueStorage()._layer = .multiply(newValue)}
  }

  public var average: AverageLayerParams {
    get {
      if case .average(let v)? = _storage._layer {return v}
      return AverageLayerParams()
    }
    set {_uniqueStorage()._layer = .average(newValue)}
  }

  public var scale: ScaleLayerParams {
    get {
      if case .scale(let v)? = _storage._layer {return v}
      return ScaleLayerParams()
    }
    set {_uniqueStorage()._layer = .scale(newValue)}
  }

  public var bias: BiasLayerParams {
    get {
      if case .bias(let v)? = _storage._layer {return v}
      return BiasLayerParams()
    }
    set {_uniqueStorage()._layer = .bias(newValue)}
  }

  public var max: MaxLayerParams {
    get {
      if case .max(let v)? = _storage._layer {return v}
      return MaxLayerParams()
    }
    set {_uniqueStorage()._layer = .max(newValue)}
  }

  public var min: MinLayerParams {
    get {
      if case .min(let v)? = _storage._layer {return v}
      return MinLayerParams()
    }
    set {_uniqueStorage()._layer = .min(newValue)}
  }

  public var dot: DotProductLayerParams {
    get {
      if case .dot(let v)? = _storage._layer {return v}
      return DotProductLayerParams()
    }
    set {_uniqueStorage()._layer = .dot(newValue)}
  }

  public var reduce: ReduceLayerParams {
    get {
      if case .reduce(let v)? = _storage._layer {return v}
      return ReduceLayerParams()
    }
    set {_uniqueStorage()._layer = .reduce(newValue)}
  }

  public var loadConstant: LoadConstantLayerParams {
    get {
      if case .loadConstant(let v)? = _storage._layer {return v}
      return LoadConstantLayerParams()
    }
    set {_uniqueStorage()._layer = .loadConstant(newValue)}
  }

  /// Data Reorganization
  public var reshape: ReshapeLayerParams {
    get {
      if case .reshape(let v)? = _storage._layer {return v}
      return ReshapeLayerParams()
    }
    set {_uniqueStorage()._layer = .reshape(newValue)}
  }

  public var flatten: FlattenLayerParams {
    get {
      if case .flatten(let v)? = _storage._layer {return v}
      return FlattenLayerParams()
    }
    set {_uniqueStorage()._layer = .flatten(newValue)}
  }

  public var permute: PermuteLayerParams {
    get {
      if case .permute(let v)? = _storage._layer {return v}
      return PermuteLayerParams()
    }
    set {_uniqueStorage()._layer = .permute(newValue)}
  }

  public var concat: ConcatLayerParams {
    get {
      if case .concat(let v)? = _storage._layer {return v}
      return ConcatLayerParams()
    }
    set {_uniqueStorage()._layer = .concat(newValue)}
  }

  public var split: SplitLayerParams {
    get {
      if case .split(let v)? = _storage._layer {return v}
      return SplitLayerParams()
    }
    set {_uniqueStorage()._layer = .split(newValue)}
  }

  public var sequenceRepeat: SequenceRepeatLayerParams {
    get {
      if case .sequenceRepeat(let v)? = _storage._layer {return v}
      return SequenceRepeatLayerParams()
    }
    set {_uniqueStorage()._layer = .sequenceRepeat(newValue)}
  }

  public var reorganizeData: ReorganizeDataLayerParams {
    get {
      if case .reorganizeData(let v)? = _storage._layer {return v}
      return ReorganizeDataLayerParams()
    }
    set {_uniqueStorage()._layer = .reorganizeData(newValue)}
  }

  public var slice: SliceLayerParams {
    get {
      if case .slice(let v)? = _storage._layer {return v}
      return SliceLayerParams()
    }
    set {_uniqueStorage()._layer = .slice(newValue)}
  }

  /// Recurrent Layers
  public var simpleRecurrent: SimpleRecurrentLayerParams {
    get {
      if case .simpleRecurrent(let v)? = _storage._layer {return v}
      return SimpleRecurrentLayerParams()
    }
    set {_uniqueStorage()._layer = .simpleRecurrent(newValue)}
  }

  public var gru: GRULayerParams {
    get {
      if case .gru(let v)? = _storage._layer {return v}
      return GRULayerParams()
    }
    set {_uniqueStorage()._layer = .gru(newValue)}
  }

  public var uniDirectionalLstm: UniDirectionalLSTMLayerParams {
    get {
      if case .uniDirectionalLstm(let v)? = _storage._layer {return v}
      return UniDirectionalLSTMLayerParams()
    }
    set {_uniqueStorage()._layer = .uniDirectionalLstm(newValue)}
  }

  public var biDirectionalLstm: BiDirectionalLSTMLayerParams {
    get {
      if case .biDirectionalLstm(let v)? = _storage._layer {return v}
      return BiDirectionalLSTMLayerParams()
    }
    set {_uniqueStorage()._layer = .biDirectionalLstm(newValue)}
  }

  /// Custom (user-implemented) Layer
  public var custom: CustomLayerParams {
    get {
      if case .custom(let v)? = _storage._layer {return v}
      return CustomLayerParams()
    }
    set {_uniqueStorage()._layer = .custom(newValue)}
  }

  /// Control Flow related Layers
  public var copy: CopyLayerParams {
    get {
      if case .copy(let v)? = _storage._layer {return v}
      return CopyLayerParams()
    }
    set {_uniqueStorage()._layer = .copy(newValue)}
  }

  public var branch: BranchLayerParams {
    get {
      if case .branch(let v)? = _storage._layer {return v}
      return BranchLayerParams()
    }
    set {_uniqueStorage()._layer = .branch(newValue)}
  }

  public var loop: LoopLayerParams {
    get {
      if case .loop(let v)? = _storage._layer {return v}
      return LoopLayerParams()
    }
    set {_uniqueStorage()._layer = .loop(newValue)}
  }

  public var loopBreak: LoopBreakLayerParams {
    get {
      if case .loopBreak(let v)? = _storage._layer {return v}
      return LoopBreakLayerParams()
    }
    set {_uniqueStorage()._layer = .loopBreak(newValue)}
  }

  public var loopContinue: LoopContinueLayerParams {
    get {
      if case .loopContinue(let v)? = _storage._layer {return v}
      return LoopContinueLayerParams()
    }
    set {_uniqueStorage()._layer = .loopContinue(newValue)}
  }

  public var rangeStatic: RangeStaticLayerParams {
    get {
      if case .rangeStatic(let v)? = _storage._layer {return v}
      return RangeStaticLayerParams()
    }
    set {_uniqueStorage()._layer = .rangeStatic(newValue)}
  }

  public var rangeDynamic: RangeDynamicLayerParams {
    get {
      if case .rangeDynamic(let v)? = _storage._layer {return v}
      return RangeDynamicLayerParams()
    }
    set {_uniqueStorage()._layer = .rangeDynamic(newValue)}
  }

  /// Element-wise Unary Layers
  public var clip: ClipLayerParams {
    get {
      if case .clip(let v)? = _storage._layer {return v}
      return ClipLayerParams()
    }
    set {_uniqueStorage()._layer = .clip(newValue)}
  }

  public var ceil: CeilLayerParams {
    get {
      if case .ceil(let v)? = _storage._layer {return v}
      return CeilLayerParams()
    }
    set {_uniqueStorage()._layer = .ceil(newValue)}
  }

  public var floor: FloorLayerParams {
    get {
      if case .floor(let v)? = _storage._layer {return v}
      return FloorLayerParams()
    }
    set {_uniqueStorage()._layer = .floor(newValue)}
  }

  public var sign: SignLayerParams {
    get {
      if case .sign(let v)? = _storage._layer {return v}
      return SignLayerParams()
    }
    set {_uniqueStorage()._layer = .sign(newValue)}
  }

  public var round: RoundLayerParams {
    get {
      if case .round(let v)? = _storage._layer {return v}
      return RoundLayerParams()
    }
    set {_uniqueStorage()._layer = .round(newValue)}
  }

  public var exp2: Exp2LayerParams {
    get {
      if case .exp2(let v)? = _storage._layer {return v}
      return Exp2LayerParams()
    }
    set {_uniqueStorage()._layer = .exp2(newValue)}
  }

  public var sin: SinLayerParams {
    get {
      if case .sin(let v)? = _storage._layer {return v}
      return SinLayerParams()
    }
    set {_uniqueStorage()._layer = .sin(newValue)}
  }

  public var cos: CosLayerParams {
    get {
      if case .cos(let v)? = _storage._layer {return v}
      return CosLayerParams()
    }
    set {_uniqueStorage()._layer = .cos(newValue)}
  }

  public var tan: TanLayerParams {
    get {
      if case .tan(let v)? = _storage._layer {return v}
      return TanLayerParams()
    }
    set {_uniqueStorage()._layer = .tan(newValue)}
  }

  public var asin: AsinLayerParams {
    get {
      if case .asin(let v)? = _storage._layer {return v}
      return AsinLayerParams()
    }
    set {_uniqueStorage()._layer = .asin(newValue)}
  }

  public var acos: AcosLayerParams {
    get {
      if case .acos(let v)? = _storage._layer {return v}
      return AcosLayerParams()
    }
    set {_uniqueStorage()._layer = .acos(newValue)}
  }

  public var atan: AtanLayerParams {
    get {
      if case .atan(let v)? = _storage._layer {return v}
      return AtanLayerParams()
    }
    set {_uniqueStorage()._layer = .atan(newValue)}
  }

  public var sinh: SinhLayerParams {
    get {
      if case .sinh(let v)? = _storage._layer {return v}
      return SinhLayerParams()
    }
    set {_uniqueStorage()._layer = .sinh(newValue)}
  }

  public var cosh: CoshLayerParams {
    get {
      if case .cosh(let v)? = _storage._layer {return v}
      return CoshLayerParams()
    }
    set {_uniqueStorage()._layer = .cosh(newValue)}
  }

  public var tanh: TanhLayerParams {
    get {
      if case .tanh(let v)? = _storage._layer {return v}
      return TanhLayerParams()
    }
    set {_uniqueStorage()._layer = .tanh(newValue)}
  }

  public var asinh: AsinhLayerParams {
    get {
      if case .asinh(let v)? = _storage._layer {return v}
      return AsinhLayerParams()
    }
    set {_uniqueStorage()._layer = .asinh(newValue)}
  }

  public var acosh: AcoshLayerParams {
    get {
      if case .acosh(let v)? = _storage._layer {return v}
      return AcoshLayerParams()
    }
    set {_uniqueStorage()._layer = .acosh(newValue)}
  }

  public var atanh: AtanhLayerParams {
    get {
      if case .atanh(let v)? = _storage._layer {return v}
      return AtanhLayerParams()
    }
    set {_uniqueStorage()._layer = .atanh(newValue)}
  }

  public var erf: ErfLayerParams {
    get {
      if case .erf(let v)? = _storage._layer {return v}
      return ErfLayerParams()
    }
    set {_uniqueStorage()._layer = .erf(newValue)}
  }

  public var gelu: GeluLayerParams {
    get {
      if case .gelu(let v)? = _storage._layer {return v}
      return GeluLayerParams()
    }
    set {_uniqueStorage()._layer = .gelu(newValue)}
  }

  /// Element-wise Binary with Broadcasting Support
  public var equal: EqualLayerParams {
    get {
      if case .equal(let v)? = _storage._layer {return v}
      return EqualLayerParams()
    }
    set {_uniqueStorage()._layer = .equal(newValue)}
  }

  public var notEqual: NotEqualLayerParams {
    get {
      if case .notEqual(let v)? = _storage._layer {return v}
      return NotEqualLayerParams()
    }
    set {_uniqueStorage()._layer = .notEqual(newValue)}
  }

  public var lessThan: LessThanLayerParams {
    get {
      if case .lessThan(let v)? = _storage._layer {return v}
      return LessThanLayerParams()
    }
    set {_uniqueStorage()._layer = .lessThan(newValue)}
  }

  public var lessEqual: LessEqualLayerParams {
    get {
      if case .lessEqual(let v)? = _storage._layer {return v}
      return LessEqualLayerParams()
    }
    set {_uniqueStorage()._layer = .lessEqual(newValue)}
  }

  public var greaterThan: GreaterThanLayerParams {
    get {
      if case .greaterThan(let v)? = _storage._layer {return v}
      return GreaterThanLayerParams()
    }
    set {_uniqueStorage()._layer = .greaterThan(newValue)}
  }

  public var greaterEqual: GreaterEqualLayerParams {
    get {
      if case .greaterEqual(let v)? = _storage._layer {return v}
      return GreaterEqualLayerParams()
    }
    set {_uniqueStorage()._layer = .greaterEqual(newValue)}
  }

  public var logicalOr: LogicalOrLayerParams {
    get {
      if case .logicalOr(let v)? = _storage._layer {return v}
      return LogicalOrLayerParams()
    }
    set {_uniqueStorage()._layer = .logicalOr(newValue)}
  }

  public var logicalXor: LogicalXorLayerParams {
    get {
      if case .logicalXor(let v)? = _storage._layer {return v}
      return LogicalXorLayerParams()
    }
    set {_uniqueStorage()._layer = .logicalXor(newValue)}
  }

  public var logicalNot: LogicalNotLayerParams {
    get {
      if case .logicalNot(let v)? = _storage._layer {return v}
      return LogicalNotLayerParams()
    }
    set {_uniqueStorage()._layer = .logicalNot(newValue)}
  }

  public var logicalAnd: LogicalAndLayerParams {
    get {
      if case .logicalAnd(let v)? = _storage._layer {return v}
      return LogicalAndLayerParams()
    }
    set {_uniqueStorage()._layer = .logicalAnd(newValue)}
  }

  public var modBroadcastable: ModBroadcastableLayerParams {
    get {
      if case .modBroadcastable(let v)? = _storage._layer {return v}
      return ModBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .modBroadcastable(newValue)}
  }

  public var minBroadcastable: MinBroadcastableLayerParams {
    get {
      if case .minBroadcastable(let v)? = _storage._layer {return v}
      return MinBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .minBroadcastable(newValue)}
  }

  public var maxBroadcastable: MaxBroadcastableLayerParams {
    get {
      if case .maxBroadcastable(let v)? = _storage._layer {return v}
      return MaxBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .maxBroadcastable(newValue)}
  }

  public var addBroadcastable: AddBroadcastableLayerParams {
    get {
      if case .addBroadcastable(let v)? = _storage._layer {return v}
      return AddBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .addBroadcastable(newValue)}
  }

  public var powBroadcastable: PowBroadcastableLayerParams {
    get {
      if case .powBroadcastable(let v)? = _storage._layer {return v}
      return PowBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .powBroadcastable(newValue)}
  }

  public var divideBroadcastable: DivideBroadcastableLayerParams {
    get {
      if case .divideBroadcastable(let v)? = _storage._layer {return v}
      return DivideBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .divideBroadcastable(newValue)}
  }

  public var floorDivBroadcastable: FloorDivBroadcastableLayerParams {
    get {
      if case .floorDivBroadcastable(let v)? = _storage._layer {return v}
      return FloorDivBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .floorDivBroadcastable(newValue)}
  }

  public var multiplyBroadcastable: MultiplyBroadcastableLayerParams {
    get {
      if case .multiplyBroadcastable(let v)? = _storage._layer {return v}
      return MultiplyBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .multiplyBroadcastable(newValue)}
  }

  public var subtractBroadcastable: SubtractBroadcastableLayerParams {
    get {
      if case .subtractBroadcastable(let v)? = _storage._layer {return v}
      return SubtractBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .subtractBroadcastable(newValue)}
  }

  /// Tensor Manipulations
  public var tile: TileLayerParams {
    get {
      if case .tile(let v)? = _storage._layer {return v}
      return TileLayerParams()
    }
    set {_uniqueStorage()._layer = .tile(newValue)}
  }

  public var stack: StackLayerParams {
    get {
      if case .stack(let v)? = _storage._layer {return v}
      return StackLayerParams()
    }
    set {_uniqueStorage()._layer = .stack(newValue)}
  }

  public var gather: GatherLayerParams {
    get {
      if case .gather(let v)? = _storage._layer {return v}
      return GatherLayerParams()
    }
    set {_uniqueStorage()._layer = .gather(newValue)}
  }

  public var scatter: ScatterLayerParams {
    get {
      if case .scatter(let v)? = _storage._layer {return v}
      return ScatterLayerParams()
    }
    set {_uniqueStorage()._layer = .scatter(newValue)}
  }

  public var gatherNd: GatherNDLayerParams {
    get {
      if case .gatherNd(let v)? = _storage._layer {return v}
      return GatherNDLayerParams()
    }
    set {_uniqueStorage()._layer = .gatherNd(newValue)}
  }

  public var scatterNd: ScatterNDLayerParams {
    get {
      if case .scatterNd(let v)? = _storage._layer {return v}
      return ScatterNDLayerParams()
    }
    set {_uniqueStorage()._layer = .scatterNd(newValue)}
  }

  public var softmaxNd: SoftmaxNDLayerParams {
    get {
      if case .softmaxNd(let v)? = _storage._layer {return v}
      return SoftmaxNDLayerParams()
    }
    set {_uniqueStorage()._layer = .softmaxNd(newValue)}
  }

  public var gatherAlongAxis: GatherAlongAxisLayerParams {
    get {
      if case .gatherAlongAxis(let v)? = _storage._layer {return v}
      return GatherAlongAxisLayerParams()
    }
    set {_uniqueStorage()._layer = .gatherAlongAxis(newValue)}
  }

  public var scatterAlongAxis: ScatterAlongAxisLayerParams {
    get {
      if case .scatterAlongAxis(let v)? = _storage._layer {return v}
      return ScatterAlongAxisLayerParams()
    }
    set {_uniqueStorage()._layer = .scatterAlongAxis(newValue)}
  }

  public var reverse: ReverseLayerParams {
    get {
      if case .reverse(let v)? = _storage._layer {return v}
      return ReverseLayerParams()
    }
    set {_uniqueStorage()._layer = .reverse(newValue)}
  }

  public var reverseSeq: ReverseSeqLayerParams {
    get {
      if case .reverseSeq(let v)? = _storage._layer {return v}
      return ReverseSeqLayerParams()
    }
    set {_uniqueStorage()._layer = .reverseSeq(newValue)}
  }

  public var splitNd: SplitNDLayerParams {
    get {
      if case .splitNd(let v)? = _storage._layer {return v}
      return SplitNDLayerParams()
    }
    set {_uniqueStorage()._layer = .splitNd(newValue)}
  }

  public var concatNd: ConcatNDLayerParams {
    get {
      if case .concatNd(let v)? = _storage._layer {return v}
      return ConcatNDLayerParams()
    }
    set {_uniqueStorage()._layer = .concatNd(newValue)}
  }

  public var transpose: TransposeLayerParams {
    get {
      if case .transpose(let v)? = _storage._layer {return v}
      return TransposeLayerParams()
    }
    set {_uniqueStorage()._layer = .transpose(newValue)}
  }

  public var sliceStatic: SliceStaticLayerParams {
    get {
      if case .sliceStatic(let v)? = _storage._layer {return v}
      return SliceStaticLayerParams()
    }
    set {_uniqueStorage()._layer = .sliceStatic(newValue)}
  }

  public var sliceDynamic: SliceDynamicLayerParams {
    get {
      if case .sliceDynamic(let v)? = _storage._layer {return v}
      return SliceDynamicLayerParams()
    }
    set {_uniqueStorage()._layer = .sliceDynamic(newValue)}
  }

  public var slidingWindows: SlidingWindowsLayerParams {
    get {
      if case .slidingWindows(let v)? = _storage._layer {return v}
      return SlidingWindowsLayerParams()
    }
    set {_uniqueStorage()._layer = .slidingWindows(newValue)}
  }

  public var topK: TopKLayerParams {
    get {
      if case .topK(let v)? = _storage._layer {return v}
      return TopKLayerParams()
    }
    set {_uniqueStorage()._layer = .topK(newValue)}
  }

  public var argMin: ArgMinLayerParams {
    get {
      if case .argMin(let v)? = _storage._layer {return v}
      return ArgMinLayerParams()
    }
    set {_uniqueStorage()._layer = .argMin(newValue)}
  }

  public var argMax: ArgMaxLayerParams {
    get {
      if case .argMax(let v)? = _storage._layer {return v}
      return ArgMaxLayerParams()
    }
    set {_uniqueStorage()._layer = .argMax(newValue)}
  }

  public var embeddingNd: EmbeddingNDLayerParams {
    get {
      if case .embeddingNd(let v)? = _storage._layer {return v}
      return EmbeddingNDLayerParams()
    }
    set {_uniqueStorage()._layer = .embeddingNd(newValue)}
  }

  public var batchedMatmul: BatchedMatMulLayerParams {
    get {
      if case .batchedMatmul(let v)? = _storage._layer {return v}
      return BatchedMatMulLayerParams()
    }
    set {_uniqueStorage()._layer = .batchedMatmul(newValue)}
  }

  /// Tensor Allocation / Reshape-related Operations
  public var getShape: GetShapeLayerParams {
    get {
      if case .getShape(let v)? = _storage._layer {return v}
      return GetShapeLayerParams()
    }
    set {_uniqueStorage()._layer = .getShape(newValue)}
  }

  public var loadConstantNd: LoadConstantNDLayerParams {
    get {
      if case .loadConstantNd(let v)? = _storage._layer {return v}
      return LoadConstantNDLayerParams()
    }
    set {_uniqueStorage()._layer = .loadConstantNd(newValue)}
  }

  public var fillLike: FillLikeLayerParams {
    get {
      if case .fillLike(let v)? = _storage._layer {return v}
      return FillLikeLayerParams()
    }
    set {_uniqueStorage()._layer = .fillLike(newValue)}
  }

  public var fillStatic: FillStaticLayerParams {
    get {
      if case .fillStatic(let v)? = _storage._layer {return v}
      return FillStaticLayerParams()
    }
    set {_uniqueStorage()._layer = .fillStatic(newValue)}
  }

  public var fillDynamic: FillDynamicLayerParams {
    get {
      if case .fillDynamic(let v)? = _storage._layer {return v}
      return FillDynamicLayerParams()
    }
    set {_uniqueStorage()._layer = .fillDynamic(newValue)}
  }

  public var broadcastToLike: BroadcastToLikeLayerParams {
    get {
      if case .broadcastToLike(let v)? = _storage._layer {return v}
      return BroadcastToLikeLayerParams()
    }
    set {_uniqueStorage()._layer = .broadcastToLike(newValue)}
  }

  public var broadcastToStatic: BroadcastToStaticLayerParams {
    get {
      if case .broadcastToStatic(let v)? = _storage._layer {return v}
      return BroadcastToStaticLayerParams()
    }
    set {_uniqueStorage()._layer = .broadcastToStatic(newValue)}
  }

  public var broadcastToDynamic: BroadcastToDynamicLayerParams {
    get {
      if case .broadcastToDynamic(let v)? = _storage._layer {return v}
      return BroadcastToDynamicLayerParams()
    }
    set {_uniqueStorage()._layer = .broadcastToDynamic(newValue)}
  }

  public var squeeze: SqueezeLayerParams {
    get {
      if case .squeeze(let v)? = _storage._layer {return v}
      return SqueezeLayerParams()
    }
    set {_uniqueStorage()._layer = .squeeze(newValue)}
  }

  public var expandDims: ExpandDimsLayerParams {
    get {
      if case .expandDims(let v)? = _storage._layer {return v}
      return ExpandDimsLayerParams()
    }
    set {_uniqueStorage()._layer = .expandDims(newValue)}
  }

  public var flattenTo2D: FlattenTo2DLayerParams {
    get {
      if case .flattenTo2D(let v)? = _storage._layer {return v}
      return FlattenTo2DLayerParams()
    }
    set {_uniqueStorage()._layer = .flattenTo2D(newValue)}
  }

  public var reshapeLike: ReshapeLikeLayerParams {
    get {
      if case .reshapeLike(let v)? = _storage._layer {return v}
      return ReshapeLikeLayerParams()
    }
    set {_uniqueStorage()._layer = .reshapeLike(newValue)}
  }

  public var reshapeStatic: ReshapeStaticLayerParams {
    get {
      if case .reshapeStatic(let v)? = _storage._layer {return v}
      return ReshapeStaticLayerParams()
    }
    set {_uniqueStorage()._layer = .reshapeStatic(newValue)}
  }

  public var reshapeDynamic: ReshapeDynamicLayerParams {
    get {
      if case .reshapeDynamic(let v)? = _storage._layer {return v}
      return ReshapeDynamicLayerParams()
    }
    set {_uniqueStorage()._layer = .reshapeDynamic(newValue)}
  }

  public var rankPreservingReshape: RankPreservingReshapeLayerParams {
    get {
      if case .rankPreservingReshape(let v)? = _storage._layer {return v}
      return RankPreservingReshapeLayerParams()
    }
    set {_uniqueStorage()._layer = .rankPreservingReshape(newValue)}
  }

  public var constantPad: ConstantPaddingLayerParams {
    get {
      if case .constantPad(let v)? = _storage._layer {return v}
      return ConstantPaddingLayerParams()
    }
    set {_uniqueStorage()._layer = .constantPad(newValue)}
  }

  /// Random Distributions
  public var randomNormalLike: RandomNormalLikeLayerParams {
    get {
      if case .randomNormalLike(let v)? = _storage._layer {return v}
      return RandomNormalLikeLayerParams()
    }
    set {_uniqueStorage()._layer = .randomNormalLike(newValue)}
  }

  public var randomNormalStatic: RandomNormalStaticLayerParams {
    get {
      if case .randomNormalStatic(let v)? = _storage._layer {return v}
      return RandomNormalStaticLayerParams()
    }
    set {_uniqueStorage()._layer = .randomNormalStatic(newValue)}
  }

  public var randomNormalDynamic: RandomNormalDynamicLayerParams {
    get {
      if case .randomNormalDynamic(let v)? = _storage._layer {return v}
      return RandomNormalDynamicLayerParams()
    }
    set {_uniqueStorage()._layer = .randomNormalDynamic(newValue)}
  }

  public var randomUniformLike: RandomUniformLikeLayerParams {
    get {
      if case .randomUniformLike(let v)? = _storage._layer {return v}
      return RandomUniformLikeLayerParams()
    }
    set {_uniqueStorage()._layer = .randomUniformLike(newValue)}
  }

  public var randomUniformStatic: RandomUniformStaticLayerParams {
    get {
      if case .randomUniformStatic(let v)? = _storage._layer {return v}
      return RandomUniformStaticLayerParams()
    }
    set {_uniqueStorage()._layer = .randomUniformStatic(newValue)}
  }

  public var randomUniformDynamic: RandomUniformDynamicLayerParams {
    get {
      if case .randomUniformDynamic(let v)? = _storage._layer {return v}
      return RandomUniformDynamicLayerParams()
    }
    set {_uniqueStorage()._layer = .randomUniformDynamic(newValue)}
  }

  public var randomBernoulliLike: RandomBernoulliLikeLayerParams {
    get {
      if case .randomBernoulliLike(let v)? = _storage._layer {return v}
      return RandomBernoulliLikeLayerParams()
    }
    set {_uniqueStorage()._layer = .randomBernoulliLike(newValue)}
  }

  public var randomBernoulliStatic: RandomBernoulliStaticLayerParams {
    get {
      if case .randomBernoulliStatic(let v)? = _storage._layer {return v}
      return RandomBernoulliStaticLayerParams()
    }
    set {_uniqueStorage()._layer = .randomBernoulliStatic(newValue)}
  }

  public var randomBernoulliDynamic: RandomBernoulliDynamicLayerParams {
    get {
      if case .randomBernoulliDynamic(let v)? = _storage._layer {return v}
      return RandomBernoulliDynamicLayerParams()
    }
    set {_uniqueStorage()._layer = .randomBernoulliDynamic(newValue)}
  }

  public var categoricalDistribution: CategoricalDistributionLayerParams {
    get {
      if case .categoricalDistribution(let v)? = _storage._layer {return v}
      return CategoricalDistributionLayerParams()
    }
    set {_uniqueStorage()._layer = .categoricalDistribution(newValue)}
  }

  /// Reduction-related Layers:
  public var reduceL1: ReduceL1LayerParams {
    get {
      if case .reduceL1(let v)? = _storage._layer {return v}
      return ReduceL1LayerParams()
    }
    set {_uniqueStorage()._layer = .reduceL1(newValue)}
  }

  public var reduceL2: ReduceL2LayerParams {
    get {
      if case .reduceL2(let v)? = _storage._layer {return v}
      return ReduceL2LayerParams()
    }
    set {_uniqueStorage()._layer = .reduceL2(newValue)}
  }

  public var reduceMax: ReduceMaxLayerParams {
    get {
      if case .reduceMax(let v)? = _storage._layer {return v}
      return ReduceMaxLayerParams()
    }
    set {_uniqueStorage()._layer = .reduceMax(newValue)}
  }

  public var reduceMin: ReduceMinLayerParams {
    get {
      if case .reduceMin(let v)? = _storage._layer {return v}
      return ReduceMinLayerParams()
    }
    set {_uniqueStorage()._layer = .reduceMin(newValue)}
  }

  public var reduceSum: ReduceSumLayerParams {
    get {
      if case .reduceSum(let v)? = _storage._layer {return v}
      return ReduceSumLayerParams()
    }
    set {_uniqueStorage()._layer = .reduceSum(newValue)}
  }

  public var reduceProd: ReduceProdLayerParams {
    get {
      if case .reduceProd(let v)? = _storage._layer {return v}
      return ReduceProdLayerParams()
    }
    set {_uniqueStorage()._layer = .reduceProd(newValue)}
  }

  public var reduceMean: ReduceMeanLayerParams {
    get {
      if case .reduceMean(let v)? = _storage._layer {return v}
      return ReduceMeanLayerParams()
    }
    set {_uniqueStorage()._layer = .reduceMean(newValue)}
  }

  public var reduceLogSum: ReduceLogSumLayerParams {
    get {
      if case .reduceLogSum(let v)? = _storage._layer {return v}
      return ReduceLogSumLayerParams()
    }
    set {_uniqueStorage()._layer = .reduceLogSum(newValue)}
  }

  public var reduceSumSquare: ReduceSumSquareLayerParams {
    get {
      if case .reduceSumSquare(let v)? = _storage._layer {return v}
      return ReduceSumSquareLayerParams()
    }
    set {_uniqueStorage()._layer = .reduceSumSquare(newValue)}
  }

  public var reduceLogSumExp: ReduceLogSumExpLayerParams {
    get {
      if case .reduceLogSumExp(let v)? = _storage._layer {return v}
      return ReduceLogSumExpLayerParams()
    }
    set {_uniqueStorage()._layer = .reduceLogSumExp(newValue)}
  }

  /// Masking / Selection Layers
  public var whereNonZero: WhereNonZeroLayerParams {
    get {
      if case .whereNonZero(let v)? = _storage._layer {return v}
      return WhereNonZeroLayerParams()
    }
    set {_uniqueStorage()._layer = .whereNonZero(newValue)}
  }

  public var matrixBandPart: MatrixBandPartLayerParams {
    get {
      if case .matrixBandPart(let v)? = _storage._layer {return v}
      return MatrixBandPartLayerParams()
    }
    set {_uniqueStorage()._layer = .matrixBandPart(newValue)}
  }

  public var lowerTriangular: LowerTriangularLayerParams {
    get {
      if case .lowerTriangular(let v)? = _storage._layer {return v}
      return LowerTriangularLayerParams()
    }
    set {_uniqueStorage()._layer = .lowerTriangular(newValue)}
  }

  public var upperTriangular: UpperTriangularLayerParams {
    get {
      if case .upperTriangular(let v)? = _storage._layer {return v}
      return UpperTriangularLayerParams()
    }
    set {_uniqueStorage()._layer = .upperTriangular(newValue)}
  }

  public var whereBroadcastable: WhereBroadcastableLayerParams {
    get {
      if case .whereBroadcastable(let v)? = _storage._layer {return v}
      return WhereBroadcastableLayerParams()
    }
    set {_uniqueStorage()._layer = .whereBroadcastable(newValue)}
  }

  /// Normalization Layers
  public var layerNormalization: LayerNormalizationLayerParams {
    get {
      if case .layerNormalization(let v)? = _storage._layer {return v}
      return LayerNormalizationLayerParams()
    }
    set {_uniqueStorage()._layer = .layerNormalization(newValue)}
  }

  public var nonMaximumSuppression: NonMaximumSuppressionLayerParams {
    get {
      if case .nonMaximumSuppression(let v)? = _storage._layer {return v}
      return NonMaximumSuppressionLayerParams()
    }
    set {_uniqueStorage()._layer = .nonMaximumSuppression(newValue)}
  }

  /// Following layers are available only after Core ML Specification
  /// version >= 5 (iOS >= 14, macOS >= 11.0)
  public var oneHot: OneHotLayerParams {
    get {
      if case .oneHot(let v)? = _storage._layer {return v}
      return OneHotLayerParams()
    }
    set {_uniqueStorage()._layer = .oneHot(newValue)}
  }

  public var cumSum: CumSumLayerParams {
    get {
      if case .cumSum(let v)? = _storage._layer {return v}
      return CumSumLayerParams()
    }
    set {_uniqueStorage()._layer = .cumSum(newValue)}
  }

  public var clampedReLu: ClampedReLULayerParams {
    get {
      if case .clampedReLu(let v)? = _storage._layer {return v}
      return ClampedReLULayerParams()
    }
    set {_uniqueStorage()._layer = .clampedReLu(newValue)}
  }

  public var argSort: ArgSortLayerParams {
    get {
      if case .argSort(let v)? = _storage._layer {return v}
      return ArgSortLayerParams()
    }
    set {_uniqueStorage()._layer = .argSort(newValue)}
  }

  public var pooling3D: Pooling3DLayerParams {
    get {
      if case .pooling3D(let v)? = _storage._layer {return v}
      return Pooling3DLayerParams()
    }
    set {_uniqueStorage()._layer = .pooling3D(newValue)}
  }

  public var globalPooling3D: GlobalPooling3DLayerParams {
    get {
      if case .globalPooling3D(let v)? = _storage._layer {return v}
      return GlobalPooling3DLayerParams()
    }
    set {_uniqueStorage()._layer = .globalPooling3D(newValue)}
  }

  public var sliceBySize: SliceBySizeLayerParams {
    get {
      if case .sliceBySize(let v)? = _storage._layer {return v}
      return SliceBySizeLayerParams()
    }
    set {_uniqueStorage()._layer = .sliceBySize(newValue)}
  }

  public var convolution3D: Convolution3DLayerParams {
    get {
      if case .convolution3D(let v)? = _storage._layer {return v}
      return Convolution3DLayerParams()
    }
    set {_uniqueStorage()._layer = .convolution3D(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Layer: Equatable {
    /// Start at 100 here
    case convolution(ConvolutionLayerParams)
    case pooling(PoolingLayerParams)
    case activation(ActivationParams)
    case innerProduct(InnerProductLayerParams)
    case embedding(EmbeddingLayerParams)
    /// Normalization-related Layers
    case batchnorm(BatchnormLayerParams)
    case mvn(MeanVarianceNormalizeLayerParams)
    case l2Normalize(L2NormalizeLayerParams)
    case softmax(SoftmaxLayerParams)
    case lrn(LRNLayerParams)
    case crop(CropLayerParams)
    case padding(PaddingLayerParams)
    case upsample(UpsampleLayerParams)
    case resizeBilinear(ResizeBilinearLayerParams)
    case cropResize(CropResizeLayerParams)
    case unary(UnaryFunctionLayerParams)
    /// Element-wise Operations
    case add(AddLayerParams)
    case multiply(MultiplyLayerParams)
    case average(AverageLayerParams)
    case scale(ScaleLayerParams)
    case bias(BiasLayerParams)
    case max(MaxLayerParams)
    case min(MinLayerParams)
    case dot(DotProductLayerParams)
    case reduce(ReduceLayerParams)
    case loadConstant(LoadConstantLayerParams)
    /// Data Reorganization
    case reshape(ReshapeLayerParams)
    case flatten(FlattenLayerParams)
    case permute(PermuteLayerParams)
    case concat(ConcatLayerParams)
    case split(SplitLayerParams)
    case sequenceRepeat(SequenceRepeatLayerParams)
    case reorganizeData(ReorganizeDataLayerParams)
    case slice(SliceLayerParams)
    /// Recurrent Layers
    case simpleRecurrent(SimpleRecurrentLayerParams)
    case gru(GRULayerParams)
    case uniDirectionalLstm(UniDirectionalLSTMLayerParams)
    case biDirectionalLstm(BiDirectionalLSTMLayerParams)
    /// Custom (user-implemented) Layer
    case custom(CustomLayerParams)
    /// Control Flow related Layers
    case copy(CopyLayerParams)
    case branch(BranchLayerParams)
    case loop(LoopLayerParams)
    case loopBreak(LoopBreakLayerParams)
    case loopContinue(LoopContinueLayerParams)
    case rangeStatic(RangeStaticLayerParams)
    case rangeDynamic(RangeDynamicLayerParams)
    /// Element-wise Unary Layers
    case clip(ClipLayerParams)
    case ceil(CeilLayerParams)
    case floor(FloorLayerParams)
    case sign(SignLayerParams)
    case round(RoundLayerParams)
    case exp2(Exp2LayerParams)
    case sin(SinLayerParams)
    case cos(CosLayerParams)
    case tan(TanLayerParams)
    case asin(AsinLayerParams)
    case acos(AcosLayerParams)
    case atan(AtanLayerParams)
    case sinh(SinhLayerParams)
    case cosh(CoshLayerParams)
    case tanh(TanhLayerParams)
    case asinh(AsinhLayerParams)
    case acosh(AcoshLayerParams)
    case atanh(AtanhLayerParams)
    case erf(ErfLayerParams)
    case gelu(GeluLayerParams)
    /// Element-wise Binary with Broadcasting Support
    case equal(EqualLayerParams)
    case notEqual(NotEqualLayerParams)
    case lessThan(LessThanLayerParams)
    case lessEqual(LessEqualLayerParams)
    case greaterThan(GreaterThanLayerParams)
    case greaterEqual(GreaterEqualLayerParams)
    case logicalOr(LogicalOrLayerParams)
    case logicalXor(LogicalXorLayerParams)
    case logicalNot(LogicalNotLayerParams)
    case logicalAnd(LogicalAndLayerParams)
    case modBroadcastable(ModBroadcastableLayerParams)
    case minBroadcastable(MinBroadcastableLayerParams)
    case maxBroadcastable(MaxBroadcastableLayerParams)
    case addBroadcastable(AddBroadcastableLayerParams)
    case powBroadcastable(PowBroadcastableLayerParams)
    case divideBroadcastable(DivideBroadcastableLayerParams)
    case floorDivBroadcastable(FloorDivBroadcastableLayerParams)
    case multiplyBroadcastable(MultiplyBroadcastableLayerParams)
    case subtractBroadcastable(SubtractBroadcastableLayerParams)
    /// Tensor Manipulations
    case tile(TileLayerParams)
    case stack(StackLayerParams)
    case gather(GatherLayerParams)
    case scatter(ScatterLayerParams)
    case gatherNd(GatherNDLayerParams)
    case scatterNd(ScatterNDLayerParams)
    case softmaxNd(SoftmaxNDLayerParams)
    case gatherAlongAxis(GatherAlongAxisLayerParams)
    case scatterAlongAxis(ScatterAlongAxisLayerParams)
    case reverse(ReverseLayerParams)
    case reverseSeq(ReverseSeqLayerParams)
    case splitNd(SplitNDLayerParams)
    case concatNd(ConcatNDLayerParams)
    case transpose(TransposeLayerParams)
    case sliceStatic(SliceStaticLayerParams)
    case sliceDynamic(SliceDynamicLayerParams)
    case slidingWindows(SlidingWindowsLayerParams)
    case topK(TopKLayerParams)
    case argMin(ArgMinLayerParams)
    case argMax(ArgMaxLayerParams)
    case embeddingNd(EmbeddingNDLayerParams)
    case batchedMatmul(BatchedMatMulLayerParams)
    /// Tensor Allocation / Reshape-related Operations
    case getShape(GetShapeLayerParams)
    case loadConstantNd(LoadConstantNDLayerParams)
    case fillLike(FillLikeLayerParams)
    case fillStatic(FillStaticLayerParams)
    case fillDynamic(FillDynamicLayerParams)
    case broadcastToLike(BroadcastToLikeLayerParams)
    case broadcastToStatic(BroadcastToStaticLayerParams)
    case broadcastToDynamic(BroadcastToDynamicLayerParams)
    case squeeze(SqueezeLayerParams)
    case expandDims(ExpandDimsLayerParams)
    case flattenTo2D(FlattenTo2DLayerParams)
    case reshapeLike(ReshapeLikeLayerParams)
    case reshapeStatic(ReshapeStaticLayerParams)
    case reshapeDynamic(ReshapeDynamicLayerParams)
    case rankPreservingReshape(RankPreservingReshapeLayerParams)
    case constantPad(ConstantPaddingLayerParams)
    /// Random Distributions
    case randomNormalLike(RandomNormalLikeLayerParams)
    case randomNormalStatic(RandomNormalStaticLayerParams)
    case randomNormalDynamic(RandomNormalDynamicLayerParams)
    case randomUniformLike(RandomUniformLikeLayerParams)
    case randomUniformStatic(RandomUniformStaticLayerParams)
    case randomUniformDynamic(RandomUniformDynamicLayerParams)
    case randomBernoulliLike(RandomBernoulliLikeLayerParams)
    case randomBernoulliStatic(RandomBernoulliStaticLayerParams)
    case randomBernoulliDynamic(RandomBernoulliDynamicLayerParams)
    case categoricalDistribution(CategoricalDistributionLayerParams)
    /// Reduction-related Layers:
    case reduceL1(ReduceL1LayerParams)
    case reduceL2(ReduceL2LayerParams)
    case reduceMax(ReduceMaxLayerParams)
    case reduceMin(ReduceMinLayerParams)
    case reduceSum(ReduceSumLayerParams)
    case reduceProd(ReduceProdLayerParams)
    case reduceMean(ReduceMeanLayerParams)
    case reduceLogSum(ReduceLogSumLayerParams)
    case reduceSumSquare(ReduceSumSquareLayerParams)
    case reduceLogSumExp(ReduceLogSumExpLayerParams)
    /// Masking / Selection Layers
    case whereNonZero(WhereNonZeroLayerParams)
    case matrixBandPart(MatrixBandPartLayerParams)
    case lowerTriangular(LowerTriangularLayerParams)
    case upperTriangular(UpperTriangularLayerParams)
    case whereBroadcastable(WhereBroadcastableLayerParams)
    /// Normalization Layers
    case layerNormalization(LayerNormalizationLayerParams)
    case nonMaximumSuppression(NonMaximumSuppressionLayerParams)
    /// Following layers are available only after Core ML Specification
    /// version >= 5 (iOS >= 14, macOS >= 11.0)
    case oneHot(OneHotLayerParams)
    case cumSum(CumSumLayerParams)
    case clampedReLu(ClampedReLULayerParams)
    case argSort(ArgSortLayerParams)
    case pooling3D(Pooling3DLayerParams)
    case globalPooling3D(GlobalPooling3DLayerParams)
    case sliceBySize(SliceBySizeLayerParams)
    case convolution3D(Convolution3DLayerParams)

  #if !swift(>=4.1)
    public static func ==(lhs: NeuralNetworkLayer.OneOf_Layer, rhs: NeuralNetworkLayer.OneOf_Layer) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.convolution, .convolution): return {
        guard case .convolution(let l) = lhs, case .convolution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pooling, .pooling): return {
        guard case .pooling(let l) = lhs, case .pooling(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activation, .activation): return {
        guard case .activation(let l) = lhs, case .activation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.innerProduct, .innerProduct): return {
        guard case .innerProduct(let l) = lhs, case .innerProduct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.embedding, .embedding): return {
        guard case .embedding(let l) = lhs, case .embedding(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.batchnorm, .batchnorm): return {
        guard case .batchnorm(let l) = lhs, case .batchnorm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mvn, .mvn): return {
        guard case .mvn(let l) = lhs, case .mvn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.l2Normalize, .l2Normalize): return {
        guard case .l2Normalize(let l) = lhs, case .l2Normalize(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.softmax, .softmax): return {
        guard case .softmax(let l) = lhs, case .softmax(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lrn, .lrn): return {
        guard case .lrn(let l) = lhs, case .lrn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.crop, .crop): return {
        guard case .crop(let l) = lhs, case .crop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.padding, .padding): return {
        guard case .padding(let l) = lhs, case .padding(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upsample, .upsample): return {
        guard case .upsample(let l) = lhs, case .upsample(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resizeBilinear, .resizeBilinear): return {
        guard case .resizeBilinear(let l) = lhs, case .resizeBilinear(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cropResize, .cropResize): return {
        guard case .cropResize(let l) = lhs, case .cropResize(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unary, .unary): return {
        guard case .unary(let l) = lhs, case .unary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.add, .add): return {
        guard case .add(let l) = lhs, case .add(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multiply, .multiply): return {
        guard case .multiply(let l) = lhs, case .multiply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.average, .average): return {
        guard case .average(let l) = lhs, case .average(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scale, .scale): return {
        guard case .scale(let l) = lhs, case .scale(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bias, .bias): return {
        guard case .bias(let l) = lhs, case .bias(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.max, .max): return {
        guard case .max(let l) = lhs, case .max(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.min, .min): return {
        guard case .min(let l) = lhs, case .min(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dot, .dot): return {
        guard case .dot(let l) = lhs, case .dot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduce, .reduce): return {
        guard case .reduce(let l) = lhs, case .reduce(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadConstant, .loadConstant): return {
        guard case .loadConstant(let l) = lhs, case .loadConstant(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reshape, .reshape): return {
        guard case .reshape(let l) = lhs, case .reshape(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.flatten, .flatten): return {
        guard case .flatten(let l) = lhs, case .flatten(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permute, .permute): return {
        guard case .permute(let l) = lhs, case .permute(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.concat, .concat): return {
        guard case .concat(let l) = lhs, case .concat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.split, .split): return {
        guard case .split(let l) = lhs, case .split(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sequenceRepeat, .sequenceRepeat): return {
        guard case .sequenceRepeat(let l) = lhs, case .sequenceRepeat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reorganizeData, .reorganizeData): return {
        guard case .reorganizeData(let l) = lhs, case .reorganizeData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.slice, .slice): return {
        guard case .slice(let l) = lhs, case .slice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.simpleRecurrent, .simpleRecurrent): return {
        guard case .simpleRecurrent(let l) = lhs, case .simpleRecurrent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gru, .gru): return {
        guard case .gru(let l) = lhs, case .gru(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uniDirectionalLstm, .uniDirectionalLstm): return {
        guard case .uniDirectionalLstm(let l) = lhs, case .uniDirectionalLstm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.biDirectionalLstm, .biDirectionalLstm): return {
        guard case .biDirectionalLstm(let l) = lhs, case .biDirectionalLstm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.custom, .custom): return {
        guard case .custom(let l) = lhs, case .custom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.copy, .copy): return {
        guard case .copy(let l) = lhs, case .copy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.branch, .branch): return {
        guard case .branch(let l) = lhs, case .branch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loop, .loop): return {
        guard case .loop(let l) = lhs, case .loop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loopBreak, .loopBreak): return {
        guard case .loopBreak(let l) = lhs, case .loopBreak(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loopContinue, .loopContinue): return {
        guard case .loopContinue(let l) = lhs, case .loopContinue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rangeStatic, .rangeStatic): return {
        guard case .rangeStatic(let l) = lhs, case .rangeStatic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rangeDynamic, .rangeDynamic): return {
        guard case .rangeDynamic(let l) = lhs, case .rangeDynamic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clip, .clip): return {
        guard case .clip(let l) = lhs, case .clip(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ceil, .ceil): return {
        guard case .ceil(let l) = lhs, case .ceil(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.floor, .floor): return {
        guard case .floor(let l) = lhs, case .floor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sign, .sign): return {
        guard case .sign(let l) = lhs, case .sign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.round, .round): return {
        guard case .round(let l) = lhs, case .round(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exp2, .exp2): return {
        guard case .exp2(let l) = lhs, case .exp2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sin, .sin): return {
        guard case .sin(let l) = lhs, case .sin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cos, .cos): return {
        guard case .cos(let l) = lhs, case .cos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tan, .tan): return {
        guard case .tan(let l) = lhs, case .tan(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.asin, .asin): return {
        guard case .asin(let l) = lhs, case .asin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acos, .acos): return {
        guard case .acos(let l) = lhs, case .acos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.atan, .atan): return {
        guard case .atan(let l) = lhs, case .atan(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sinh, .sinh): return {
        guard case .sinh(let l) = lhs, case .sinh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cosh, .cosh): return {
        guard case .cosh(let l) = lhs, case .cosh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tanh, .tanh): return {
        guard case .tanh(let l) = lhs, case .tanh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.asinh, .asinh): return {
        guard case .asinh(let l) = lhs, case .asinh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acosh, .acosh): return {
        guard case .acosh(let l) = lhs, case .acosh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.atanh, .atanh): return {
        guard case .atanh(let l) = lhs, case .atanh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.erf, .erf): return {
        guard case .erf(let l) = lhs, case .erf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gelu, .gelu): return {
        guard case .gelu(let l) = lhs, case .gelu(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.equal, .equal): return {
        guard case .equal(let l) = lhs, case .equal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notEqual, .notEqual): return {
        guard case .notEqual(let l) = lhs, case .notEqual(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lessThan, .lessThan): return {
        guard case .lessThan(let l) = lhs, case .lessThan(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lessEqual, .lessEqual): return {
        guard case .lessEqual(let l) = lhs, case .lessEqual(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.greaterThan, .greaterThan): return {
        guard case .greaterThan(let l) = lhs, case .greaterThan(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.greaterEqual, .greaterEqual): return {
        guard case .greaterEqual(let l) = lhs, case .greaterEqual(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logicalOr, .logicalOr): return {
        guard case .logicalOr(let l) = lhs, case .logicalOr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logicalXor, .logicalXor): return {
        guard case .logicalXor(let l) = lhs, case .logicalXor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logicalNot, .logicalNot): return {
        guard case .logicalNot(let l) = lhs, case .logicalNot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logicalAnd, .logicalAnd): return {
        guard case .logicalAnd(let l) = lhs, case .logicalAnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.modBroadcastable, .modBroadcastable): return {
        guard case .modBroadcastable(let l) = lhs, case .modBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.minBroadcastable, .minBroadcastable): return {
        guard case .minBroadcastable(let l) = lhs, case .minBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.maxBroadcastable, .maxBroadcastable): return {
        guard case .maxBroadcastable(let l) = lhs, case .maxBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addBroadcastable, .addBroadcastable): return {
        guard case .addBroadcastable(let l) = lhs, case .addBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.powBroadcastable, .powBroadcastable): return {
        guard case .powBroadcastable(let l) = lhs, case .powBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.divideBroadcastable, .divideBroadcastable): return {
        guard case .divideBroadcastable(let l) = lhs, case .divideBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.floorDivBroadcastable, .floorDivBroadcastable): return {
        guard case .floorDivBroadcastable(let l) = lhs, case .floorDivBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multiplyBroadcastable, .multiplyBroadcastable): return {
        guard case .multiplyBroadcastable(let l) = lhs, case .multiplyBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subtractBroadcastable, .subtractBroadcastable): return {
        guard case .subtractBroadcastable(let l) = lhs, case .subtractBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tile, .tile): return {
        guard case .tile(let l) = lhs, case .tile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stack, .stack): return {
        guard case .stack(let l) = lhs, case .stack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gather, .gather): return {
        guard case .gather(let l) = lhs, case .gather(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scatter, .scatter): return {
        guard case .scatter(let l) = lhs, case .scatter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gatherNd, .gatherNd): return {
        guard case .gatherNd(let l) = lhs, case .gatherNd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scatterNd, .scatterNd): return {
        guard case .scatterNd(let l) = lhs, case .scatterNd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.softmaxNd, .softmaxNd): return {
        guard case .softmaxNd(let l) = lhs, case .softmaxNd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gatherAlongAxis, .gatherAlongAxis): return {
        guard case .gatherAlongAxis(let l) = lhs, case .gatherAlongAxis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scatterAlongAxis, .scatterAlongAxis): return {
        guard case .scatterAlongAxis(let l) = lhs, case .scatterAlongAxis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reverse, .reverse): return {
        guard case .reverse(let l) = lhs, case .reverse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reverseSeq, .reverseSeq): return {
        guard case .reverseSeq(let l) = lhs, case .reverseSeq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.splitNd, .splitNd): return {
        guard case .splitNd(let l) = lhs, case .splitNd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.concatNd, .concatNd): return {
        guard case .concatNd(let l) = lhs, case .concatNd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transpose, .transpose): return {
        guard case .transpose(let l) = lhs, case .transpose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sliceStatic, .sliceStatic): return {
        guard case .sliceStatic(let l) = lhs, case .sliceStatic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sliceDynamic, .sliceDynamic): return {
        guard case .sliceDynamic(let l) = lhs, case .sliceDynamic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.slidingWindows, .slidingWindows): return {
        guard case .slidingWindows(let l) = lhs, case .slidingWindows(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.topK, .topK): return {
        guard case .topK(let l) = lhs, case .topK(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.argMin, .argMin): return {
        guard case .argMin(let l) = lhs, case .argMin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.argMax, .argMax): return {
        guard case .argMax(let l) = lhs, case .argMax(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.embeddingNd, .embeddingNd): return {
        guard case .embeddingNd(let l) = lhs, case .embeddingNd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.batchedMatmul, .batchedMatmul): return {
        guard case .batchedMatmul(let l) = lhs, case .batchedMatmul(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getShape, .getShape): return {
        guard case .getShape(let l) = lhs, case .getShape(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadConstantNd, .loadConstantNd): return {
        guard case .loadConstantNd(let l) = lhs, case .loadConstantNd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fillLike, .fillLike): return {
        guard case .fillLike(let l) = lhs, case .fillLike(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fillStatic, .fillStatic): return {
        guard case .fillStatic(let l) = lhs, case .fillStatic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fillDynamic, .fillDynamic): return {
        guard case .fillDynamic(let l) = lhs, case .fillDynamic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.broadcastToLike, .broadcastToLike): return {
        guard case .broadcastToLike(let l) = lhs, case .broadcastToLike(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.broadcastToStatic, .broadcastToStatic): return {
        guard case .broadcastToStatic(let l) = lhs, case .broadcastToStatic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.broadcastToDynamic, .broadcastToDynamic): return {
        guard case .broadcastToDynamic(let l) = lhs, case .broadcastToDynamic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.squeeze, .squeeze): return {
        guard case .squeeze(let l) = lhs, case .squeeze(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expandDims, .expandDims): return {
        guard case .expandDims(let l) = lhs, case .expandDims(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.flattenTo2D, .flattenTo2D): return {
        guard case .flattenTo2D(let l) = lhs, case .flattenTo2D(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reshapeLike, .reshapeLike): return {
        guard case .reshapeLike(let l) = lhs, case .reshapeLike(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reshapeStatic, .reshapeStatic): return {
        guard case .reshapeStatic(let l) = lhs, case .reshapeStatic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reshapeDynamic, .reshapeDynamic): return {
        guard case .reshapeDynamic(let l) = lhs, case .reshapeDynamic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rankPreservingReshape, .rankPreservingReshape): return {
        guard case .rankPreservingReshape(let l) = lhs, case .rankPreservingReshape(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.constantPad, .constantPad): return {
        guard case .constantPad(let l) = lhs, case .constantPad(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomNormalLike, .randomNormalLike): return {
        guard case .randomNormalLike(let l) = lhs, case .randomNormalLike(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomNormalStatic, .randomNormalStatic): return {
        guard case .randomNormalStatic(let l) = lhs, case .randomNormalStatic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomNormalDynamic, .randomNormalDynamic): return {
        guard case .randomNormalDynamic(let l) = lhs, case .randomNormalDynamic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomUniformLike, .randomUniformLike): return {
        guard case .randomUniformLike(let l) = lhs, case .randomUniformLike(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomUniformStatic, .randomUniformStatic): return {
        guard case .randomUniformStatic(let l) = lhs, case .randomUniformStatic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomUniformDynamic, .randomUniformDynamic): return {
        guard case .randomUniformDynamic(let l) = lhs, case .randomUniformDynamic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomBernoulliLike, .randomBernoulliLike): return {
        guard case .randomBernoulliLike(let l) = lhs, case .randomBernoulliLike(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomBernoulliStatic, .randomBernoulliStatic): return {
        guard case .randomBernoulliStatic(let l) = lhs, case .randomBernoulliStatic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomBernoulliDynamic, .randomBernoulliDynamic): return {
        guard case .randomBernoulliDynamic(let l) = lhs, case .randomBernoulliDynamic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.categoricalDistribution, .categoricalDistribution): return {
        guard case .categoricalDistribution(let l) = lhs, case .categoricalDistribution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceL1, .reduceL1): return {
        guard case .reduceL1(let l) = lhs, case .reduceL1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceL2, .reduceL2): return {
        guard case .reduceL2(let l) = lhs, case .reduceL2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceMax, .reduceMax): return {
        guard case .reduceMax(let l) = lhs, case .reduceMax(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceMin, .reduceMin): return {
        guard case .reduceMin(let l) = lhs, case .reduceMin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceSum, .reduceSum): return {
        guard case .reduceSum(let l) = lhs, case .reduceSum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceProd, .reduceProd): return {
        guard case .reduceProd(let l) = lhs, case .reduceProd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceMean, .reduceMean): return {
        guard case .reduceMean(let l) = lhs, case .reduceMean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceLogSum, .reduceLogSum): return {
        guard case .reduceLogSum(let l) = lhs, case .reduceLogSum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceSumSquare, .reduceSumSquare): return {
        guard case .reduceSumSquare(let l) = lhs, case .reduceSumSquare(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reduceLogSumExp, .reduceLogSumExp): return {
        guard case .reduceLogSumExp(let l) = lhs, case .reduceLogSumExp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whereNonZero, .whereNonZero): return {
        guard case .whereNonZero(let l) = lhs, case .whereNonZero(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matrixBandPart, .matrixBandPart): return {
        guard case .matrixBandPart(let l) = lhs, case .matrixBandPart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lowerTriangular, .lowerTriangular): return {
        guard case .lowerTriangular(let l) = lhs, case .lowerTriangular(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upperTriangular, .upperTriangular): return {
        guard case .upperTriangular(let l) = lhs, case .upperTriangular(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whereBroadcastable, .whereBroadcastable): return {
        guard case .whereBroadcastable(let l) = lhs, case .whereBroadcastable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.layerNormalization, .layerNormalization): return {
        guard case .layerNormalization(let l) = lhs, case .layerNormalization(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nonMaximumSuppression, .nonMaximumSuppression): return {
        guard case .nonMaximumSuppression(let l) = lhs, case .nonMaximumSuppression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oneHot, .oneHot): return {
        guard case .oneHot(let l) = lhs, case .oneHot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cumSum, .cumSum): return {
        guard case .cumSum(let l) = lhs, case .cumSum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clampedReLu, .clampedReLu): return {
        guard case .clampedReLu(let l) = lhs, case .clampedReLu(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.argSort, .argSort): return {
        guard case .argSort(let l) = lhs, case .argSort(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pooling3D, .pooling3D): return {
        guard case .pooling3D(let l) = lhs, case .pooling3D(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.globalPooling3D, .globalPooling3D): return {
        guard case .globalPooling3D(let l) = lhs, case .globalPooling3D(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sliceBySize, .sliceBySize): return {
        guard case .sliceBySize(let l) = lhs, case .sliceBySize(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.convolution3D, .convolution3D): return {
        guard case .convolution3D(let l) = lhs, case .convolution3D(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Branching Layer
///
/// A layer that provides the functionality of branching or an If-Else block.
///
/// Must have 1 input. There are no outputs as the execution is transferred to either the
/// if or the else branch based on the value of the input.
///
/// Input is the condition predicate. Must be a scalar (length 1 tensor).
public struct BranchLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// execute this graph if the absolute value of the input Tensor is greater than 1e-6
  /// This must be present.
  public var ifBranch: NeuralNetwork {
    get {return _ifBranch ?? NeuralNetwork()}
    set {_ifBranch = newValue}
  }
  /// Returns true if `ifBranch` has been explicitly set.
  public var hasIfBranch: Bool {return self._ifBranch != nil}
  /// Clears the value of `ifBranch`. Subsequent reads from it will return its default value.
  public mutating func clearIfBranch() {self._ifBranch = nil}

  ///
  /// execute this graph if the absolute value of the input Tensor is less than 1e-6
  /// This is optional.
  public var elseBranch: NeuralNetwork {
    get {return _elseBranch ?? NeuralNetwork()}
    set {_elseBranch = newValue}
  }
  /// Returns true if `elseBranch` has been explicitly set.
  public var hasElseBranch: Bool {return self._elseBranch != nil}
  /// Clears the value of `elseBranch`. Subsequent reads from it will return its default value.
  public mutating func clearElseBranch() {self._elseBranch = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ifBranch: NeuralNetwork? = nil
  fileprivate var _elseBranch: NeuralNetwork? = nil
}

///
/// Loop Layer
///
/// A layer that provides the functionality of a "for" loop or a "while" loop.
///
/// There are either no inputs or 1 input. When an input is present, it corresponds to the maximum loop count,
/// in that case the value of the "maxLoopIterations" field is ignored. Input must be a scalar.
/// (For description below, maxLoopIterations is assumed to be the value of the input, when its present)
///
/// No outputs are produced. Blobs produced by the condition or the body network are visible in the scope of the overall network.
///
/// "conditionNetwork" must produce a tensor with the name specified in the "conditionVar" field.
///
/// There are 3 possible cases for determining the termination condition:
///
/// Case 1:
///
/// If there is no "conditionNetwork", in this case the layer corresponds to a pure for loop, which is run "maxLoopIterations" number of times.
/// Equivalent pseudo-code:
///
/// for loopIterator = 0 : maxLoopIterations
///      bodyNetwork()
///
///
/// Case 2:
///
/// "conditionNetwork" is present, and "maxLoopIterations" is 0 and there is no input,
/// in this case the layer corresponds to a while loop. Equivalent pseudo-code:
///
/// conditionVar = conditionNetwork()
/// while conditionVar:
///      bodyNetwork()
///      conditionVar = conditionNetwork()
///
///
/// Case 3:
///
/// "conditionNetwork" is provided, and "maxLoopIterations" is positive or there is an input,
/// in this case the layer corresponds to a while loop with a joint condition. Equivalent pseudo-code:
///
/// loopIterator = 0
/// conditionVar = conditionNetwork()
/// while (conditionVar and loopIterator < maxLoopIterations):
///      bodyNetwork()
///      loopIterator = loopIterator + 1
///      conditionVar = conditionNetwork()
public struct LoopLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// maximum number of iterations. Ignored if input is present.
  public var maxLoopIterations: UInt64 = 0

  ///
  /// This field provides the name of the tensor which is produced by the conditionNetwork
  /// and whose value is checked to start/continue/terminate the loop. Value close to 0.0f is treated as False.
  /// This field is optional.
  /// Must be a non empty string if and only if "conditionNetwork" is present.
  public var conditionVar: String = String()

  ///
  /// Must generate a tensor with the name provided in the "conditionVar" field.
  /// This field is optional.
  /// Must be present if and only if "conditionVar" field is a non empty string.
  public var conditionNetwork: NeuralNetwork {
    get {return _conditionNetwork ?? NeuralNetwork()}
    set {_conditionNetwork = newValue}
  }
  /// Returns true if `conditionNetwork` has been explicitly set.
  public var hasConditionNetwork: Bool {return self._conditionNetwork != nil}
  /// Clears the value of `conditionNetwork`. Subsequent reads from it will return its default value.
  public mutating func clearConditionNetwork() {self._conditionNetwork = nil}

  ///
  /// Body of the loop.
  /// This field must be present.
  public var bodyNetwork: NeuralNetwork {
    get {return _bodyNetwork ?? NeuralNetwork()}
    set {_bodyNetwork = newValue}
  }
  /// Returns true if `bodyNetwork` has been explicitly set.
  public var hasBodyNetwork: Bool {return self._bodyNetwork != nil}
  /// Clears the value of `bodyNetwork`. Subsequent reads from it will return its default value.
  public mutating func clearBodyNetwork() {self._bodyNetwork = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conditionNetwork: NeuralNetwork? = nil
  fileprivate var _bodyNetwork: NeuralNetwork? = nil
}

///
/// Loop break Layer
///
/// Terminate the loop that has this layer.
/// If present, it should always reside in the "bodyNetwork" of the loop layer
///
/// No inputs/outputs
public struct LoopBreakLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Loop Continue Layer
///
/// Stop the current loop iteration and continue on the next iteration.
/// If present, it should always reside in the "bodyNetwork" of the loop layer
///
/// No inputs/outputs
public struct LoopContinueLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Copy Layer
///
/// A layer that copies its input tensor to the output tensor.
/// Must have 1 input and 1 output, with distinct names.
/// This is the only layer that is allowed to re-generate an output that is already present in the neural network prior to this layer,
/// in which case it will overwrite the output tensor.
public struct CopyLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// GreaterThan Layer
///
/// Either 1 or 2 inputs.
/// Produces 1 output.
/// Perform elementwise greater than operation.
///
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = x1 > x2
///          or
///      y = x1 > alpha, if only one input is provided
///
/// Broadcasting is supported.
public struct GreaterThanLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Compare to the scalar value provided here if there is 1 input
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// GreaterEqual Layer
///
/// Either 1 or 2 inputs.
/// Produces 1 output.
/// Perform elementwise greater equal operation.
///
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = x1 >= x2
///          or
///      y = x1 >= alpha, if only one input is provided
///
/// Broadcasting is supported.
public struct GreaterEqualLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Compare to the scalar value provided here if there is 1 input
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// LessThan Layer
///
/// Either 1 or 2 inputs.
/// Produces 1 output.
/// Perform elementwise less than operation.
///
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = x1 < x2
///          or
///      y = x1 < alpha, if only one input is provided
///
/// Broadcasting is supported.
public struct LessThanLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Compare to the scalar value provided here if there is 1 input
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// LessEqual Layer
///
/// Either 1 or 2 inputs.
/// Produces 1 output.
/// Perform elementwise less equal operation.
///
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = x1 <= x2
///          or
///      y = x1 <= alpha, if only one input is provided
///
/// Broadcasting is supported.
public struct LessEqualLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Compare to the scalar value provided here if there is 1 input
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Equal Layer
///
/// Either 1 or 2 inputs.
/// Produces 1 output.
/// Perform elementwise equal operation.
///
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = x1 == x2
///          or
///      y = x1 == alpha, if only one input is provided
///
/// Broadcasting is supported.
public struct EqualLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Compare to the scalar value provided here if there is 1 input
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// NotEqual Layer
///
/// Either 1 or 2 inputs.
/// Produces 1 output.
/// Perform elementwise not equal operation.
///
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = x1 != x2
///          or
///      y = x1 != alpha, if only one input is provided
///
/// Broadcasting is supported.
public struct NotEqualLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Compare to the scalar value provided here if there is 1 input
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// LogicalAnd Layer
///
/// Must have 2 inputs, produces 1 output.
/// Perform elementwise logical AND operation.
///
/// Input is considered False if equal to 0.0f otherwise True.
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = AND(x1, x2)
///
/// Broadcasting is supported.
public struct LogicalAndLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// LogicalOr Layer
///
/// Must have 2 inputs, produces 1 output.
/// Perform elementwise logical OR operation.
///
/// Input is considered False if equal to 0.0f otherwise True.
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = OR(x1, x2)
///
/// Broadcasting is supported.
public struct LogicalOrLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// LogicalXor Layer
///
/// Must have 2 inputs, produces 1 output.
/// Perform elementwise logical XOR operation.
///
/// Input is considered False if equal to 0.0f otherwise True.
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = XOR(x1, x2)
///
/// Broadcasting is supported.
public struct LogicalXorLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// LogicalNot Layer
///
/// Must have 1 input, produces 1 output.
/// Perform elementwise logical NOT operation.
///
/// Input is considered False if equal to 0.0f otherwise True.
/// Output is 1.0f if the condition is true otherwise 0.0f.
///
/// .. code::
///
///      y = NOT(x)
public struct LogicalNotLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Specifies the amount of spatial border to be either padded or cropped.
///
/// For padding:
///
/// .. code::
///
///     H_out = borderAmounts[0].startEdgeSize + H_in + borderAmounts[0].endEdgeSize
///     W_out = borderAmounts[1].startEdgeSize + W_in + borderAmounts[1].endEdgeSize
///
///     topPaddingAmount == Height startEdgeSize
///     bottomPaddingAmount == Height endEdgeSize
///     leftPaddingAmount == Width startEdgeSize
///     rightPaddingAmount == Width endEdgeSize
///
/// For cropping:
///
/// .. code::
///
///     H_out = (-borderAmounts[0].startEdgeSize) + H_in + (-borderAmounts[0].endEdgeSize)
///     W_out = (-borderAmounts[1].startEdgeSize) + W_in + (-borderAmounts[1].endEdgeSize)
///
///     topCropAmount == Height startEdgeSize
///     bottomCropAmount == Height endEdgeSize
///     leftCropAmount == Width startEdgeSize
///     rightCropAmount == Width endEdgeSize
public struct BorderAmounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The border amounts.
  /// This must be length 2 in the order ``[H, W]``.
  public var borderAmounts: [BorderAmounts.EdgeSizes] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct EdgeSizes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// The amount to be padded or cropped from the beginning.
    public var startEdgeSize: UInt64 = 0

    ///
    /// The amount to be padded or cropped from the end.
    public var endEdgeSize: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

///
/// Specifies the type of padding to be used with Convolution/Deconvolution and Pooling layers.
/// After padding, input spatial shape: ``[H_in, W_in]``, gets modified to the
/// output spatial shape ``[H_out, W_out]``.
///
/// .. code::
///
///      topPaddingAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
///      bottomPaddingAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
///      leftPaddingAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
///      rightPaddingAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
///
/// With Convolution or Pooling:
///
/// .. code::
///
///    H_out = int_division_round_down((H_in + topPaddingAmount + bottomPaddingAmount - KernelSize[0]),stride[0]) + 1
///
/// which is same as:
///
/// .. code::
///
///    H_out = int_division_round_up((H_in + topPaddingAmount + bottomPaddingAmount - KernelSize[0] + 1),stride[0])
///
/// With Deconvolution:
///
/// .. code::
///
///    H_out = (H_in-1) * stride[0] + kernelSize[0] - (topPaddingAmount + bottomPaddingAmount)
///
///
/// The equivalent expressions hold true for ``W_out`` as well.
///
///
/// By default, the values of ``paddingAmounts`` are set to ``0``,
/// which results in a "true" valid padding.
/// If non-zero values are provided for ``paddingAmounts``,
/// "valid" convolution/pooling is performed within the spatially expanded input.
public struct ValidPadding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paddingAmounts: BorderAmounts {
    get {return _paddingAmounts ?? BorderAmounts()}
    set {_paddingAmounts = newValue}
  }
  /// Returns true if `paddingAmounts` has been explicitly set.
  public var hasPaddingAmounts: Bool {return self._paddingAmounts != nil}
  /// Clears the value of `paddingAmounts`. Subsequent reads from it will return its default value.
  public mutating func clearPaddingAmounts() {self._paddingAmounts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paddingAmounts: BorderAmounts? = nil
}

///
/// Specifies the type of padding to be used with Convolution/Deconvolution and pooling layers.
/// After padding, input spatial shape: ``[H_in, W_in]``, gets modified to the
/// output spatial shape ``[H_out, W_out]``.
/// With Convolution or pooling:
///
/// .. code::
///
///      H_out = int_division_round_up(H_in,stride[0])
///      W_out = int_division_round_up(W_in,stride[1])
///
/// This is achieved by using the following padding amounts:
///
/// .. code::
///
///     totalPaddingHeight = max(0,(H_out-1) * stride[0] + KernelSize[0] - Hin)
///     totalPaddingWidth = max(0,(W_out-1) * stride[1] + KernelSize[1] - Win)
///
/// There are two modes of asymmetry:
/// ``BOTTOM_RIGHT_HEAVY``, and ``TOP_LEFT_HEAVY``.
///
/// If the mode is ``BOTTOM_RIGHT_HEAVY``:
///
/// .. code::
///
///     topPaddingAmount = floor(totalPaddingHeight / 2)
///     bottomPaddingAmount = totalPaddingHeight - topPaddingAmount
///     leftPaddingAmount = floor(totalPaddingWidth / 2)
///     rightPaddingAmount = totalPaddingWidth - leftPaddingAmount
///
/// If the mode is ``TOP_LEFT_HEAVY``:
///
/// .. code::
///
///     bottomPaddingAmount = floor(totalPaddingHeight / 2)
///     topPaddingAmount = totalPaddingHeight - bottomPaddingAmount
///     rightPaddingAmount = floor(totalPaddingWidth / 2)
///     leftPaddingAmount = totalPaddingWidth - rightPaddingAmount
///
///
/// With Deconvolution:
///
/// .. code::
///
///    H_out = H_in * stride[0]
///    W_out = W_in * stride[1]
public struct SamePadding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var asymmetryMode: SamePadding.SamePaddingMode = .bottomRightHeavy

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SamePaddingMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case bottomRightHeavy // = 0
    case topLeftHeavy // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .bottomRightHeavy
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bottomRightHeavy
      case 1: self = .topLeftHeavy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .bottomRightHeavy: return 0
      case .topLeftHeavy: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension SamePadding.SamePaddingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SamePadding.SamePaddingMode] = [
    .bottomRightHeavy,
    .topLeftHeavy,
  ]
}

#endif  // swift(>=4.2)

///
/// Specifies how grid points are sampled from an interval.
/// Without the loss of generality, assume the interval to be [0, X-1] from which N points are to be sampled.
/// Here X may correspond to an input image's height or width.
/// All the methods can be expressed in terms of numpy's linspace function, along with the constraint that grid points have to lie in the interval [0, X-1].
/// Note: numpy.linspace(start = start, end = end, num = N, endpoint = True) corresponds to sampling
/// N points uniformly from the interval [start, end], endpoints included.
/// The methods vary in how the ``start`` and ``end`` values are computed.
public struct SamplingMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplingMethod: SamplingMode.Method = .strictAlignEndpointsMode

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Method: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    ///
    /// start = 0, end = X-1
    /// grid points = numpy.linspace(start, end)
    case strictAlignEndpointsMode // = 0

    ///
    /// if N == 1: start = end = (X-1)/2
    /// otherwise, start = 0, end = X-1
    /// grid points = numpy.linspace(start, end)
    case alignEndpointsMode // = 1

    ///
    /// start = 0, end = X - X/N
    /// grid points = min(X-1, numpy.linspace(start, end))
    /// This is same as the mode used in the upsample layer in this specification, when used with bilinear interpolation. In that case N/X = upsample ratio.
    case upsampleMode // = 2

    ///
    /// spacing = max(1, X-1)/N
    /// start = 0.5 * spacing
    /// end = start + (N-1) * spacing
    /// grid points = min(X-1, numpy.linspace(start, end))
    case roiAlignMode // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .strictAlignEndpointsMode
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .strictAlignEndpointsMode
      case 1: self = .alignEndpointsMode
      case 2: self = .upsampleMode
      case 3: self = .roiAlignMode
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .strictAlignEndpointsMode: return 0
      case .alignEndpointsMode: return 1
      case .upsampleMode: return 2
      case .roiAlignMode: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension SamplingMode.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SamplingMode.Method] = [
    .strictAlignEndpointsMode,
    .alignEndpointsMode,
    .upsampleMode,
    .roiAlignMode,
  ]
}

#endif  // swift(>=4.2)

///
/// Specifies the convention used to specify four bounding box coordinates for an image of size (Height, Width).
/// The (0,0) coordinate corresponds to the top-left corner of the image.
public struct BoxCoordinatesMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var boxMode: BoxCoordinatesMode.Coordinates = .cornersHeightFirst

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Coordinates: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    ///
    /// [h_start, w_start, h_end, w_end]
    case cornersHeightFirst // = 0

    ///
    /// [w_start, h_start, w_end, h_end]
    case cornersWidthFirst // = 1

    ///
    /// [h_center, w_center, box_height, box_width]
    case centerSizeHeightFirst // = 2

    ///
    /// [w_center, h_center, box_width, box_height]
    case centerSizeWidthFirst // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .cornersHeightFirst
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cornersHeightFirst
      case 1: self = .cornersWidthFirst
      case 2: self = .centerSizeHeightFirst
      case 3: self = .centerSizeWidthFirst
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .cornersHeightFirst: return 0
      case .cornersWidthFirst: return 1
      case .centerSizeHeightFirst: return 2
      case .centerSizeWidthFirst: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BoxCoordinatesMode.Coordinates: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BoxCoordinatesMode.Coordinates] = [
    .cornersHeightFirst,
    .cornersWidthFirst,
    .centerSizeHeightFirst,
    .centerSizeWidthFirst,
  ]
}

#endif  // swift(>=4.2)

///
/// Weights for layer parameters.
/// Weights are stored as repeated floating point numbers
/// using row-major ordering
/// and can represent 1-, 2-, 3-, or 4-dimensional data.
public struct WeightParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Values specified in single / float / FP32 precision.
  public var floatValue: [Float] = []

  ///
  /// Values in 16-bit half precision floating point.
  public var float16Value: Data = Data()

  ///
  /// Raw value specification for quantized lower precisions.
  ///
  /// This field is interpreted as uintN, where N is the number of bits in quantization.
  /// E.g. if n=8, the field is interpreted as an array of UINT8.
  /// Use this field for quantized parameters unless specifically noted to use
  /// int8RawValue.
  public var rawValue: Data = Data()

  ///
  /// Field to be used if int8DynamicQuantize is set in the parent layer.
  /// Cannot be set if rawValue is also set.
  /// The values in this field are interpreted as INT8.
  ///
  /// If this field is set, following conditions must hold true:
  /// * QuantizationType == LinearQuantizationParams, such that
  ///   * size of the "scale" field is 1 and "bias" field is empty in "LinearQuantizationParams"
  public var int8RawValue: Data = Data()

  ///
  /// Quantization related parameters.
  public var quantization: QuantizationParams {
    get {return _quantization ?? QuantizationParams()}
    set {_quantization = newValue}
  }
  /// Returns true if `quantization` has been explicitly set.
  public var hasQuantization: Bool {return self._quantization != nil}
  /// Clears the value of `quantization`. Subsequent reads from it will return its default value.
  public mutating func clearQuantization() {self._quantization = nil}

  public var isUpdatable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _quantization: QuantizationParams? = nil
}

///
/// Quantization parameters.
public struct QuantizationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numberOfBits: UInt64 = 0

  public var quantizationType: QuantizationParams.OneOf_QuantizationType? = nil

  public var linearQuantization: LinearQuantizationParams {
    get {
      if case .linearQuantization(let v)? = quantizationType {return v}
      return LinearQuantizationParams()
    }
    set {quantizationType = .linearQuantization(newValue)}
  }

  public var lookupTableQuantization: LookUpTableQuantizationParams {
    get {
      if case .lookupTableQuantization(let v)? = quantizationType {return v}
      return LookUpTableQuantizationParams()
    }
    set {quantizationType = .lookupTableQuantization(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_QuantizationType: Equatable {
    case linearQuantization(LinearQuantizationParams)
    case lookupTableQuantization(LookUpTableQuantizationParams)

  #if !swift(>=4.1)
    public static func ==(lhs: QuantizationParams.OneOf_QuantizationType, rhs: QuantizationParams.OneOf_QuantizationType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.linearQuantization, .linearQuantization): return {
        guard case .linearQuantization(let l) = lhs, case .linearQuantization(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lookupTableQuantization, .lookupTableQuantization): return {
        guard case .lookupTableQuantization(let l) = lhs, case .lookupTableQuantization(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct LinearQuantizationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Stores scale and bias values corresponding to the quantized weights.
  /// Must be an array of 1 element, or an array of C elements, where C
  /// is number of output channels. For recurrent layers it is equal to
  /// the output vector size.
  ///
  /// Relationship between quantized weights, unquantized weights, scale and bias:
  ///
  /// W_unquantized = W_quantized * scale + bias
  public var scale: [Float] = []

  public var bias: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LookUpTableQuantizationParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stores look-up table quantization values. Must be an array of
  ///(2^numberOfBits) Elements.
  public var floatValue: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs spatial convolution or deconvolution.
///
/// .. code::
///
///      y = ConvolutionLayer(x)
///
/// Requires 1 or 2 inputs and produces 1 output.
///
/// Input
///    First Input:
///      A blob with rank greater than or equal to 4.
///      Rank 4 blob represents [Batch, channels, height, width].
///      For ranks greater than 4, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
///
///     From Core ML specification version 4 onwards (iOS >= 13, macOS >= 10.15).
///     convolution layer can have 2 inputs, in which case the second input is
///     the blob representing the weights. This is allowed when "isDeconvolution" = False.
///     The weight blob should have shape
///     ``[outputChannels, kernelChannels, kernelHeight, kernelWidth]``,
///     where kernelChannels == inputChannels / nGroups.
///
/// Output
///   Rank is same as the input. e.g.: for rank 4 input, output shape is [B, C_out, H_out, W_out]
///
///
/// If ``dilationFactor`` is not 1, effective kernel size is
/// modified as follows:
///
/// .. code::
///
///      KernelSize[0] <-- (kernelSize[0]-1) * dilationFactor[0] + 1
///      KernelSize[1] <-- (kernelSize[1]-1) * dilationFactor[1] + 1
///
/// Type of padding can be ``valid`` or ``same``. Output spatial dimensions depend on the
/// the type of padding. For details, refer to the descriptions of the messages "ValidPadding"
/// and "SamePadding". Padded values are all zeros.
///
/// For Deconvolution, ``ConvolutionPaddingType`` (``valid`` or ``same``) is ignored when ``outputShape`` is set.
public struct ConvolutionLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The number of kernels.
  /// Same as ``C_out`` used in the layer description.
  public var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  ///
  /// Channel dimension of the kernels.
  /// Must be equal to ``inputChannels / nGroups``, if isDeconvolution == False
  /// Must be equal to ``inputChannels``, if isDeconvolution == True
  public var kernelChannels: UInt64 {
    get {return _storage._kernelChannels}
    set {_uniqueStorage()._kernelChannels = newValue}
  }

  ///
  /// Group convolution, i.e. weight reuse along channel axis.
  /// Input and kernels are divided into g groups
  /// and convolution / deconvolution is applied within the groups independently.
  /// If not set or 0, it is set to the default value 1.
  public var nGroups: UInt64 {
    get {return _storage._nGroups}
    set {_uniqueStorage()._nGroups = newValue}
  }

  ///
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[3, 3]`` is used.
  public var kernelSize: [UInt64] {
    get {return _storage._kernelSize}
    set {_uniqueStorage()._kernelSize = newValue}
  }

  ///
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  public var stride: [UInt64] {
    get {return _storage._stride}
    set {_uniqueStorage()._stride = newValue}
  }

  ///
  /// Must be length 2 in order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  /// It is ignored if ``isDeconvolution == true``.
  public var dilationFactor: [UInt64] {
    get {return _storage._dilationFactor}
    set {_uniqueStorage()._dilationFactor = newValue}
  }

  ///
  /// The type of padding.
  public var convolutionPaddingType: OneOf_ConvolutionPaddingType? {
    get {return _storage._convolutionPaddingType}
    set {_uniqueStorage()._convolutionPaddingType = newValue}
  }

  public var valid: ValidPadding {
    get {
      if case .valid(let v)? = _storage._convolutionPaddingType {return v}
      return ValidPadding()
    }
    set {_uniqueStorage()._convolutionPaddingType = .valid(newValue)}
  }

  public var same: SamePadding {
    get {
      if case .same(let v)? = _storage._convolutionPaddingType {return v}
      return SamePadding()
    }
    set {_uniqueStorage()._convolutionPaddingType = .same(newValue)}
  }

  ///
  /// Flag to specify whether it is a deconvolution layer.
  public var isDeconvolution: Bool {
    get {return _storage._isDeconvolution}
    set {_uniqueStorage()._isDeconvolution = newValue}
  }

  ///
  /// Flag to specify whether a bias is to be added or not.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  ///
  /// Weights associated with this layer.
  /// If convolution (``isDeconvolution == false``), weights have the shape
  /// ``[outputChannels, kernelChannels, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels / nGroups
  /// If deconvolution (``isDeconvolution == true``) weights have the shape
  /// ``[kernelChannels, outputChannels / nGroups, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels
  public var weights: WeightParams {
    get {return _storage._weights ?? WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_uniqueStorage()._weights = nil}

  /// Must be of size [outputChannels].
  public var bias: WeightParams {
    get {return _storage._bias ?? WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_uniqueStorage()._bias = nil}

  ///
  /// The output shape, which has length 2 ``[H_out, W_out]``.
  /// This is used only for deconvolution (``isDeconvolution == true``).
  /// If not set, the deconvolution output shape is calculated
  /// based on ``ConvolutionPaddingType``.
  public var outputShape: [UInt64] {
    get {return _storage._outputShape}
    set {_uniqueStorage()._outputShape = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// The type of padding.
  public enum OneOf_ConvolutionPaddingType: Equatable {
    case valid(ValidPadding)
    case same(SamePadding)

  #if !swift(>=4.1)
    public static func ==(lhs: ConvolutionLayerParams.OneOf_ConvolutionPaddingType, rhs: ConvolutionLayerParams.OneOf_ConvolutionPaddingType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.valid, .valid): return {
        guard case .valid(let l) = lhs, case .valid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.same, .same): return {
        guard case .same(let l) = lhs, case .same(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A layer that performs a 3-dimensional convolution.
///
/// .. code::
///
///      y = Convolution3DLayer(x)
///
/// Input
///    A blob of rank 5.
///    The input blob's shape should be ``[batch, channels, depth, height, width]``.
///
/// Fields
///   The bias field, if set, should have shape of ``[channelsOut]``.
///
/// Output
///   A blob of rank 5.
///   The output blob's shape is ``[batch, channelsOut, depthOut, heightOut, widthOut]``.
///
/// Type of padding can be ``custom``, ``valid``, or ``same``. Padded values are all zeros.
/// Output spatial dimensions depend on the the type of padding. For details, refer to the
/// descriptions of the ``PaddingType`` field of this ``Convolution3DLayerParams`` message.
///
/// Example
///   For example, given an input of size ``[1, 3, 3, 8, 8]``, a stride of 2 in each dimension,
///   a kernel of 3 in each dimension, 2 output channels, and ``same`` padding, this layer will
///   compute the total padding applied in the depth, height, and width dimensions to be 2, 1, and 1,
///   respectively. The depth padding is even and will be applied equally to both sides of the depth
///   dimension. Since the height and width padding values are odd, they'll be applied to the
///   bottom/right of the height/width dimensions. Thus, the padding applied to the input will be
///   ``[1, 1, 0, 1, 0, 1]`` (front, back, top, bottom, left, right). Finally, the output produced
///   will have size ``[1, 2, 2, 4, 4]``.
public struct Convolution3DLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The number of channels in the output (channelsOut). Must be a positive integer.
  public var outputChannels: Int32 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  ///
  /// The number of channels in the input (channels). Must be a positive integer.
  public var inputChannels: Int32 {
    get {return _storage._inputChannels}
    set {_uniqueStorage()._inputChannels = newValue}
  }

  ///
  /// Group convolution, i.e., weight reuse along the channel axis.
  /// It must evenly divide both the number of input and output channels and be at most the number
  /// of input channels (a depthwise convolution).
  /// Input and kernels are divided into g groups and convolution is applied within the groups
  /// independently.
  public var nGroups: Int32 {
    get {return _storage._nGroups}
    set {_uniqueStorage()._nGroups = newValue}
  }

  /// Depth of the convolution kernel. Must be a positive integer.
  public var kernelDepth: Int32 {
    get {return _storage._kernelDepth}
    set {_uniqueStorage()._kernelDepth = newValue}
  }

  /// Height of the convolution kernel. Must be a positive integer.
  public var kernelHeight: Int32 {
    get {return _storage._kernelHeight}
    set {_uniqueStorage()._kernelHeight = newValue}
  }

  /// Width of the convolution kernel. Must be a positive integer.
  public var kernelWidth: Int32 {
    get {return _storage._kernelWidth}
    set {_uniqueStorage()._kernelWidth = newValue}
  }

  /// Stride along the depth direction. Must be a positive integer.
  public var strideDepth: Int32 {
    get {return _storage._strideDepth}
    set {_uniqueStorage()._strideDepth = newValue}
  }

  /// Stride along the height direction. Must be a positive integer.
  public var strideHeight: Int32 {
    get {return _storage._strideHeight}
    set {_uniqueStorage()._strideHeight = newValue}
  }

  /// Stride along the width direction. Must be a positive integer.
  public var strideWidth: Int32 {
    get {return _storage._strideWidth}
    set {_uniqueStorage()._strideWidth = newValue}
  }

  /// Dilation along the depth direction. Must be a positive integer.
  public var dilationDepth: Int32 {
    get {return _storage._dilationDepth}
    set {_uniqueStorage()._dilationDepth = newValue}
  }

  /// Dilation along the height direction. Must be a positive integer.
  public var dilationHeight: Int32 {
    get {return _storage._dilationHeight}
    set {_uniqueStorage()._dilationHeight = newValue}
  }

  /// Dilation along the width direction. Must be a positive integer.
  public var dilationWidth: Int32 {
    get {return _storage._dilationWidth}
    set {_uniqueStorage()._dilationWidth = newValue}
  }

  ///
  /// Flag to specify whether a bias is to be added or not.
  /// If false, then no bias is added.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  ///
  /// Weights associated with this layer.
  /// Weights have the shape
  /// if deconvolution == False
  /// ``[outputChannels, kernelChannels, kernelDepth, kernelHeight, kernelWidth]``, where
  /// kernelChannels == inputChannels / nGroups
  /// else if deconvolution == True
  /// ``[outputChannels / nGroups, kernelChannels, kernelDepth, kernelHeight, kernelWidth]``, where
  public var weights: WeightParams {
    get {return _storage._weights ?? WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_uniqueStorage()._weights = nil}

  ///
  /// Must be of size ``[outputChannels]``.
  public var bias: WeightParams {
    get {return _storage._bias ?? WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_uniqueStorage()._bias = nil}

  public var paddingType: Convolution3DLayerParams.PaddingType {
    get {return _storage._paddingType}
    set {_uniqueStorage()._paddingType = newValue}
  }

  /// Padding before the input in the depth direction. Must be zero or a positive integer.
  /// Used when the `PaddingType` is `CustomPadding`, otherwise ignored by other padding types.
  public var customPaddingFront: Int32 {
    get {return _storage._customPaddingFront}
    set {_uniqueStorage()._customPaddingFront = newValue}
  }

  /// Padding after the input in the depth direction. Must be zero or a positive integer.
  /// Used when the `PaddingType` is `CustomPadding`, otherwise ignored by other padding types.
  public var customPaddingBack: Int32 {
    get {return _storage._customPaddingBack}
    set {_uniqueStorage()._customPaddingBack = newValue}
  }

  /// Padding before the input in the height direction. Must be zero or a positive integer.
  /// Used when the `PaddingType` is `CustomPadding`, otherwise ignored by other padding types.
  public var customPaddingTop: Int32 {
    get {return _storage._customPaddingTop}
    set {_uniqueStorage()._customPaddingTop = newValue}
  }

  /// Padding after the input in the height direction. Must be zero or a positive integer.
  /// Used when the `PaddingType` is `CustomPadding`, otherwise ignored by other padding types.
  public var customPaddingBottom: Int32 {
    get {return _storage._customPaddingBottom}
    set {_uniqueStorage()._customPaddingBottom = newValue}
  }

  /// Padding before the input in the width direction. Must be zero or a positive integer.
  /// Used when the `PaddingType` is `CustomPadding`, otherwise ignored by other padding types.
  public var customPaddingLeft: Int32 {
    get {return _storage._customPaddingLeft}
    set {_uniqueStorage()._customPaddingLeft = newValue}
  }

  /// Padding after the input in the width direction. Must be zero or a positive integer.
  /// Used when the `PaddingType` is `CustomPadding`, otherwise ignored by other padding types.
  public var customPaddingRight: Int32 {
    get {return _storage._customPaddingRight}
    set {_uniqueStorage()._customPaddingRight = newValue}
  }

  /// Flag to specify if this is Convolution Transpose or not.
  public var isDeconvolution: Bool {
    get {return _storage._isDeconvolution}
    set {_uniqueStorage()._isDeconvolution = newValue}
  }

  ///
  /// The output shape, which has length 3 ``[D_out, H_out, W_out]``.
  /// This is used only for deconvolution (``isDeconvolution == true``).
  /// If not set, the deconvolution output shape is calculated
  /// based on ``PaddingType``.
  public var outputShape: [UInt64] {
    get {return _storage._outputShape}
    set {_uniqueStorage()._outputShape = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// The type of padding.
  /// All padding types pad the input shape with zeros.
  /// CUSTOM padding will add the custom padding values specified below to their respective
  /// dimensions, e.g., `customPaddingFront` number of zeros will be added to one side of the
  /// input's depth dimension and `customPaddingBack` number of zeros will be added to the other
  /// side of the input's depth dimension.
  /// VALID padding adds no padding to any dimension. In this case, the last convolution along
  /// each dimension will be dropped if the input dimension and the kernel size, stride, and
  /// dilation do not match.
  /// SAME padding adds enough padding to each dimension such that the output of the convolution
  /// has size ``Ceiling(inputShape / stride)``. Padding is added evenly to both sides of each
  /// dimension unless the total padding to add is odd, in which case it is added to the
  /// back/bottom/right side of the respective dimension. For example, if the total padding needed
  /// in the depth dimension is 3, 1 zero will be added to the front side of the depth dimension
  /// and 2 zeros will be added to the back side.
  public enum PaddingType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case custom // = 0
    case valid // = 1
    case same // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .custom
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .custom
      case 1: self = .valid
      case 2: self = .same
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .custom: return 0
      case .valid: return 1
      case .same: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Convolution3DLayerParams.PaddingType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Convolution3DLayerParams.PaddingType] = [
    .custom,
    .valid,
    .same,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that performs a matrix-vector or matrix-matrix product.
/// This is equivalent to a fully-connected, or dense layer.
/// The weight parameters correspond to a matrix of dimensions (inputChannels, outputChannels) i.e. (C_in, C_out)
///
/// .. code::
///
///      y = InnerProductLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///      Input can have rank 1 to rank 5. This is how it is reshaped in to the matrix (for rank > 1):
///      rank 1 (x1) : in this case, the layer corresponds to a matrix-vector product. x1 must be equal to C_in
///      rank 2 (x1, x2): x2 must be equal to C_in
///      rank 3 (x1, x2, x3) --> (x1 * x2, x3). x3 must be equal to C_in
///      rank 4 (x1, x2, x3, x4) ---> (x1, x2 * x3 * x4). x2 * x3 * x4 must be equal to C_in
///      rank 5 (x1, x2, x3, x4, x5) ---> (x1 * x2, x3 * x4 * x5). x3 * x4 * x5 must be equal to C_in
///
/// Output
///      Output rank is same as the input rank
///      rank 1: (C_out)
///      rank 2: (x1, C_out)
///      rank 3: (x1, x2, C_out)
///      rank 4: (x1, C_out, 1, 1)
///      rank 5: (x1, x2, C_out, 1, 1)
public struct InnerProductLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input size: C_in.
  public var inputChannels: UInt64 {
    get {return _storage._inputChannels}
    set {_uniqueStorage()._inputChannels = newValue}
  }

  /// Output size: C_out.
  public var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  /// Whether a bias is added or not.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  /// Weight matrix [C_out, C_in].
  public var weights: WeightParams {
    get {return _storage._weights ?? WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_uniqueStorage()._weights = nil}

  /// Bias vector [C_out].
  public var bias: WeightParams {
    get {return _storage._bias ?? WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_uniqueStorage()._bias = nil}

  ///
  /// If set, this layer, at runtime, quantizes the floating point input blob to int8 before applying an
  /// inner product using INT8 weight matrix parameters, as provided in weights->int8RawValue. The
  /// result is then dequantized.
  /// Requires:
  /// * hasBias == false
  /// * QuantizationType == LinearQuantizationParams, such that
  ///   * size of the "scale" field is 1 and "bias" field is empty in "LinearQuantizationParams"
  /// * numberOfBits == 8
  /// * weights->rawValue_size to be empty
  public var int8DynamicQuantize: Bool {
    get {return _storage._int8DynamicQuantize}
    set {_uniqueStorage()._int8DynamicQuantize = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A layer that performs a matrix lookup and optionally adds a bias.
/// The weights matrix is stored with dimensions [outputChannels, inputDim].
///
/// .. code::
///
///      y = EmbeddingLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     Input values must be in the range ``[0, inputDim - 1]``.
///
///     Input must have rank equal to 4 or 5, such that the last 3 dimensions are all 1.
///     rank 4: shape (x1, 1, 1, 1). x1 is effectively the batch/sequence length.
///     rank 5: shape (x1, x2 , 1, 1, 1). x1 * x2 is effectively the combined batch/sequence length.
///
/// Output
///      Output rank is same as the input rank. Please see input description above.
///      rank 4: shape (x1, outputChannels, 1, 1)
///      rank 5: shape (x1, x2, outputChannels, 1, 1)
public struct EmbeddingLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Size of the input dictionary.
  public var inputDim: UInt64 {
    get {return _storage._inputDim}
    set {_uniqueStorage()._inputDim = newValue}
  }

  /// Size of the output vectors.
  public var outputChannels: UInt64 {
    get {return _storage._outputChannels}
    set {_uniqueStorage()._outputChannels = newValue}
  }

  /// Whether a bias is added or not.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  /// 2-D weights of dimensions [outputChannels, inputDim].
  public var weights: WeightParams {
    get {return _storage._weights ?? WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_uniqueStorage()._weights = nil}

  /// Bias of size [outputChannels].
  public var bias: WeightParams {
    get {return _storage._bias ?? WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_uniqueStorage()._bias = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A layer that performs a matrix lookup and optionally adds a bias.
/// The weights matrix is stored with dimensions [embeddingSize, vocabSize].
///
/// .. code::
///
///      y = EmbeddingNDLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     Input values must be in the range ``[0, vocabSize - 1]``.
///     Input must have rank at least 2. The last dimension must always be 1.
///     rank 2: shape (x1, 1). x1 is the batch/sequence length.
///     rank 3: shape (x1, x2, 1). x1 * x2 is effectively the combined batch/sequence length.
///     rank 4: shape (x1, x2, x3, 1). x1 * x2 * x2 is effectively the combined batch/sequence length.
///     rank 5: shape (x1, x2 , x3, x4, 1). x1 * x2 * x3 * x4 is effectively the combined batch/sequence length.
///
/// Output
///      Output rank is same as the input rank. Please see input description above.
///      rank 2: shape (x1, embeddingSize)
///      rank 3: shape (x1, x2, embeddingSize)
///      rank 4: shape (x1, x2, x3, embeddingSize)
///      rank 5: shape (x1, x2, x3, x4, embeddingSize)
public struct EmbeddingNDLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Size of the input dictionary.
  public var vocabSize: UInt64 {
    get {return _storage._vocabSize}
    set {_uniqueStorage()._vocabSize = newValue}
  }

  /// Size of the output vectors.
  public var embeddingSize: UInt64 {
    get {return _storage._embeddingSize}
    set {_uniqueStorage()._embeddingSize = newValue}
  }

  /// Whether a bias is added or not.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  /// 2-D weights of dimensions [embeddingSize, vocabSize].
  public var weights: WeightParams {
    get {return _storage._weights ?? WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_uniqueStorage()._weights = nil}

  /// Bias of size [embeddingSize].
  public var bias: WeightParams {
    get {return _storage._bias ?? WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_uniqueStorage()._bias = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A layer that performs batch normalization,
/// which is performed along axis = -3,
/// and repeated along the other axes, if present.
///
/// .. code::
///
///      y = BatchnormLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// This operation is described by the following formula:
///
/// .. math::
///     y_i = \gamma_i \dfrac{ (x_i - \mu_i)}{\sqrt{\sigma_i^2 + \epsilon}} + \beta_i \;,\;i=1,....,C
///
/// Input
///     A blob with rank greater than equal to 3.
///     Example: Rank 4 blob represents [Batch, channels, height, width]
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
///
/// Output
///     A blob with the same shape as the input.
public struct BatchnormLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Size of the channel dimension in the input.
  public var channels: UInt64 {
    get {return _storage._channels}
    set {_uniqueStorage()._channels = newValue}
  }

  ///
  /// If ``computeMeanVar == true``,
  /// the mean and variance are calculated from either
  /// the single input instance, if ``instanceNormalization == true``,
  /// or the whole batch, if ``instanceNormalization = false``.
  /// and the values provided in parameters "mean" and "variance" are ignored.
  public var computeMeanVar: Bool {
    get {return _storage._computeMeanVar}
    set {_uniqueStorage()._computeMeanVar = newValue}
  }

  public var instanceNormalization: Bool {
    get {return _storage._instanceNormalization}
    set {_uniqueStorage()._instanceNormalization = newValue}
  }

  ///
  /// A small constant to avoid division by 0 while normalizing by variance.
  /// Defaults to ``1e-5`` if not set or set to ``0``.
  public var epsilon: Float {
    get {return _storage._epsilon}
    set {_uniqueStorage()._epsilon = newValue}
  }

  /// Parameter of length [channels]
  public var gamma: WeightParams {
    get {return _storage._gamma ?? WeightParams()}
    set {_uniqueStorage()._gamma = newValue}
  }
  /// Returns true if `gamma` has been explicitly set.
  public var hasGamma: Bool {return _storage._gamma != nil}
  /// Clears the value of `gamma`. Subsequent reads from it will return its default value.
  public mutating func clearGamma() {_uniqueStorage()._gamma = nil}

  /// Parameter of length [channels]
  public var beta: WeightParams {
    get {return _storage._beta ?? WeightParams()}
    set {_uniqueStorage()._beta = newValue}
  }
  /// Returns true if `beta` has been explicitly set.
  public var hasBeta: Bool {return _storage._beta != nil}
  /// Clears the value of `beta`. Subsequent reads from it will return its default value.
  public mutating func clearBeta() {_uniqueStorage()._beta = nil}

  /// Parameter of length [channels]
  public var mean: WeightParams {
    get {return _storage._mean ?? WeightParams()}
    set {_uniqueStorage()._mean = newValue}
  }
  /// Returns true if `mean` has been explicitly set.
  public var hasMean: Bool {return _storage._mean != nil}
  /// Clears the value of `mean`. Subsequent reads from it will return its default value.
  public mutating func clearMean() {_uniqueStorage()._mean = nil}

  /// Parameter of length [channels]
  public var variance: WeightParams {
    get {return _storage._variance ?? WeightParams()}
    set {_uniqueStorage()._variance = newValue}
  }
  /// Returns true if `variance` has been explicitly set.
  public var hasVariance: Bool {return _storage._variance != nil}
  /// Clears the value of `variance`. Subsequent reads from it will return its default value.
  public mutating func clearVariance() {_uniqueStorage()._variance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A spatial pooling layer.
///
/// .. code::
///
///      y = PoolingLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank greater than equal to 4.
///     Rank 4 blob represents [Batch, channels, height, width]
///     For ranks greater than 4, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
///
/// Output
///     Rank is same as the input. e.g.: for rank 4 input, output shape is [B, C, H_out, W_out]
///
/// Padding options are similar to ``ConvolutionLayerParams``
/// with the additional option of ``ValidCompletePadding`` (``includeLastPixel``),
/// which ensures that the last application of the kernel
/// always includes the last pixel of the input image, if there is padding.
///
/// .. code::
///
///     H_out = ceil(float(H_in + 2 * paddingAmounts[0] - kernelSize[0])/float(Stride[0])) + 1
///     if (paddingAmounts[0] > 0 or paddingAmounts[1] > 0)
///          if ((H_out - 1) * Stride >= H_in + paddingAmounts[0]) {
///              H_out = H_out - 1
///          }
///     }
///
/// The equivalent expressions hold true for ``W_out`` as well.
/// Only symmetric padding is supported with this option.
public struct PoolingLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of pooling operation.
  public var type: PoolingLayerParams.PoolingType = .max

  ///
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[3, 3]`` is used.
  public var kernelSize: [UInt64] = []

  ///
  /// Must be length 2 in the order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  public var stride: [UInt64] = []

  public var poolingPaddingType: PoolingLayerParams.OneOf_PoolingPaddingType? = nil

  public var valid: ValidPadding {
    get {
      if case .valid(let v)? = poolingPaddingType {return v}
      return ValidPadding()
    }
    set {poolingPaddingType = .valid(newValue)}
  }

  public var same: SamePadding {
    get {
      if case .same(let v)? = poolingPaddingType {return v}
      return SamePadding()
    }
    set {poolingPaddingType = .same(newValue)}
  }

  public var includeLastPixel: PoolingLayerParams.ValidCompletePadding {
    get {
      if case .includeLastPixel(let v)? = poolingPaddingType {return v}
      return PoolingLayerParams.ValidCompletePadding()
    }
    set {poolingPaddingType = .includeLastPixel(newValue)}
  }

  ///
  /// If true, padded values are excluded from the count (denominator)
  /// when computing average pooling.
  public var avgPoolExcludePadding: Bool = false

  ///
  /// If true, global pooling is performed.
  /// Kernel size is inferred from the input data spatial dimensions.
  public var globalPooling: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PoolingPaddingType: Equatable {
    case valid(ValidPadding)
    case same(SamePadding)
    case includeLastPixel(PoolingLayerParams.ValidCompletePadding)

  #if !swift(>=4.1)
    public static func ==(lhs: PoolingLayerParams.OneOf_PoolingPaddingType, rhs: PoolingLayerParams.OneOf_PoolingPaddingType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.valid, .valid): return {
        guard case .valid(let l) = lhs, case .valid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.same, .same): return {
        guard case .same(let l) = lhs, case .same(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.includeLastPixel, .includeLastPixel): return {
        guard case .includeLastPixel(let l) = lhs, case .includeLastPixel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum PoolingType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case max // = 0
    case average // = 1
    case l2 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .max
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .average
      case 2: self = .l2
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .max: return 0
      case .average: return 1
      case .l2: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct ValidCompletePadding {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Must be length 2 in order ``[H, W]``.
    /// If not set, value ``[0, 0]`` is used.
    public var paddingAmounts: [UInt64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension PoolingLayerParams.PoolingType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PoolingLayerParams.PoolingType] = [
    .max,
    .average,
    .l2,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer to pool three spatial dimensions
///
/// Input
///      A blob with rank equal to 5, representing [Batch, channels, depth, height, width].
///
/// Output
///      Rank is same as the input: A blob with rank equal to 5, representing [Batch, channels, depth, height, width].
///
/// Requires 1 input and produces 1 output.
///
/// For example, given an input of shape (1,1,2,3,3):
///        +----+----+----+
///      / | 10 | 11 | 12 |
///     /  +----+----+----+
///    /   | 13 | 14 | 15 |
///   /    +----+----+----+
///  /     | 16 | 17 | 18 |
/// /      +----+----+----+
/// +----+----+----+      /
/// |  1 |  2 |  3 |     /
/// +----+----+----+    /
/// |  4 |  5 |  6 |   /
/// +----+----+----+  /
/// |  7 |  8 |  9 | /
/// +----+----+----+
///
/// And applying MAX pooling using:
///      Kernel: 2x2x2
///      Stride: 1x1x1
///      Valid Padding
/// We expect to get an output with shape: (1,1,1,2,2) and value:
/// +----+----+
/// | 14 | 15 |
/// +----+----+
/// | 17 | 18 |
/// +----+----+
public struct Pooling3DLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether to use Max or Average
  public var type: Pooling3DLayerParams.PoolingType3D = .max

  /// Depth of the pooling region.
  public var kernelDepth: Int32 = 0

  /// Height of the pooling region.
  public var kernelHeight: Int32 = 0

  /// Width of the pooling region.
  public var kernelWidth: Int32 = 0

  /// Stride along the depth direction
  public var strideDepth: Int32 = 0

  /// Stride along the height direction
  public var strideHeight: Int32 = 0

  /// Stride along the width direction
  public var strideWidth: Int32 = 0

  public var paddingType: Pooling3DLayerParams.Pooling3DPaddingType = .custom

  /// Padding before the input in the depth direction.
  public var customPaddingFront: Int32 = 0

  /// Padding after the input in the depth direction.
  public var customPaddingBack: Int32 = 0

  /// Padding before the input in the height direction.
  public var customPaddingTop: Int32 = 0

  /// Padding after the input in the height direction.
  public var customPaddingBottom: Int32 = 0

  /// Padding before the input in the width direction.
  public var customPaddingLeft: Int32 = 0

  /// Padding after the input in the width direction.
  public var customPaddingRight: Int32 = 0

  /// If true, exclude zeros from padding in Average pooling.  Meaningless in Max Pooling.
  public var countExcludePadding: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PoolingType3D: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case max // = 0
    case average // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .max
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .average
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .max: return 0
      case .average: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  ///
  /// The type of padding.
  /// All padding types pad the input shape with zeros.
  /// CUSTOM padding will add the custom padding values specified below to their respective
  /// dimensions, e.g., `customPaddingFront` number of zeros will be added to one side of the
  /// input's depth dimension and `customPaddingBack` number of zeros will be added to the other
  /// side of the input's depth dimension.
  /// VALID padding adds no padding to any dimension. In this case, the last pool along
  /// each dimension will be dropped if the input dimension and the kernel size, and stride do not match.
  /// SAME padding adds enough padding to each dimension such that the output
  /// has the same spatial dimensions as the input. Padding is added evenly to both
  /// sides of each dimension unless the total padding to add is odd, in which case the extra padding
  /// is added to the back/bottom/right side of the respective dimension.  For example, if the the
  /// total horizontal padding is 3, then there will be 1 padding on the left, and 2 padding on the right.
  public enum Pooling3DPaddingType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case custom // = 0
    case valid // = 1
    case same // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .custom
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .custom
      case 1: self = .valid
      case 2: self = .same
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .custom: return 0
      case .valid: return 1
      case .same: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Pooling3DLayerParams.PoolingType3D: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Pooling3DLayerParams.PoolingType3D] = [
    .max,
    .average,
  ]
}

extension Pooling3DLayerParams.Pooling3DPaddingType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Pooling3DLayerParams.Pooling3DPaddingType] = [
    .custom,
    .valid,
    .same,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer to pool three spatial dimensions down to one value.
/// This behaves like a special case of Pooling3DLayerParams in which
/// the Kernel is the size of the input and there is no padding.
///
/// Input
///      A blob with rank equal to 5, representing [Batch, channels, depth, height, width].
///
/// Output
///      Rank is same as the input: A blob with rank equal to 5, representing [Batch, channels, depth, height, width].
///      Depth, height, and width of the output will always be 1.
///
/// Requires 1 input and produces 1 output.
///
/// For example, given an input of shape (1,1,2,3,3):
///        +----+----+----+
///      / | 10 | 11 | 12 |
///     /  +----+----+----+
///    /   | 13 | 14 | 15 |
///   /    +----+----+----+
///  /     | 16 | 17 | 18 |
/// /      +----+----+----+
/// +----+----+----+      /
/// |  1 |  2 |  3 |     /
/// +----+----+----+    /
/// |  4 |  5 |  6 |   /
/// +----+----+----+  /
/// |  7 |  8 |  9 | /
/// +----+----+----+
///
/// And applying MAX global 3d pooling, we expect to get an output with shape: (1,1,1,1,1) and value:
/// +----+
/// | 18 |
/// +----+
public struct GlobalPooling3DLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether to use Max or Average
  public var type: GlobalPooling3DLayerParams.GlobalPoolingType3D = .max

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum GlobalPoolingType3D: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case max // = 0
    case average // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .max
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .average
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .max: return 0
      case .average: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension GlobalPooling3DLayerParams.GlobalPoolingType3D: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [GlobalPooling3DLayerParams.GlobalPoolingType3D] = [
    .max,
    .average,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that performs padding along spatial dimensions.
///
/// .. code::
///
///      y = PaddingLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank at least 2.
///     e.g.: blob with shape ``[H_in, W_in]``.
///     For ranks greater than 2, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch
///     i.e. Padding is applied on last two dimensions.
///
/// Output
///     Same rank as the input.
///     e.g.: blob with shape ``[H_out, W_out]``.
///
/// Output dimensions are calculated as follows:
///
/// .. code::
///
///     H_out = H_in + topPaddingAmount + bottomPaddingAmount
///     W_out = W_in + leftPaddingAmount + rightPaddingAmount
///
///     topPaddingAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
///     bottomPaddingAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
///     leftPaddingAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
///     rightPaddingAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
///
/// There are three types of padding:
///
/// - ``PaddingConstant``, which fills a constant value at the border.
/// - ``PaddingReflection``, which reflects the values at the border.
/// - ``PaddingReplication``, which replicates the values at the border.
///
/// Given the following input:
///
/// .. code::
///
///     [1, 3, 4]  :  1   2   3   4
///                   5   6   7   8
///                   9   10  11  12
///
/// Here is the output of applying the padding
/// ``(top=2, left=2, bottom=0, right=0)``
/// with each of the supported types:
///
/// - ``PaddingConstant`` (``value = 0``):
///   .. code::
///
///       [1, 5, 6]  :  0   0   0  0   0   0
///                     0   0   0  0   0   0
///                     0   0   1  2   3   4
///                     0   0   5  6   7   8
///                     0   0   9  10  11  12
///
/// - ``PaddingReflection``:
///   .. code::
///
///       [1, 5, 6]  :  11  10  9  10  11  12
///                     7   6   5  6   7   8
///                     3   2   1  2   3   4
///                     7   6   5  6   7   8
///                     11  10  9  10  11  12
///
/// - ``PaddingReplication``:
///   .. code::
///
///       [1, 5, 6]  :  1   1   1  2   3   4
///                     1   1   1  2   3   4
///                     1   1   1  2   3   4
///                     5   5   5  6   7   8
///                     9   9   9  10  11  12
public struct PaddingLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paddingType: PaddingLayerParams.OneOf_PaddingType? = nil

  public var constant: PaddingLayerParams.PaddingConstant {
    get {
      if case .constant(let v)? = paddingType {return v}
      return PaddingLayerParams.PaddingConstant()
    }
    set {paddingType = .constant(newValue)}
  }

  public var reflection: PaddingLayerParams.PaddingReflection {
    get {
      if case .reflection(let v)? = paddingType {return v}
      return PaddingLayerParams.PaddingReflection()
    }
    set {paddingType = .reflection(newValue)}
  }

  public var replication: PaddingLayerParams.PaddingReplication {
    get {
      if case .replication(let v)? = paddingType {return v}
      return PaddingLayerParams.PaddingReplication()
    }
    set {paddingType = .replication(newValue)}
  }

  /// Amounts to be padded to the input.
  public var paddingAmounts: BorderAmounts {
    get {return _paddingAmounts ?? BorderAmounts()}
    set {_paddingAmounts = newValue}
  }
  /// Returns true if `paddingAmounts` has been explicitly set.
  public var hasPaddingAmounts: Bool {return self._paddingAmounts != nil}
  /// Clears the value of `paddingAmounts`. Subsequent reads from it will return its default value.
  public mutating func clearPaddingAmounts() {self._paddingAmounts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PaddingType: Equatable {
    case constant(PaddingLayerParams.PaddingConstant)
    case reflection(PaddingLayerParams.PaddingReflection)
    case replication(PaddingLayerParams.PaddingReplication)

  #if !swift(>=4.1)
    public static func ==(lhs: PaddingLayerParams.OneOf_PaddingType, rhs: PaddingLayerParams.OneOf_PaddingType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.constant, .constant): return {
        guard case .constant(let l) = lhs, case .constant(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reflection, .reflection): return {
        guard case .reflection(let l) = lhs, case .reflection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.replication, .replication): return {
        guard case .replication(let l) = lhs, case .replication(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///
  /// Fill a constant value in the padded region.
  public struct PaddingConstant {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Reflect the values at the border for padding.
  public struct PaddingReflection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Replicate the values at the border for padding.
  public struct PaddingReplication {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _paddingAmounts: BorderAmounts? = nil
}

///
/// A layer that concatenates along the axis = -3 or -5.
/// For general concatenation along any axis, see ConcatNDLayer.
///
/// .. code::
///
///      y = ConcatLayer(x1,x2,....)
///
/// Requires more than 1 input and produces 1 output.
///
/// Input
///   All input blobs must have same rank.
///   If "sequenceConcat" = False, rank must be greater than equal to 3. In this case concatenation is along axis = -3
///   If "sequenceConcat" = True, rank must be greater than equal to 5. In this case concatenation is along axis = -5
///
/// Output
///   Same rank as the input.
public struct ConcatLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// If true, concatenate along the axis = -5 instead of axis = -3.
  public var sequenceConcat: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs local response normalization (LRN).
///
/// .. code::
///
///      y = LRNLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank greater than equal to 3.
///     Example: Rank 4 blob represents [Batch, channels, height, width]
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
/// Output
///     A blob with the same shape as the input.
///
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow  \dfrac{x_i}{\left ( k + \dfrac{\alpha}{\text{localSize}} \sum_j x_j^2 \right )^\beta}
///
/// where the summation is done over a ``(localSize, 1, 1)`` neighborhood ---
/// that is, over a window "across" channels in 1x1 spatial neighborhoods.
public struct LRNLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alpha: Float = 0

  public var beta: Float = 0

  /// Number of channels in the normalization window.
  public var localSize: UInt64 = 0

  /// Defaults to 1 if not set or 0. Must be strictly positive.
  public var k: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Softmax Normalization Layer
///
/// A layer that performs softmax normalization.
/// Normalization is applied along axis = -3 or N-3 (where N is the rank of the input)
/// For softmax layer that can operate on any axis, see SoftmaxNDLayer.
///
///
/// .. code::
///
///      y = SoftmaxLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     Must be a blob with rank >= 3.
/// Output
///     A blob with the same shape as the input.
///
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow \dfrac{e^{x_i}}{\sum_i{e^{x_i}}}
public struct SoftmaxLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that uniformly splits across axis = -3 to produce a specified number of outputs.
/// For general split operation along any axis, see SplitNDLayer.
///
/// .. code::
///
///      (y1,y2,...yN) = SplitLayer(x), where N = nOutputs
///
/// Requires 1 input and produces multiple outputs.
///
/// Input
///     A blob with rank at least 3.
///     e.g.: blob with shape ``[C, H, W]``
/// Output
///     ``nOutputs`` blobs each with same rank as the input.
///     e.g.: For input that is of shape ``[C, H, W]``, output shapes will be ``[C/nOutputs, H, W]``
public struct SplitLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of outputs.
  public var nOutputs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs elementwise addition.
/// This layer has limited broadcasting support. For general broadcasting see AddBroadcastableLayer.
///
/// .. code::
///
///      y = AddLayer(x1,x2,...)
///
/// Requires 1 or more than 1 input and produces 1 output.
///
/// Input
///     In general, there are no rank constraints.
///     However, only certain set of shapes are broadcastable. For example:
///     [B, 1, 1, 1], [B, C, 1, 1], [B, 1, H, W], [B, C, H, W]
/// Output
///     A blob with shape equal to the input blob.
///
/// If only one input is provided, scalar addition is performed:
///
/// .. math::
///     y = x + \alpha
public struct AddLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Scalar to be added to the input.
  /// Only used if there is a single input.
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs elementwise multiplication.
/// This layer has limited broadcasting support. For general broadcasting see MultiplyBroadcastableLayer.
///
/// .. code::
///
///      y = MultiplyLayer(x1,x2,...)
///
/// Requires 1 or more than 1 input and produces 1 output.
///
/// Input
///     In general, there are no rank constraints.
///     However, only certain set of shapes are broadcastable. For example:
///     [B, 1, 1, 1], [B, C, 1, 1], [B, 1, H, W], [B, C, H, W]
/// Output
///     A blob with shape equal to the first input blob.
///
/// If only one input is provided, scalar multiplication is performed:
///
/// .. math::
///     y = \alpha x
public struct MultiplyLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Scalar to be multiplied with the input.
  /// Only used if there is a single input.
  public var alpha: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that applies a unary function.
///
/// .. code::
///
///      y = UnaryFunctionLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with no rank constraints.
/// Output
///     A blob with the same shape as the input.
///
/// The input is first modified by shifting and scaling:
///
/// .. math::
///     x \leftarrow \text{scale} \cdot x + \text{shift}
public struct UnaryFunctionLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of unary function.
  public var type: UnaryFunctionLayerParams.Operation = .sqrt

  ///
  /// A constant used in ``POWER`` and ``THRESHOLD`` functions.
  public var alpha: Float = 0

  ///
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  public var epsilon: Float = 0

  ///
  /// Input is shifted by this amount
  /// before the unary function is applied.
  /// Defaults to ``0.0`` if not set.
  public var shift: Float = 0

  ///
  /// Input is scaled by this amount
  /// before the unary function is applied.
  /// Defaults to ``1.0`` if not set or set to ``0``.
  public var scale: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// A unary operator.
  ///
  /// The following functions are supported:
  ///
  /// ``SQRT``
  ///     .. math:: f(x) = \sqrt{x}
  ///
  /// ``RSQRT``
  ///     .. math:: f(x) = \dfrac{1}{\sqrt{x + \epsilon}}
  ///
  /// ``INVERSE``
  ///     .. math:: f(x) = \dfrac{1}{x + \epsilon}
  ///
  /// ``POWER``
  ///     .. math:: f(x) = x^\alpha
  ///
  /// ``EXP``
  ///     .. math:: f(x) = e^x
  ///
  /// ``LOG``
  ///     .. math:: f(x) = \log x
  ///
  /// ``ABS``
  ///     .. math:: f(x) = |x|
  ///
  /// ``THRESHOLD``
  ///     .. math:: f(x) = \text{max}(\alpha, x)
  public enum Operation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sqrt // = 0
    case rsqrt // = 1
    case inverse // = 2
    case power // = 3
    case exp // = 4
    case log // = 5
    case abs // = 6
    case threshold // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .sqrt
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sqrt
      case 1: self = .rsqrt
      case 2: self = .inverse
      case 3: self = .power
      case 4: self = .exp
      case 5: self = .log
      case 6: self = .abs
      case 7: self = .threshold
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sqrt: return 0
      case .rsqrt: return 1
      case .inverse: return 2
      case .power: return 3
      case .exp: return 4
      case .log: return 5
      case .abs: return 6
      case .threshold: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension UnaryFunctionLayerParams.Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [UnaryFunctionLayerParams.Operation] = [
    .sqrt,
    .rsqrt,
    .inverse,
    .power,
    .exp,
    .log,
    .abs,
    .threshold,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that scales up spatial dimensions.
/// It supports two modes: nearest neighbour (default) and bilinear.
///
/// .. code::
///
///      y = UpsampleLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank at least 3.
///     e.g.: blob with shape ``[C, H, W]``.
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
///
/// Output
///     Same rank as the input.
///     e.g.: blob with shape ``[C, scalingFactor[0] * H, scalingFactor[1] * W]``
public struct UpsampleLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Scaling Factor. Mutually exclusive with fractionalScalingFactor.
  /// Must be length 2 in order ``[H, W]``.
  /// If not set, default value ``[1, 1]`` is used.
  public var scalingFactor: [UInt64] = []

  ///
  /// Fractional scaling factor. Mutually exclusive with scalingFactor.
  /// Must be length 2 in order ``[H, W]``.
  /// If not set, default value ``[1.0, 1.0]`` is used.
  public var fractionalScalingFactor: [Float] = []

  public var mode: UpsampleLayerParams.InterpolationMode = .nn

  public var linearUpsampleMode: UpsampleLayerParams.LinearUpsampleMode = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Overall mode for interpolating new elements when upsampling.
  /// NN - Nearest Neighbors - simply pick the nearest true value for interpolated values.
  /// BILINEAR - Use bilinear interpolation. See LinearUpsamplingMode for behavior.
  public enum InterpolationMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Nearest Neighbour
    case nn // = 0

    /// Bilinear
    case bilinear // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .nn
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nn
      case 1: self = .bilinear
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .nn: return 0
      case .bilinear: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  ///
  /// LinearUpsampleMode specifies the behavior for linear upsampling. Only valid when Interpolation Mode is BILINEAR.
  /// If input grid is [0, Xin-1] (corresponding to an input size of Xin), and if the output size is Xout,
  /// then the grid points are sampled in the following manner:
  /// DEFAULT:
  ///   spacing = (Xin-Xin/Xout) / (Xout-1)
  ///   grid_point[i] = min(Xin-1, max(0, i * spacing)), for i = 0,1,2,….,Xout-1
  /// ALIGN_CORNERS_TRUE:
  ///   spacing = (Xin-1) / (Xout-1)
  ///   grid_point[i] = min(Xin-1, max(0, i * spacing)), for i = 0,1,2,….,Xout-1
  /// ALIGN_CORNERS_FALSE:
  ///   spacing = Xin / Xout
  ///   grid_point[i] = min(Xin-1, max(0, i * spacing + 0.5 * spacing - 0.5)), for i = 0,1,2,….,Xout-1
  public enum LinearUpsampleMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case `default` // = 0
    case alignCornersTrue // = 1
    case alignCornersFalse // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .alignCornersTrue
      case 2: self = .alignCornersFalse
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .alignCornersTrue: return 1
      case .alignCornersFalse: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension UpsampleLayerParams.InterpolationMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [UpsampleLayerParams.InterpolationMode] = [
    .nn,
    .bilinear,
  ]
}

extension UpsampleLayerParams.LinearUpsampleMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [UpsampleLayerParams.LinearUpsampleMode] = [
    .default,
    .alignCornersTrue,
    .alignCornersFalse,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that resizes the input to a pre-specified spatial size using bilinear interpolation.
///
/// .. code::
///
///      y = ResizeBilinearLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank at least 3.
///     e.g.: blob with shape ``[C, H_in, W_in]``.
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
///
/// Output
///     Same rank as the input.
///     e.g.: blob with shape ``[C, H_out, W_out]``.
public struct ResizeBilinearLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Target Spatial Size.
  /// Must be length 2 in order ``[Height, Width]``, i.e. ``[H_out, W_out]``.
  /// If not set, default value ``[1, 1]`` is used.
  public var targetSize: [UInt64] = []

  ///
  /// Mode used to compute the grid on which the spatial output values are evaluated.
  /// Same mode is applied to both the height and width axes.
  public var mode: SamplingMode {
    get {return _mode ?? SamplingMode()}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  public var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  public mutating func clearMode() {self._mode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mode: SamplingMode? = nil
}

///
/// A layer that extracts cropped spatial patches or RoIs (regions of interest) from the input and resizes them to a pre-specified size using
/// bilinear interpolation.
/// Note that RoI Align layer can be implemented with this layer followed by a pooling layer.
///
/// .. code::
///
///      y = CropResizeLayer(x)
///
/// Requires 2 inputs and produces 1 output.
///
/// Input
///     There are two inputs.
///     First input represents an image feature map.
///     Second input represents the bounding box coordinates for N patches or RoIs (region of interest).
///
///     First input is rank 5: [1, Batch, C, H_in, W_in].
///     Second input is rank 5. Its shape can be either [N, 1, 4, 1, 1] or [N, 1, 5, 1, 1].
///
///     N: number of patches/RoIs to be extracted
///
///     If RoI shape = ``[N, 1, 4, 1, 1]``
///                    The axis=-3 corresponds to the four coordinates specifying the bounding box.
///                    All the N RoIs are extracted from all the batches of the input.
///
///     If RoI shape = ``[N, 1, 5, 1, 1]``
///                     The first element of the axis=-3 specifies the input batch id from which to extract the RoI and
///                               must be in the interval ``[0, Batch - 1]``. That is, n-th RoI is extracted from the RoI[n,0,0,0,0]-th
///                     input batch id. The last four elements of the axis=-3 specify the bounding box coordinates.
///
/// Output
///     A blob with rank 5.
///           - Shape is [N, Batch, C, H_out, W_out] if input RoI shape is [N, 1, 4, 1, 1]
///           - Shape is [N, 1, C, H_out, W_out] if input RoI shape is [N, 1, 5, 1, 1]
public struct CropResizeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Target Spatial Size.
  /// Must be length 2 in order ``[Height, Width]``, i.e. ``[H_out, W_out]``.
  /// If not set, default value ``[1, 1]`` is used.
  public var targetSize: [UInt64] = []

  ///
  /// If true the bounding box coordinates must be in the interval [0, 1].
  /// They are scaled by (H_in - 1), (W_in - 1), i.e. based on the input spatial dimensions.
  /// If false the bounding box coordinates must be in the interval
  /// [0, H_in -1] and [0, W_in - 1], respectively for height and width dimensions.
  public var normalizedCoordinates: Bool = false

  ///
  /// Mode used to compute the grid on which the spatial output values are evaluated.
  /// Same mode is applied to both the height and width axes.
  public var mode: SamplingMode {
    get {return _mode ?? SamplingMode()}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  public var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  public mutating func clearMode() {self._mode = nil}

  ///
  /// Representation used to express the bounding box coordinates.
  /// It determines how the values of the second input are interpreted.
  public var boxIndicesMode: BoxCoordinatesMode {
    get {return _boxIndicesMode ?? BoxCoordinatesMode()}
    set {_boxIndicesMode = newValue}
  }
  /// Returns true if `boxIndicesMode` has been explicitly set.
  public var hasBoxIndicesMode: Bool {return self._boxIndicesMode != nil}
  /// Clears the value of `boxIndicesMode`. Subsequent reads from it will return its default value.
  public mutating func clearBoxIndicesMode() {self._boxIndicesMode = nil}

  ///
  /// Additional spatial scale that multiplies the bounding box coordinates.
  /// Generally used while implementing the RoI Align layer,
  /// which uses unnormalized RoI coordinates along with a spatial scale less than or equal to 1.
  public var spatialScale: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mode: SamplingMode? = nil
  fileprivate var _boxIndicesMode: BoxCoordinatesMode? = nil
}

///
/// A layer that performs elementwise addition of a bias,
/// which is broadcasted to match the input shape.
///
/// .. code::
///
///      y = BiasLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank at least 3.
///     e.g.: blob with shape ``[C, H, W]``.
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
/// Output
///     A blob with the same shape as the input.
public struct BiasLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The shape of the bias.
  /// Must be one of the following:
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
  public var shape: [UInt64] = []

  ///
  /// The bias values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  public var bias: WeightParams {
    get {return _bias ?? WeightParams()}
    set {_bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return self._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {self._bias = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bias: WeightParams? = nil
}

///
/// A layer that performs elmentwise multiplication by a scale factor
/// and optionally adds a bias;
/// both the scale and bias are broadcasted to match the input shape.
///
/// .. code::
///
///      y = ScaleLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank at least 3.
///     e.g.: blob with shape ``[C, H, W]``.
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
/// Output
///     A blob with the same shape as the input.
public struct ScaleLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The shape of the scale.
  /// Must be one of the following:
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
  public var shapeScale: [UInt64] {
    get {return _storage._shapeScale}
    set {_uniqueStorage()._shapeScale = newValue}
  }

  ///
  /// The scale values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  public var scale: WeightParams {
    get {return _storage._scale ?? WeightParams()}
    set {_uniqueStorage()._scale = newValue}
  }
  /// Returns true if `scale` has been explicitly set.
  public var hasScale: Bool {return _storage._scale != nil}
  /// Clears the value of `scale`. Subsequent reads from it will return its default value.
  public mutating func clearScale() {_uniqueStorage()._scale = nil}

  /// If true, a bias is added after scaling.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  ///
  /// The shape of the bias.
  /// Must be one of the following:
  /// ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
  public var shapeBias: [UInt64] {
    get {return _storage._shapeBias}
    set {_uniqueStorage()._shapeBias = newValue}
  }

  ///
  /// The bias values.
  /// The size must be equal to the product of the ``shape`` dimensions.
  public var bias: WeightParams {
    get {return _storage._bias ?? WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_uniqueStorage()._bias = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A layer that loads data as a parameter and provides it as an output.
/// The output is rank 5. For general rank, see LoadConstantNDLayer.
///
/// .. code::
///
///      y = LoadConstantLayer()
///
/// Requires no input and produces 1 output.
///
/// Output:
///     A blob with rank 5 and shape ``[1, 1, C, H, W]``
public struct LoadConstantLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The shape of the constant to be loaded,
  /// which must be``[C, H, W]``, that is length 3.
  public var shape: [UInt64] = []

  ///
  /// The data values,
  /// of size ``C * H * W``.
  public var data: WeightParams {
    get {return _data ?? WeightParams()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: WeightParams? = nil
}

///
/// A layer that performs L2 normalization, i.e. divides by the
/// the square root of the sum of squares of all elements of input.
///
/// .. code::
///
///      y = L2NormalizeLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank greater than equal to 3.
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
/// Output
///     A blob with the same shape as the input.
///
/// This layer is described by the following formula:
///
/// .. math::
///     x_i \leftarrow \dfrac{x_i}{\sqrt{\sum{x_i^2} + \epsilon}}
public struct L2NormalizeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  public var epsilon: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that flattens the input.
///
/// .. code::
///
///      y = FlattenLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank greater than equal to 3.
///     e.g.: Rank 4 blob represents [Batch, C, H, W]
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
/// Output
///     Same rank as the input, such that last two dimensions are both 1.
///     e.g.: For rank 4 input, output shape is ``[Batch, C * H * W, 1, 1]``
///
/// There are two X orders: ``CHANNEL_FIRST`` and ``CHANNEL_LAST``.
/// ``CHANNEL_FIRST`` does not require data to be rearranged,
/// because row major ordering is used by internal storage.
/// ``CHANNEL_LAST`` requires data to be rearranged.
public struct FlattenLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: FlattenLayerParams.FlattenOrder = .channelFirst

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FlattenOrder: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case channelFirst // = 0
    case channelLast // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .channelFirst
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelFirst
      case 1: self = .channelLast
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .channelFirst: return 0
      case .channelLast: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FlattenLayerParams.FlattenOrder: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FlattenLayerParams.FlattenOrder] = [
    .channelFirst,
    .channelLast,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that recasts the input into a new shape.
///
/// .. code::
///
///      y = ReshapeLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank 5.
///     e.g.: ``[1, 1, C, H, W]`` or ``[Seq, 1, C, H, W]``.
/// Output
///     A blob with rank 5.
///     e.g.: ``[1, 1, C_out, H_out, W_out]`` or ``[Seq_out, 1, C_out, H_out, W_out]``.
///
/// There are two reshape orders: ``CHANNEL_FIRST`` and ``CHANNEL_LAST``.
/// ``CHANNEL_FIRST`` is equivalent to
/// flattening the input to ``[Seq, 1, C * H * W, 1, 1]`` in channel first order
/// and then reshaping it to the target shape;
/// no data rearrangement is required.
/// ``CHANNEL_LAST`` is equivalent to
/// flattening the input to ``[Seq, 1, H * W * C, 1, 1]`` in channel last order,
/// reshaping it to ``[Seq_out, 1, H_out, W_out, C_out]`` (it is now in "H_out-major"" order),
/// and then permuting it to ``[C_out, H_out, W_out]``;
/// both the flattening and permuting requires the data to be rearranged.
public struct ReshapeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The shape of the output.
  /// Must be of length 3 or 4.
  /// If set to 3, ``targetShape`` is interpreted as
  /// ``[1, 1, C_out, H_out, W_out]``, and sequence length of the input is preserved.
  /// If set to 4, ``targetShape`` is interpreted as
  /// ``[Seq_out, 1, C_out, H_out, W_out]``,
  /// where ``Seq_out`` is the new sequence length.
  public var targetShape: [Int64] = []

  public var mode: ReshapeLayerParams.ReshapeOrder = .channelFirst

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ReshapeOrder: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case channelFirst // = 0
    case channelLast // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .channelFirst
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelFirst
      case 1: self = .channelLast
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .channelFirst: return 0
      case .channelLast: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension ReshapeLayerParams.ReshapeOrder: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ReshapeLayerParams.ReshapeOrder] = [
    .channelFirst,
    .channelLast,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that rearranges the dimensions and data of an input.
/// For generic transpose/permute operation see TransposeLayer.
///
/// .. code::
///
///      y = PermuteLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     Must be a rank 5 blob.
///     e.g.: shape ``[Seq, B, C, H, W]``.
/// Output
///     Rank 5 blob. Transposed version of the input, such that dimensions at axis=1 or axis=-4 is unchanged.
///
///
/// Examples:
///
///  Assume input shape is [Seq, B, C, H, W]
///
/// - If ``axis`` is set to ``[0, 3, 1, 2]``,
///   then the output has shape ``[Seq, B, W, C, H]``
///
/// - If ``axis`` is set to ``[3, 1, 2, 0]``,
///   then the output has shape ``[W, B, C, H, Seq]``
///
/// - If ``axis`` is set to ``[0, 3, 2, 1]``,
///   then the output has shape ``[Seq, B, W, H, C]``
///
/// - If ``axis`` is not set, or is set to ``[0, 1, 2, 3]``,
///   the output is the same as the input.
public struct PermuteLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The order in which to permute the dimensions.
  /// Must have length 4 and a permutation of ``[0, 1, 2, 3]``.
  public var axis: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that reorganizes data in the input in specific ways.
///
/// .. code::
///
///      y = ReorganizeDataLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank at least 3.
///     e.g.: blob with shape ``[C, H, W]``.
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
/// Output
///     Same rank as the input.
///     e.g.: blob with shape ``[C_out, H_out, W_out]``.
///
/// mode == SPACE_TO_DEPTH
///  ``[C_out, H_out, W_out]`` : ``[C * blockSize * blockSize, H/blockSize, W/blockSize]``.
///  blockSize must divide H and W.
///  Data is moved from the spatial dimensions to the channel dimension. Input is spatially divided into
///  non-overlapping blocks of size blockSize X blockSize and data from each block is moved into the
///  channel dimension.
///
/// mode == DEPTH_TO_SPACE
///  ``[C_out, H_out, W_out]`` : ``[C/(blockSize * blockSize), H * blockSize, W * blockSize]``.
///  Square of blockSize must divide C.
///  Reverse of SPACE_TO_DEPTH. Data is moved from the channel dimension to the spatial dimensions.
///
/// mode == PIXEL_SHUFFLE
///  ``[C_out, H_out, W_out]`` : ``[C/(blockSize * blockSize), H * blockSize, W *  blockSize]``.
///  Square of blockSize must divide C.
///  Similar to DEPTH_TO_SPACE, but using the pixel-shuffle semantics for channel order in the output space.
///  In both modes, elements along the channel dimension are collapsed into
///  blocks in the spatial dimensions. The difference is in the arrangement of
///  the input-channels' data in the output space. See below example for more
///  detail.
///  (Only available in Core ML Specification >= 5 (iOS >= 14, macOS >= 11.0)
///
///
/// Examples:
///
/// Assume input is the following [C = 8, H = 1, W = 2] tensor:
///
/// .. code::
///
///    [[[1 2]] [[3 4]] [[5 6]] [[7 8]] [[9 10]] [[11 12]] [[13 14]] [[15 16]]]
///
/// If block_size == 2 and mode == DEPTH_TO_SPACE, output will be the following
/// [C = 2, H = 2, W = 4] tensor:
///
/// .. code::
///
///    [[[ 1  5  2  6]
///      [ 9 13 10 14]]
///
///     [[ 3  7  4  8]
///      [11 15 12 16]]]
///
/// For mode == SPACE_TO_DEPTH, the behavior is the same as mode ==
/// DEPTH_TO_SPACE, but with the input and output swapped.
///
/// If block_size == 2 and mode == PIXEL_SHUFFLE, output will be the following
/// [C = 2, H = 2, W = 4] tensor:
///
/// .. code::
///
///    [[[ 1  3  2  4]
///      [ 5  7  6  8]]
///
///     [[ 9 11 10 12]
///      [13 15 14 16]]]
public struct ReorganizeDataLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: ReorganizeDataLayerParams.ReorganizationType = .spaceToDepth

  /// must be greater than 1
  public var blockSize: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ReorganizationType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case spaceToDepth // = 0
    case depthToSpace // = 1
    case pixelShuffle // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .spaceToDepth
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .spaceToDepth
      case 1: self = .depthToSpace
      case 2: self = .pixelShuffle
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .spaceToDepth: return 0
      case .depthToSpace: return 1
      case .pixelShuffle: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension ReorganizeDataLayerParams.ReorganizationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ReorganizeDataLayerParams.ReorganizationType] = [
    .spaceToDepth,
    .depthToSpace,
    .pixelShuffle,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that slices the input data along axis = -1 or -2 or -3.
/// For general slice along any axis, please see SliceStaticLayer/SliceDynamicLayer.
///
/// .. code::
///
///      y = SliceLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob that can, in general, have any rank. However, depending on the value of "axis" ,
///     there may be additional rank constraints.
/// Output
///     A blob with the same rank as the input.
///
/// Sliced section is taken from the interval ``[startIndex, endIndex)``, i.e.
/// startIndex is inclusive while endIndex is exclusive.
/// stride must be positive and represents the step size for slicing.
/// Negative indexing is supported for startIndex and endIndex.
/// -1 denotes N-1, -2 denotes N-2 and so on, where N is the length of the dimension to be sliced.
public struct SliceLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// start of the sliced section. Inclusive.
  public var startIndex: Int64 = 0

  /// end of sliced section. Exclusive.
  public var endIndex: Int64 = 0

  /// The step size. Must be positive.
  public var stride: UInt64 = 0

  /// The following mapping is used for interpreting this parameter:
  /// CHANNEL_AXIS => axis = -3, input must have rank at least 3.
  /// HEIGHT_AXIS => axis = -2, input must have rank at least 2.
  /// WIDTH_AXIS => axis = -1
  public var axis: SliceLayerParams.SliceAxis = .channelAxis

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SliceAxis: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case channelAxis // = 0
    case heightAxis // = 1
    case widthAxis // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .channelAxis
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .channelAxis
      case 1: self = .heightAxis
      case 2: self = .widthAxis
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .channelAxis: return 0
      case .heightAxis: return 1
      case .widthAxis: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension SliceLayerParams.SliceAxis: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SliceLayerParams.SliceAxis] = [
    .channelAxis,
    .heightAxis,
    .widthAxis,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that reduces the input using a specified operation.
///
/// .. code::
///
///      y = ReduceLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob that can, in general, have any rank. However, depending on the value of "axis" ,
///      there may be additional rank constraints.
/// Output
///     A blob with the same rank as the input, which has 1s on the dimensions specified in the parameter "axis"
///
///     Values supported for axis are [-1], [-2], [-3], [-2,-1], [-3,-2,-1]
///     and the equivalent positive values (depending on the rank of the input)
///     For mode == 'ArgMax', axis must be [-1] or [-2] or [-3].
public struct ReduceLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies function used to reduce.
  public var mode: ReduceLayerParams.ReduceOperation = .sum

  ///
  /// Used if mode is ``LOGSUM``.
  /// Defaults to ``1e-6`` if not set or is set to ``0``.
  public var epsilon: Float = 0

  /// The following mapping is used for interpreting this parameter:
  /// CHW = axis [-3, -2, -1], input must have rank at least 3.
  /// HW = axis [-2, -1], input must have rank at least 2.
  /// C = axis [-3]
  /// H = axis [-2]
  /// W = axis [-1]
  public var axis: ReduceLayerParams.ReduceAxis = .chw

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// The following reduction operations are supported
  /// and are applied on the specified axis of the input array:
  ///
  /// ``SUM``
  ///     Sum of all elements
  ///
  ///     .. math:: \sum{x_i}
  ///
  /// ``AVG``
  ///     Sum of all elements divided by the number of elements
  ///
  ///     .. math:: \dfrac{\sum^n{x_i}}{n}
  ///
  /// ``PROD``
  ///     Product of all elements
  ///
  ///     .. math:: \prod{x_i}
  ///
  /// ``LOGSUM``
  ///     Sum of the natural logarithm of all elements
  ///
  ///     .. math:: \sum{\ln{(x_i + \epsilon)}}
  ///
  /// ``SUMSQUARE``
  ///     Sum of squares of all elements
  ///
  ///     .. math:: \sum{x^2}
  ///
  /// ``L1``
  ///     L1 normalization of all elements
  ///
  ///     .. math:: ||x||_1 = \sum{|x_i|}
  ///
  /// ``L2``
  ///     L2 normalization of all elements
  ///
  ///     .. math:: ||x||_2 = \sqrt{\sum{x_i^2}}
  ///
  /// ``MAX``
  ///     Maximum of all elements
  ///
  ///     .. math:: \text{max}(x_i)
  ///
  /// ``MIN``
  ///     Minimum of all elements
  ///
  ///     .. math:: \text{min}(x_i)
  ///
  /// ``ARGMAX``
  ///     Argument of the maximum of all elements
  ///
  ///     .. math:: \text{argmax}(x_i)
  public enum ReduceOperation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sum // = 0
    case avg // = 1
    case prod // = 2
    case logsum // = 3
    case sumsquare // = 4
    case l1 // = 5
    case l2 // = 6
    case max // = 7
    case min // = 8

    /// only supported with axis = C, H or W.
    case argmax // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .sum
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sum
      case 1: self = .avg
      case 2: self = .prod
      case 3: self = .logsum
      case 4: self = .sumsquare
      case 5: self = .l1
      case 6: self = .l2
      case 7: self = .max
      case 8: self = .min
      case 9: self = .argmax
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sum: return 0
      case .avg: return 1
      case .prod: return 2
      case .logsum: return 3
      case .sumsquare: return 4
      case .l1: return 5
      case .l2: return 6
      case .max: return 7
      case .min: return 8
      case .argmax: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ReduceAxis: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chw // = 0
    case hw // = 1
    case c // = 2
    case h // = 3
    case w // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .chw
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chw
      case 1: self = .hw
      case 2: self = .c
      case 3: self = .h
      case 4: self = .w
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chw: return 0
      case .hw: return 1
      case .c: return 2
      case .h: return 3
      case .w: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension ReduceLayerParams.ReduceOperation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ReduceLayerParams.ReduceOperation] = [
    .sum,
    .avg,
    .prod,
    .logsum,
    .sumsquare,
    .l1,
    .l2,
    .max,
    .min,
    .argmax,
  ]
}

extension ReduceLayerParams.ReduceAxis: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ReduceLayerParams.ReduceAxis] = [
    .chw,
    .hw,
    .c,
    .h,
    .w,
  ]
}

#endif  // swift(>=4.2)

///
/// A layer that crops the spatial dimensions of an input.
/// If two inputs are provided, the shape of the second input is used as the reference shape.
///
/// .. code::
///
///      y = CropLayer(x1) or y = CropLayer(x1,x2)
///
/// Requires 1 or 2 inputs and produces 1 output.
///
/// Input
///    1 or 2 tensors, each with rank at least 3, both inputs must have equal rank.
///    Example:
///     - 1 input case: A blob with shape ``[C, H_in, W_in]``.
///     - 2 input case: 1st blob with shape ``[C, H_in, W_in]``, 2nd blob with shape ``[C, H_out, W_out]``.
///
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
///
/// Output
///     Same rank as the inputs.
///     e.g.: A blob with shape ``[C, H_out, W_out]``.
///
/// If one input is used, output is computed as follows:
///
/// .. code::
///
///      y = x1[:, topCropAmount:H_in - bottomCropAmount, leftCropAmount:W_in - rightCropAmount]
///
///      topCropAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
///      bottomCropAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
///      leftCropAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
///      rightCropAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
///
///      H_out = H_in - topCropAmount - bottomCropAmount
///      W_out = W_in - leftCropAmount - rightCropAmount
///
/// If two inputs are used, output is computed as follows:
///
/// .. code::
///
///      y = x1[:, offset[0]:offset[0] + H_out, offset[1]:offset[1] + W_out]
public struct CropLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The amounts to be cropped from the input.
  /// Used only if a single input is provided.
  public var cropAmounts: BorderAmounts {
    get {return _cropAmounts ?? BorderAmounts()}
    set {_cropAmounts = newValue}
  }
  /// Returns true if `cropAmounts` has been explicitly set.
  public var hasCropAmounts: Bool {return self._cropAmounts != nil}
  /// Clears the value of `cropAmounts`. Subsequent reads from it will return its default value.
  public mutating func clearCropAmounts() {self._cropAmounts = nil}

  ///
  /// The offset amounts.
  /// Used only if two inputs are provided.
  /// Must be of length 2, in order ``[H, W]``.
  public var offset: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cropAmounts: BorderAmounts? = nil
}

///
/// A layer that computes the elementwise average of the inputs.
/// This layer has limited broadcasting support. For general broadcasting see AddBroadcastableLayer.
///
/// .. code::
///
///      y = AverageLayer(x1,x2,...)
///
/// Requires multiple inputs and produces 1 output.
///
/// Input
///     In general, there are no rank constraints.
///     However, only certain set of shapes are broadcastable. For example:
///     [B, 1, 1, 1], [B, C, 1, 1], [B, 1, H, W], [B, C, H, W]
/// Output
///     A blob with the same shape as each input.
public struct AverageLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes the elementwise maximum over the inputs.
///
/// .. code::
///
///      y = MaxLayer(x1,x2,...)
///
/// Requires multiple inputs and produces 1 output.
///
/// Input
///     In general, there are no rank constraints.
///     However, only certain set of shapes are broadcastable. For example:
///     [B, C, 1, 1], [B, C, H, W]
/// Output
///     A blob with the same shape as each input.
public struct MaxLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes the elementwise minimum over the inputs.
///
/// .. code::
///
///      y = MinLayer(x1,x2,...)
///
/// Requires multiple inputs and produces 1 output.
///
/// Input
///     In general, there are no rank constraints.
///     However, only certain set of shapes are broadcastable. For example:
///     [B, C, 1, 1], [B, C, H, W]
/// Output
///     A blob with the same shape as each input.
public struct MinLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes the dot product of two vectors.
///
/// .. code::
///
///      y = DotProductLayer(x1,x2)
///
/// Requires 2 inputs and produces 1 output.
///
/// Input
///     Two blobs with rank at least 3, such that the last two dimensions must be 1.
///     e.g.: blobs with shape ``[B, C, 1, 1]``.
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
///
/// Output
///     Same rank as the input.
///     e.g. for rank 4 inputs, output shape: [B, 1, 1, 1]
public struct DotProductLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// If true, inputs are normalized first,
  /// thereby computing the cosine similarity.
  public var cosineSimilarity: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs mean variance normalization, along axis = -3.
///
/// .. code::
///
///      y = MeanVarianceNormalizeLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank greater than equal to 3.
///     Example: Rank 4 blob represents [Batch, channels, height, width]
///     For ranks greater than 3, the leading dimensions, starting from 0 to -4 (inclusive), are all treated as batch.
///
/// Output
///     A blob with the same shape as the input.
///
/// If ``acrossChannels == true``
/// normalization is performed on flattened input, i.e. the input is reshaped to (Batch,C), where "Batch" contains
/// all dimensions from 0 to -4 (inclusive), and C contains dimensions -1, -2, -3.
///
/// If ``acrossChannels == false``
/// normalization is performed within a channel,
/// across spatial dimensions (i.e. last two dimensions).
public struct MeanVarianceNormalizeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// If true, mean and variance are computed across channels.
  public var acrossChannels: Bool = false

  ///
  /// If false, only mean is subtracted.
  public var normalizeVariance: Bool = false

  ///
  /// A small constant to avoid division by 0 while normalizing variance.
  /// Defaults to ``1e-6`` if not set or set to ``0``.
  public var epsilon: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that repeats a sequence or the dimension sitting at axis = -5
///
/// .. code::
///
///      y = SequenceRepeatLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     A blob with rank at least 5.
///     e.g: shape ``[Seq, B, C, H, W]``
/// Output
///     A blob with the same rank as the input.
///     e.g.: for input shape ``[Seq, B, C, H, W]``, output shape is ``[nRepetitions * Seq, B, C, H, W]``.
public struct SequenceRepeatLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Number of repetitions.
  /// Defaults to ``1`` if not set or set to ``0``.
  public var nRepetitions: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A simple recurrent layer.
///
/// .. code::
///
///      y_t = SimpleRecurrentLayer(x_t, y_{t-1})
///
/// Input
///    A blob of rank 5, with shape `[Seq, Batch, inputVectorSize, 1, 1]``.
///    This represents a sequence of vectors of size ``inputVectorSize``.
/// Output
///    Same rank as the input.
///    Represents a vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
///
/// - Output Shape: ``[1, Batch, outputVectorSize, 1, 1]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq, Batch, outputVectorSize, 1, 1]`` , if ``sequenceOutput == true``
///
/// This layer is described by the following equation:
///
/// .. math::
///     \boldsymbol{y_t} = f(\mathrm{clip}(W \boldsymbol{x_t} + \
///                                        R \boldsymbol{y_{t-1}} + b))
///
/// - ``W`` is a 2-dimensional weight matrix
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R`` is a 2-dimensional recursion matrix
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b`` is a 1-dimensional bias vector (``[outputVectorSize]``)
/// - ``f()`` is an activation
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
public struct SimpleRecurrentLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The size of the input vectors.
  public var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  /// The size of the output vectors.
  public var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  public var activation: ActivationParams {
    get {return _storage._activation ?? ActivationParams()}
    set {_uniqueStorage()._activation = newValue}
  }
  /// Returns true if `activation` has been explicitly set.
  public var hasActivation: Bool {return _storage._activation != nil}
  /// Clears the value of `activation`. Subsequent reads from it will return its default value.
  public mutating func clearActivation() {_uniqueStorage()._activation = nil}

  ///
  ///If false output is just the result after final state update.
  ///If true, output is a sequence, containing outputs at all time steps.
  public var sequenceOutput: Bool {
    get {return _storage._sequenceOutput}
    set {_uniqueStorage()._sequenceOutput = newValue}
  }

  /// If false, no bias is added.
  public var hasBiasVector_p: Bool {
    get {return _storage._hasBiasVector_p}
    set {_uniqueStorage()._hasBiasVector_p = newValue}
  }

  /// Weight matrix W.
  public var weightMatrix: WeightParams {
    get {return _storage._weightMatrix ?? WeightParams()}
    set {_uniqueStorage()._weightMatrix = newValue}
  }
  /// Returns true if `weightMatrix` has been explicitly set.
  public var hasWeightMatrix: Bool {return _storage._weightMatrix != nil}
  /// Clears the value of `weightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearWeightMatrix() {_uniqueStorage()._weightMatrix = nil}

  /// Recursion Weight matrix R.
  public var recursionMatrix: WeightParams {
    get {return _storage._recursionMatrix ?? WeightParams()}
    set {_uniqueStorage()._recursionMatrix = newValue}
  }
  /// Returns true if `recursionMatrix` has been explicitly set.
  public var hasRecursionMatrix: Bool {return _storage._recursionMatrix != nil}
  /// Clears the value of `recursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearRecursionMatrix() {_uniqueStorage()._recursionMatrix = nil}

  /// Bias vector b.
  public var biasVector: WeightParams {
    get {return _storage._biasVector ?? WeightParams()}
    set {_uniqueStorage()._biasVector = newValue}
  }
  /// Returns true if `biasVector` has been explicitly set.
  public var hasBiasVector: Bool {return _storage._biasVector != nil}
  /// Clears the value of `biasVector`. Subsequent reads from it will return its default value.
  public mutating func clearBiasVector() {_uniqueStorage()._biasVector = nil}

  /// If true, then the node processes the input sequence from right to left
  public var reverseInput: Bool {
    get {return _storage._reverseInput}
    set {_uniqueStorage()._reverseInput = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Gated-Recurrent Unit (GRU) Layer
///
/// .. code::
///
///      y_t = GRULayer(x_t, y_{t-1})
///
/// Input
///    A blob of rank 5, with shape `[Seq, Batch, inputVectorSize, 1, 1]``.
///    This represents a sequence of vectors of size ``inputVectorSize``.
/// Output
///    Same rank as the input.
///    Represents a vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
///
/// - Output Shape: ``[1, Batch, outputVectorSize, 1, 1]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq, Batch, outputVectorSize, 1, 1]`` , if ``sequenceOutput == true``
///
/// This layer is described by the following equations:
///
/// Update Gate
///     .. math::
///         \boldsymbol{z_t} = \
///             f(\mathrm{clip}(W_z \boldsymbol{x_t} + \
///                             R_z \boldsymbol{y_{t-1}} + b_z)
///
/// Reset Gate
///     .. math::
///         \boldsymbol{r_t} = \
///             f(\mathrm{clip}(W_r \boldsymbol{x_t} + \
///                             R_r \boldsymbol{y_{t-1}} + b_r))
///
/// Cell Memory State
///     .. math::
///         \boldsymbol{c_t} = \
///             \boldsymbol{y_{t-1}} \odot \boldsymbol{r_t}
///
/// Output Gate
///     .. math::
///         \boldsymbol{o_t} = \
///             g(\mathrm{clip}(W_o \boldsymbol{x_t} + \
///                             R_o \boldsymbol{c_t} + b_o))
///
/// Output
///     .. math::
///         \boldsymbol{y_t} = \
///             (1 - \boldsymbol{z_t}) \odot \boldsymbol{o_t} + \
///              \boldsymbol{z_t} \odot \boldsymbol{y_{t-1}}
///
/// - ``W_z``, ``W_r``, ``W_o`` are 2-dimensional input weight matrices
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R_z``, ``R_r``, ``R_o`` are 2-dimensional recursion matrices
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b_z``, ``b_r``, ``b_o`` are 1-dimensional bias vectors
///   (``[outputVectorSize]``)
/// - ``f()``, ``g()`` are activations
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
/// - ``⊙`` denotes the elementwise product of matrices
public struct GRULayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Size of the input vectors.
  public var inputVectorSize: UInt64 {
    get {return _storage._inputVectorSize}
    set {_uniqueStorage()._inputVectorSize = newValue}
  }

  /// Size of the output vectors.
  public var outputVectorSize: UInt64 {
    get {return _storage._outputVectorSize}
    set {_uniqueStorage()._outputVectorSize = newValue}
  }

  ///
  /// 2 element array representing activations [f(), g()] in that order.
  /// Typical values used = [sigmoid, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  public var activations: [ActivationParams] {
    get {return _storage._activations}
    set {_uniqueStorage()._activations = newValue}
  }

  ///
  /// If false output is just the result after final state update.
  /// If true, output is a sequence, containing outputs at all time steps.
  public var sequenceOutput: Bool {
    get {return _storage._sequenceOutput}
    set {_uniqueStorage()._sequenceOutput = newValue}
  }

  ///
  /// If false, no biases (``b_z``, ``b_r``, ``b_o``) are added.
  public var hasBiasVectors_p: Bool {
    get {return _storage._hasBiasVectors_p}
    set {_uniqueStorage()._hasBiasVectors_p = newValue}
  }

  /// Weight Matrix W_z.
  public var updateGateWeightMatrix: WeightParams {
    get {return _storage._updateGateWeightMatrix ?? WeightParams()}
    set {_uniqueStorage()._updateGateWeightMatrix = newValue}
  }
  /// Returns true if `updateGateWeightMatrix` has been explicitly set.
  public var hasUpdateGateWeightMatrix: Bool {return _storage._updateGateWeightMatrix != nil}
  /// Clears the value of `updateGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateGateWeightMatrix() {_uniqueStorage()._updateGateWeightMatrix = nil}

  /// Weight Matrix W_r.
  public var resetGateWeightMatrix: WeightParams {
    get {return _storage._resetGateWeightMatrix ?? WeightParams()}
    set {_uniqueStorage()._resetGateWeightMatrix = newValue}
  }
  /// Returns true if `resetGateWeightMatrix` has been explicitly set.
  public var hasResetGateWeightMatrix: Bool {return _storage._resetGateWeightMatrix != nil}
  /// Clears the value of `resetGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearResetGateWeightMatrix() {_uniqueStorage()._resetGateWeightMatrix = nil}

  /// Weight Matrix W_o.
  public var outputGateWeightMatrix: WeightParams {
    get {return _storage._outputGateWeightMatrix ?? WeightParams()}
    set {_uniqueStorage()._outputGateWeightMatrix = newValue}
  }
  /// Returns true if `outputGateWeightMatrix` has been explicitly set.
  public var hasOutputGateWeightMatrix: Bool {return _storage._outputGateWeightMatrix != nil}
  /// Clears the value of `outputGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateWeightMatrix() {_uniqueStorage()._outputGateWeightMatrix = nil}

  /// Recursion Weight Matrix R_z.
  public var updateGateRecursionMatrix: WeightParams {
    get {return _storage._updateGateRecursionMatrix ?? WeightParams()}
    set {_uniqueStorage()._updateGateRecursionMatrix = newValue}
  }
  /// Returns true if `updateGateRecursionMatrix` has been explicitly set.
  public var hasUpdateGateRecursionMatrix: Bool {return _storage._updateGateRecursionMatrix != nil}
  /// Clears the value of `updateGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateGateRecursionMatrix() {_uniqueStorage()._updateGateRecursionMatrix = nil}

  /// Recursion Weight Matrix R_r.
  public var resetGateRecursionMatrix: WeightParams {
    get {return _storage._resetGateRecursionMatrix ?? WeightParams()}
    set {_uniqueStorage()._resetGateRecursionMatrix = newValue}
  }
  /// Returns true if `resetGateRecursionMatrix` has been explicitly set.
  public var hasResetGateRecursionMatrix: Bool {return _storage._resetGateRecursionMatrix != nil}
  /// Clears the value of `resetGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearResetGateRecursionMatrix() {_uniqueStorage()._resetGateRecursionMatrix = nil}

  /// Recursion Weight Matrix R_o.
  public var outputGateRecursionMatrix: WeightParams {
    get {return _storage._outputGateRecursionMatrix ?? WeightParams()}
    set {_uniqueStorage()._outputGateRecursionMatrix = newValue}
  }
  /// Returns true if `outputGateRecursionMatrix` has been explicitly set.
  public var hasOutputGateRecursionMatrix: Bool {return _storage._outputGateRecursionMatrix != nil}
  /// Clears the value of `outputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateRecursionMatrix() {_uniqueStorage()._outputGateRecursionMatrix = nil}

  /// Bias vector b_z.
  public var updateGateBiasVector: WeightParams {
    get {return _storage._updateGateBiasVector ?? WeightParams()}
    set {_uniqueStorage()._updateGateBiasVector = newValue}
  }
  /// Returns true if `updateGateBiasVector` has been explicitly set.
  public var hasUpdateGateBiasVector: Bool {return _storage._updateGateBiasVector != nil}
  /// Clears the value of `updateGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateGateBiasVector() {_uniqueStorage()._updateGateBiasVector = nil}

  /// Bias vector b_r.
  public var resetGateBiasVector: WeightParams {
    get {return _storage._resetGateBiasVector ?? WeightParams()}
    set {_uniqueStorage()._resetGateBiasVector = newValue}
  }
  /// Returns true if `resetGateBiasVector` has been explicitly set.
  public var hasResetGateBiasVector: Bool {return _storage._resetGateBiasVector != nil}
  /// Clears the value of `resetGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearResetGateBiasVector() {_uniqueStorage()._resetGateBiasVector = nil}

  /// Bias vector b_o.
  public var outputGateBiasVector: WeightParams {
    get {return _storage._outputGateBiasVector ?? WeightParams()}
    set {_uniqueStorage()._outputGateBiasVector = newValue}
  }
  /// Returns true if `outputGateBiasVector` has been explicitly set.
  public var hasOutputGateBiasVector: Bool {return _storage._outputGateBiasVector != nil}
  /// Clears the value of `outputGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateBiasVector() {_uniqueStorage()._outputGateBiasVector = nil}

  /// If true, then the node processes the input sequence from right to left
  public var reverseInput: Bool {
    get {return _storage._reverseInput}
    set {_uniqueStorage()._reverseInput = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Long short-term memory (LSTM) parameters.
///
/// This is described by the following equations:
///
/// Input Gate
///     .. math::
///         \boldsymbol{i_t} = \
///             f(\mathrm{clip}(W_i \boldsymbol{x_t} + \
///                             R_i \boldsymbol{y_{t-1}} + \
///                             p_i \odot c_{t-1} + b_i))
///
/// Forget Gate
///     .. math::
///         \boldsymbol{f_t} = \
///             f(\mathrm{clip}(W_f \boldsymbol{x_t} + \
///                             R_f \boldsymbol{y_{t-1}} + \
///                             p_f \odot c_{t-1} + b_f))
///
/// Block Input
///     .. math::
///         \boldsymbol{z_t} = \
///             g(\mathrm{clip}(W_z \boldsymbol{x_t} + \
///                             R_z \boldsymbol{y_{t-1}} + b_z))
///
/// Cell Memory State
///     .. math::
///         \boldsymbol{c_t} = \
///             \boldsymbol{c_{t-1}} \odot \boldsymbol{f_t} + \
///             \boldsymbol{i_t} \odot \boldsymbol{z_t}
///
/// Output Gate
///     .. math::
///         \boldsymbol{o_t} = \
///             f(\mathrm{clip}(W_o \boldsymbol{x_t} + \
///                             R_o \boldsymbol{y_{t-1}} + \
///                             p_o \odot c_t + b_o))
///
/// Output
///     .. math::
///         \boldsymbol{y_t} = \
///             h(\boldsymbol{c_t}) \odot \boldsymbol{o_t}
///
/// - ``W_i``, ``W_f``, ``W_z``, ``W_o`` are 2-dimensional input weight matrices
///   (``[outputVectorSize, inputVectorSize]``, row-major)
/// - ``R_i``, ``R_f``, ``R_z``, ``R_o`` are 2-dimensional recursion matrices
///   (``[outputVectorSize, outputVectorSize]``, row-major)
/// - ``b_i``, ``b_f``, ``b_z``, ``b_o`` are 1-dimensional bias vectors
///   (``[outputVectorSize]``)
/// - ``p_``, ``p_f``, ``p_o`` are 1-dimensional peephole vectors
///   (``[outputVectorSize]``)
/// - ``f()``, ``g()``, ``h()`` are activations
/// - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
/// - ``⊙`` denotes the elementwise product of matrices
public struct LSTMParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// If true, output is a sequence, containing outputs at all time steps.
  /// If false, output is just the result after final state update.
  public var sequenceOutput: Bool = false

  ///
  /// If false, no biases (``b_i``, ``b_f``, ``b_z``, ``b_o``) are added.
  public var hasBiasVectors_p: Bool = false

  ///
  /// If true, a vector of ``1`` values is added to ``b_f``.
  public var forgetBias: Bool = false

  ///
  /// If true, peephole vectors are included.
  public var hasPeepholeVectors_p: Bool = false

  ///
  /// If the coupled Input and Forget flag is on, the behaviour of
  /// ``c_t`` is changed to the following (i.e. forget gate is not used):
  ///
  /// .. math::
  ///     \boldsymbol{c_t} = \
  ///         \boldsymbol{c_{t-1}} \odot (1 - \boldsymbol{i_t}) + \
  ///         \boldsymbol{i_t} \odot \boldsymbol{z_t}
  public var coupledInputAndForgetGate: Bool = false

  ///
  /// Places a limit on the maximum and minimum values of ``c_t``.
  /// c_t = min(c_t, cellClipThreshold)
  /// c_t = max(c_t, -cellClipThreshold)
  /// If 0, it is set to its default value = 50.0.
  public var cellClipThreshold: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Weights for long short-term memory (LSTM) layers
public struct LSTMWeightParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Weight Matrix W_i.
  public var inputGateWeightMatrix: WeightParams {
    get {return _storage._inputGateWeightMatrix ?? WeightParams()}
    set {_uniqueStorage()._inputGateWeightMatrix = newValue}
  }
  /// Returns true if `inputGateWeightMatrix` has been explicitly set.
  public var hasInputGateWeightMatrix: Bool {return _storage._inputGateWeightMatrix != nil}
  /// Clears the value of `inputGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearInputGateWeightMatrix() {_uniqueStorage()._inputGateWeightMatrix = nil}

  /// Weight Matrix W_f.
  public var forgetGateWeightMatrix: WeightParams {
    get {return _storage._forgetGateWeightMatrix ?? WeightParams()}
    set {_uniqueStorage()._forgetGateWeightMatrix = newValue}
  }
  /// Returns true if `forgetGateWeightMatrix` has been explicitly set.
  public var hasForgetGateWeightMatrix: Bool {return _storage._forgetGateWeightMatrix != nil}
  /// Clears the value of `forgetGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearForgetGateWeightMatrix() {_uniqueStorage()._forgetGateWeightMatrix = nil}

  /// Weight Matrix W_z.
  public var blockInputWeightMatrix: WeightParams {
    get {return _storage._blockInputWeightMatrix ?? WeightParams()}
    set {_uniqueStorage()._blockInputWeightMatrix = newValue}
  }
  /// Returns true if `blockInputWeightMatrix` has been explicitly set.
  public var hasBlockInputWeightMatrix: Bool {return _storage._blockInputWeightMatrix != nil}
  /// Clears the value of `blockInputWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearBlockInputWeightMatrix() {_uniqueStorage()._blockInputWeightMatrix = nil}

  /// Weight Matrix W_o.
  public var outputGateWeightMatrix: WeightParams {
    get {return _storage._outputGateWeightMatrix ?? WeightParams()}
    set {_uniqueStorage()._outputGateWeightMatrix = newValue}
  }
  /// Returns true if `outputGateWeightMatrix` has been explicitly set.
  public var hasOutputGateWeightMatrix: Bool {return _storage._outputGateWeightMatrix != nil}
  /// Clears the value of `outputGateWeightMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateWeightMatrix() {_uniqueStorage()._outputGateWeightMatrix = nil}

  /// Recursion Weight Matrix R_i.
  public var inputGateRecursionMatrix: WeightParams {
    get {return _storage._inputGateRecursionMatrix ?? WeightParams()}
    set {_uniqueStorage()._inputGateRecursionMatrix = newValue}
  }
  /// Returns true if `inputGateRecursionMatrix` has been explicitly set.
  public var hasInputGateRecursionMatrix: Bool {return _storage._inputGateRecursionMatrix != nil}
  /// Clears the value of `inputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearInputGateRecursionMatrix() {_uniqueStorage()._inputGateRecursionMatrix = nil}

  /// Recursion Weight Matrix R_f.
  public var forgetGateRecursionMatrix: WeightParams {
    get {return _storage._forgetGateRecursionMatrix ?? WeightParams()}
    set {_uniqueStorage()._forgetGateRecursionMatrix = newValue}
  }
  /// Returns true if `forgetGateRecursionMatrix` has been explicitly set.
  public var hasForgetGateRecursionMatrix: Bool {return _storage._forgetGateRecursionMatrix != nil}
  /// Clears the value of `forgetGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearForgetGateRecursionMatrix() {_uniqueStorage()._forgetGateRecursionMatrix = nil}

  /// Recursion Weight Matrix R_z.
  public var blockInputRecursionMatrix: WeightParams {
    get {return _storage._blockInputRecursionMatrix ?? WeightParams()}
    set {_uniqueStorage()._blockInputRecursionMatrix = newValue}
  }
  /// Returns true if `blockInputRecursionMatrix` has been explicitly set.
  public var hasBlockInputRecursionMatrix: Bool {return _storage._blockInputRecursionMatrix != nil}
  /// Clears the value of `blockInputRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearBlockInputRecursionMatrix() {_uniqueStorage()._blockInputRecursionMatrix = nil}

  /// Recursion Weight Matrix R_o.
  public var outputGateRecursionMatrix: WeightParams {
    get {return _storage._outputGateRecursionMatrix ?? WeightParams()}
    set {_uniqueStorage()._outputGateRecursionMatrix = newValue}
  }
  /// Returns true if `outputGateRecursionMatrix` has been explicitly set.
  public var hasOutputGateRecursionMatrix: Bool {return _storage._outputGateRecursionMatrix != nil}
  /// Clears the value of `outputGateRecursionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateRecursionMatrix() {_uniqueStorage()._outputGateRecursionMatrix = nil}

  ///biases:
  public var inputGateBiasVector: WeightParams {
    get {return _storage._inputGateBiasVector ?? WeightParams()}
    set {_uniqueStorage()._inputGateBiasVector = newValue}
  }
  /// Returns true if `inputGateBiasVector` has been explicitly set.
  public var hasInputGateBiasVector: Bool {return _storage._inputGateBiasVector != nil}
  /// Clears the value of `inputGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearInputGateBiasVector() {_uniqueStorage()._inputGateBiasVector = nil}

  /// Bias vector b_f.
  public var forgetGateBiasVector: WeightParams {
    get {return _storage._forgetGateBiasVector ?? WeightParams()}
    set {_uniqueStorage()._forgetGateBiasVector = newValue}
  }
  /// Returns true if `forgetGateBiasVector` has been explicitly set.
  public var hasForgetGateBiasVector: Bool {return _storage._forgetGateBiasVector != nil}
  /// Clears the value of `forgetGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearForgetGateBiasVector() {_uniqueStorage()._forgetGateBiasVector = nil}

  /// Bias vector b_z.
  public var blockInputBiasVector: WeightParams {
    get {return _storage._blockInputBiasVector ?? WeightParams()}
    set {_uniqueStorage()._blockInputBiasVector = newValue}
  }
  /// Returns true if `blockInputBiasVector` has been explicitly set.
  public var hasBlockInputBiasVector: Bool {return _storage._blockInputBiasVector != nil}
  /// Clears the value of `blockInputBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearBlockInputBiasVector() {_uniqueStorage()._blockInputBiasVector = nil}

  /// Bias vector b_o.
  public var outputGateBiasVector: WeightParams {
    get {return _storage._outputGateBiasVector ?? WeightParams()}
    set {_uniqueStorage()._outputGateBiasVector = newValue}
  }
  /// Returns true if `outputGateBiasVector` has been explicitly set.
  public var hasOutputGateBiasVector: Bool {return _storage._outputGateBiasVector != nil}
  /// Clears the value of `outputGateBiasVector`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGateBiasVector() {_uniqueStorage()._outputGateBiasVector = nil}

  ///peepholes:
  public var inputGatePeepholeVector: WeightParams {
    get {return _storage._inputGatePeepholeVector ?? WeightParams()}
    set {_uniqueStorage()._inputGatePeepholeVector = newValue}
  }
  /// Returns true if `inputGatePeepholeVector` has been explicitly set.
  public var hasInputGatePeepholeVector: Bool {return _storage._inputGatePeepholeVector != nil}
  /// Clears the value of `inputGatePeepholeVector`. Subsequent reads from it will return its default value.
  public mutating func clearInputGatePeepholeVector() {_uniqueStorage()._inputGatePeepholeVector = nil}

  /// Peephole vector p_f.
  public var forgetGatePeepholeVector: WeightParams {
    get {return _storage._forgetGatePeepholeVector ?? WeightParams()}
    set {_uniqueStorage()._forgetGatePeepholeVector = newValue}
  }
  /// Returns true if `forgetGatePeepholeVector` has been explicitly set.
  public var hasForgetGatePeepholeVector: Bool {return _storage._forgetGatePeepholeVector != nil}
  /// Clears the value of `forgetGatePeepholeVector`. Subsequent reads from it will return its default value.
  public mutating func clearForgetGatePeepholeVector() {_uniqueStorage()._forgetGatePeepholeVector = nil}

  /// Peephole vector p_o.
  public var outputGatePeepholeVector: WeightParams {
    get {return _storage._outputGatePeepholeVector ?? WeightParams()}
    set {_uniqueStorage()._outputGatePeepholeVector = newValue}
  }
  /// Returns true if `outputGatePeepholeVector` has been explicitly set.
  public var hasOutputGatePeepholeVector: Bool {return _storage._outputGatePeepholeVector != nil}
  /// Clears the value of `outputGatePeepholeVector`. Subsequent reads from it will return its default value.
  public mutating func clearOutputGatePeepholeVector() {_uniqueStorage()._outputGatePeepholeVector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A unidirectional long short-term memory (LSTM) layer.
///
/// .. code::
///
///      (y_t, c_t) = UniDirectionalLSTMLayer(x_t, y_{t-1}, c_{t-1})
///
/// Input
///    A blob of rank 5, with shape `[Seq, Batch, inputVectorSize, 1, 1]``.
///    This represents a sequence of vectors of size ``inputVectorSize``.
/// Output
///    Same rank as the input.
///    Represents a vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
///
/// - Output Shape: ``[1, Batch, outputVectorSize, 1, 1]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq, Batch, outputVectorSize, 1, 1]`` , if ``sequenceOutput == true``
public struct UniDirectionalLSTMLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Size of the input vectors.
  public var inputVectorSize: UInt64 = 0

  /// Size of the output vectors.
  public var outputVectorSize: UInt64 = 0

  ///
  /// 3 element array representing activations [f(),g(),h()] in that order.
  /// Typical values used = [sigmoid, tanh, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  public var activations: [ActivationParams] = []

  public var params: LSTMParams {
    get {return _params ?? LSTMParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  /// Weights, biases and peepholes.
  public var weightParams: LSTMWeightParams {
    get {return _weightParams ?? LSTMWeightParams()}
    set {_weightParams = newValue}
  }
  /// Returns true if `weightParams` has been explicitly set.
  public var hasWeightParams: Bool {return self._weightParams != nil}
  /// Clears the value of `weightParams`. Subsequent reads from it will return its default value.
  public mutating func clearWeightParams() {self._weightParams = nil}

  /// If true, then the node processes the input sequence from right to left
  public var reverseInput: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: LSTMParams? = nil
  fileprivate var _weightParams: LSTMWeightParams? = nil
}

///
/// Bidirectional long short-term memory (LSTM) layer
///
/// .. code::
///
///      (y_t, c_t, y_t_reverse, c_t_reverse) = BiDirectionalLSTMLayer(x_t, y_{t-1}, c_{t-1}, y_{t-1}_reverse, c_{t-1}_reverse)
///
/// Input
///    A blob of rank 5, with shape `[Seq, Batch, inputVectorSize, 1, 1]``.
///    This represents a sequence of vectors of size ``inputVectorSize``.
/// Output
///    Same rank as the input.
///    Represents a vector of size ``2 * outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
///
/// - Output Shape: ``[1, Batch, 2 * outputVectorSize, 1, 1]`` , if ``sequenceOutput == false``
/// - Output Shape: ``[Seq, Batch, 2 * outputVectorSize, 1, 1]`` , if ``sequenceOutput == true``
///
///
/// The first LSTM operates on the input sequence in the forward direction.
/// The second LSTM operates on the input sequence in the reverse direction.
///
/// Example: given the input sequence ``[x_1, x_2, x_3]``,
/// where ``x_i`` are vectors at time index ``i``:
///
/// The forward LSTM output is ``[yf_1, yf_2, yf_3]``,
///
/// where ``yf_i`` are vectors of size ``outputVectorSize``:
///
/// - ``yf_1`` is the output at the end of sequence {``x_1``}
/// - ``yf_2`` is the output at the end of sequence {``x_1``, ``x_2``}
/// - ``yf_3`` is the output at the end of sequence {``x_1``, ``x_2``, ``x_3``}
///
/// The backward LSTM output: ``[yb_1, yb_2, yb_3]``,
///
/// where ``yb_i`` are vectors of size ``outputVectorSize``:
///
/// - ``yb_1`` is the output at the end of sequence {``x_3``}
/// - ``yb_2`` is the output at the end of sequence {``x_3``, ``x_2``}
/// - ``yb_3`` is the output at the end of sequence {``x_3``, ``x_2``, ``x_1``}
///
/// Output of the bi-dir layer:
///
/// - if ``sequenceOutput = True`` : { ``[yf_1, yb_3]``,  ``[yf_2, yb_2]``,  ``[yf_3, yb_1]`` }
/// - if ``sequenceOutput = False`` : { ``[yf_3, yb_3]`` }
public struct BiDirectionalLSTMLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Size of the input vectors.
  public var inputVectorSize: UInt64 = 0

  ///
  /// Size of the outputs vectors.
  /// It is same for both forward and backward LSTMs.
  public var outputVectorSize: UInt64 = 0

  ///
  /// 3 element array representing activations [f(),g(),h()] in that order.
  /// Typical values used = [sigmoid, tanh, tanh].
  /// Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
  public var activationsForwardLstm: [ActivationParams] = []

  ///
  /// Currently, backward LSTM activations
  /// must be same as the ones for the forward LSTM.
  public var activationsBackwardLstm: [ActivationParams] = []

  ///
  /// Common parameters shared by the forward and backward LSTMs.
  public var params: LSTMParams {
    get {return _params ?? LSTMParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  ///
  /// Weights and biases.
  /// Must be a length 2 message,
  /// for the forward and backward LSTM respectively.
  public var weightParams: [LSTMWeightParams] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: LSTMParams? = nil
}

public struct CustomLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the class (conforming to MLCustomLayer) corresponding to this layer
  public var className: String = String()

  /// Any weights -- these are serialized in binary format and memmapped at runtime
  public var weights: [WeightParams] = []

  /// these may be handled as strings, so this should not be large
  public var parameters: Dictionary<String,CustomLayerParams.CustomLayerParamValue> = [:]

  /// An (optional) description of the layer provided by the model creator. This information is displayed when viewing the model, but does not affect the model's execution on device.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct CustomLayerParamValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: CustomLayerParams.CustomLayerParamValue.OneOf_Value? = nil

    public var doubleValue: Double {
      get {
        if case .doubleValue(let v)? = value {return v}
        return 0
      }
      set {value = .doubleValue(newValue)}
    }

    public var stringValue: String {
      get {
        if case .stringValue(let v)? = value {return v}
        return String()
      }
      set {value = .stringValue(newValue)}
    }

    public var intValue: Int32 {
      get {
        if case .intValue(let v)? = value {return v}
        return 0
      }
      set {value = .intValue(newValue)}
    }

    public var longValue: Int64 {
      get {
        if case .longValue(let v)? = value {return v}
        return 0
      }
      set {value = .longValue(newValue)}
    }

    public var boolValue: Bool {
      get {
        if case .boolValue(let v)? = value {return v}
        return false
      }
      set {value = .boolValue(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Value: Equatable {
      case doubleValue(Double)
      case stringValue(String)
      case intValue(Int32)
      case longValue(Int64)
      case boolValue(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: CustomLayerParams.CustomLayerParamValue.OneOf_Value, rhs: CustomLayerParams.CustomLayerParamValue.OneOf_Value) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.doubleValue, .doubleValue): return {
          guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.stringValue, .stringValue): return {
          guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.intValue, .intValue): return {
          guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.longValue, .longValue): return {
          guard case .longValue(let l) = lhs, case .longValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.boolValue, .boolValue): return {
          guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

public struct TransposeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Length of "axes" should match the rank of input & output tensor
  /// "axes" should be a permutation of "[0,1,2,...,N-1]" where N is the rank.
  public var axes: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes the matrix multiplication of two tensors with numpy-like broadcasting
/// where the matrices reside in the last two indices of the tensor.
///
/// .. code::
///
///      y = BatchedMatMul(a,b)
///
/// Requires 1 or 2 inputs and produces 1 output.
///
/// The first tensor, "a", must be provided as an input. The second tensor can either be an input or provided as a weight matrix parameter.
///
/// Input
///     - a: First N-Dimensional tensor
///     - b: Second N-Dimensional tensor (either a rank-N input or a matrix, i.e. N=2, provided as a layer parameter)
///
/// Output
///     A tensor containing the matrix product of two tensors.
///     When there are two inputs: rank is max(2, rank(a), rank(b))
///     When there is one input: rank is same as that of the input.
///
/// This operation behaves as following:
///
///  When there are two inputs:
///      - If N >= 2 for both tensors, it is treated as a batch of matrices residing in the last two indices.
///        All the indices, except for the last two, are broadcasted using conventional rules.
///      - If the first tensor is 1-D, it is converted to a 2-D tensor by prepending a 1 to its shape. Eg. (D) -> (1,D)
///      - If the second tensor is 1-D, it is converted to a 2-D tensor by appending a 1 to its shape. Eg. (D) -> (D,1)
///
///  When there is one input:
///      - The weight matrix corresponds to a matrix, of shape (X1, X2). Values of X1, X2 must be provided as layer parameters.
///      - The input, "a", is reshaped into a matrix by combining all the leading dimensions, except the last, into a batch dimension. eg:
///             - if "a" is rank 1 (X1,) -->  (1, X1). Output shape will be (X2,)
///             - if "a" is rank 2 (B1, X1) --> no need to reshape. Output shape will be (B1, X2)
///             - if "a" is rank 3 (B1, B2, X1) --> (B1 * B2, X1). Output shape will be (B1, B2, X2)
///             - etc
public struct BatchedMatMulLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// If transposeA is true, it transposes the left matrix on the fly before matrix multiplication.
  /// (is ignored when there is one input)
  public var transposeA: Bool {
    get {return _storage._transposeA}
    set {_uniqueStorage()._transposeA = newValue}
  }

  ///
  /// If transposeB is true, it transposes the right matrix on the fly before matrix multiplication.
  /// (is ignored when there is one input)
  public var transposeB: Bool {
    get {return _storage._transposeB}
    set {_uniqueStorage()._transposeB = newValue}
  }

  /// X1: same as the last dimension of the input tensor
  public var weightMatrixFirstDimension: UInt64 {
    get {return _storage._weightMatrixFirstDimension}
    set {_uniqueStorage()._weightMatrixFirstDimension = newValue}
  }

  /// X2: same as the last dimension of the output tensor
  public var weightMatrixSecondDimension: UInt64 {
    get {return _storage._weightMatrixSecondDimension}
    set {_uniqueStorage()._weightMatrixSecondDimension = newValue}
  }

  /// Whether a bias is added or not. Supported only when there is one input.
  public var hasBias_p: Bool {
    get {return _storage._hasBias_p}
    set {_uniqueStorage()._hasBias_p = newValue}
  }

  ///
  /// Weight matrix representing shape [X1, X2].
  /// Values are however stored in column major order,
  /// in the "repeated float" or "bytes" fields of the message "WeightParams"
  public var weights: WeightParams {
    get {return _storage._weights ?? WeightParams()}
    set {_uniqueStorage()._weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return _storage._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {_uniqueStorage()._weights = nil}

  /// Bias vector [X2]. Supported only when there is one input.
  public var bias: WeightParams {
    get {return _storage._bias ?? WeightParams()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  public var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  public mutating func clearBias() {_uniqueStorage()._bias = nil}

  ///
  /// If set, this layer, at runtime, quantizes the floating point input blob to int8 before applying the
  /// matrix multiplication using the INT8 weight parameters provided in weights->int8RawValue. The
  /// result is then dequantized.
  /// Requires:
  /// * number of inputs to be 1
  /// * hasBias == false
  /// * QuantizationType == LinearQuantizationParams, such that
  ///   * size of the "scale" field is 1 and "bias" field is empty in "LinearQuantizationParams"
  /// * numberOfBits == 8
  /// * weights->rawValue_size to be empty
  public var int8DynamicQuantize: Bool {
    get {return _storage._int8DynamicQuantize}
    set {_uniqueStorage()._int8DynamicQuantize = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// A layer that concatenates a list of tensors along a specified axis.
///
/// .. code::
///
///      y = ConcatNDLayer(x1,x2,....)
///
/// Requires at least 2 input and produces 1 output.
///
/// Input
///     The rank of the input tensors must match and all dimensions also must match, except for the dimension 'axis'.
///
///
/// Output
///     Same rank as the input. The dimension along "axis", is the sum of the dimensions of the inputs.
///
/// example:
///
/// in1 : shape (3, 2), value = [[1, 2], [3, 4], [5, 6]]
/// in2 : shape (3, 2), value = [[7, 8], [9, 10], [11, 12]]
/// axis = 0
///
/// if interleave = False (default)
/// output : shape (6, 2)
/// output[0:3, :] = in1
/// output[3:6, :] = in2
/// value = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]
///
/// if interleave = True
/// output : shape (6, 2)
/// output[0::2, :] = in1
/// output[1::2, :] = in2
/// value = [[1, 2], [7, 8], [3, 4], [9, 10], [5, 6], [11, 12]]
public struct ConcatNDLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Dimension along which to concatenate. Supports negative values of the parameter 'axis'.
  public var axis: Int64 = 0

  ///
  /// (Only available in Core ML Specification >= 5 (iOS >= 14, macOS >= 11.0)
  /// Interleave option. If True, concatenation is done via interleaving the inputs.
  /// This requires all inputs to have the exact same shape.
  public var interleave: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs softmax normalization along a specified axis.
///
/// .. code::
///
///      y = SoftmaxNDLayer(x)
///
/// Requires 1 input and produces 1 output.
///
/// Output shape is same as the input.
public struct SoftmaxNDLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Dimension on which the softmax would be performed. Supports negative values of the parameter 'axis'.
  public var axis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that reverses specific dimensions of the input tensor.
/// It is similar in functionality to the numpy.flip method.
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct ReverseLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Reverses each dimension of the input tensor for which corresponding reverseDim is set to True.
  /// Requires len(reverseDim) == rank(inputTensor)
  public var reverseDim: [Bool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that reverses variable length slices.
///
/// Requires 2 inputs and produces 1 output.
///
/// 2 inputs, in order are denoted by "data", "seq_lengths".
/// "seq_lenghts" must be a rank 1 tensor, i.e. seq_lengths.shape = (B,)
/// which contains the lengths of the amount of sequence to be reversed, for each element of the batch.
/// Dimension "batchAxis" in "data" must be equal to B, i.e,
/// data.shape[batchAxis] = B.
///
/// According to the batch axis, input "data" is first divided into a batch of B inputs,
/// each of which is flipped along the dimension "sequenceAxis", by the amount specified in
/// "seq_lengths", the second input.
///
/// e.g.:
///
/// data [shape = (2,4)]:
/// [0 1 2 3]
/// [4 5 6 7]
/// seq_lengths [shape = (2,)]:
/// [3, 0]
/// batchAxis = 0
/// sequenceAxis = 1
///
/// output [shape = (2,4)]:
/// [2 1 0 3]
/// [4 5 6 7]
///
///
/// data [shape = (2,3,2)]:
/// [0 1]
/// [2 3]
/// [4 5] (slice = 0)
/// [6 7]
/// [8 9]
/// [10 11] (slice = 1)
/// seq_lengths [shape = (2,)]:
/// [2, 3]
/// batchAxis = 0
/// sequenceAxis = 1
///
/// output [shape = (2,3,2)]:
/// [2 3]
/// [0 1]
/// [4 5] (slice = 0)
/// [10 11]
/// [8 9]
/// [6 7] (slice = 1)
///
/// Output shape is same as the input.
public struct ReverseSeqLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// batch axis has to be strictly less than seq_axis
  public var batchAxis: Int64 = 0

  public var sequenceAxis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that loads data as a parameter and provides it as an output.
///
/// .. code::
///
///      y = LoadConstantNDLayer()
///
/// Requires no input and produces 1 output.
///
/// Output: A tensor with shape as provided in the parameter "shape"
public struct LoadConstantNDLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The shape of the constant to be loaded.
  public var shape: [UInt64] = []

  public var data: WeightParams {
    get {return _data ?? WeightParams()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: WeightParams? = nil
}

///
/// A layer that generates an output tensor with a constant value.
/// Input is only used to determine the shape of the output.
/// This layer is used to allocate a tensor with a dynamic shape (that of the input) and constant value.
///
/// Requires 1 input and produces 1 output.
///
/// .. code::
///
///      y = FillLikeLayer(x)
///
/// Input
///     A N-Dimensional tensor, whose values are ignored. Only the shape is used to
///     infer the shape of the output.
///
/// Output
///     A N-Dimensional tensor with the same shape as the input tensor.
public struct FillLikeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that generates an output tensor with a constant value.
/// This layer is used to allocate a tensor with a static shape and constant value.
///
/// Requires no input and produces 1 output.
///
/// .. code::
///
///      y = FillStaticLayer(x)
///
/// Output
///     A N-Dimensional tensor of shape "targetShape".
public struct FillStaticLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Float = 0

  public var targetShape: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that generates an output tensor with a constant value.
/// This layer is used to allocate a tensor with a dynamic shape (as specified by the input) and constant value.
///
/// Requires 1 input and produces 1 output.
///
/// .. code::
///
///      y = FillDynamicLayer(x)
///
/// Input
///     A rank 1 tensor specifying the shape of the output
///
/// Output
///     An N-Dimensional tensor with the shape specified by the values in the input tensor.
public struct FillDynamicLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns the elements either from tensor x or tensor y,
/// depending on the value in the condition tensor.
/// It is similar in functionality to the numpy.where method with 3 inputs.
///
/// Requires 3 inputs and produces 1 output.
/// Inputs, in order, are the condition tensor, x and y.
///
/// for each vector index (i,...,j):
///    output[i,...,j] = x[i,...,j] if condition[i,...,j] = True
///                      y[i,...,j] if condition[i,...,j] = False
///
/// All the 3 inputs are first broadcasted to a common shape.
/// (the shapes must be broadcastable)
///
/// output.rank = max(input[0].rank, input[1].rank, input[2].rank)
public struct WhereBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric sine function.
///
///
/// .. code::
///
///      y = SinLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct SinLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric cosine function.
///
///
/// .. code::
///
///      y = CosLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct CosLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric tangent function.
///
///
/// .. code::
///
///      y = TanLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct TanLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric arcsine function.
///
///
/// .. code::
///
///      y = AsinLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct AsinLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric arccosine function.
///
///
/// .. code::
///
///      y = AcosLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct AcosLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric arctangent function.
///
///
/// .. code::
///
///      y = AtanLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct AtanLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric hyperbolic sine function.
///
///
/// .. code::
///
///      y = SinhLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct SinhLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric hyperbolic cosine function.
///
///
/// .. code::
///
///      y = CoshLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct CoshLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric hyperbolic tangent function.
///
///
/// .. code::
///
///      y = TanhLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct TanhLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric hyperbolic arcsine function.
///
///
/// .. code::
///
///      y = AsinhLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct AsinhLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric hyperbolic arccosine function.
///
///
/// .. code::
///
///      y = AcoshLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct AcoshLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes elementwise trigonometric hyperbolic arctangent function.
///
///
/// .. code::
///
///      y = AtanhLayer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct AtanhLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that raises each element in first tensor to the power of
/// corresponding element in the second tensor.
/// Supports conventional numpy-like broadcasting.
///
/// .. code::
///
///      y = PowBroadcastableLayer(x)
///
/// Requires 2 inputs and produces 1 output.
///
/// Input
///     - First N-Dimensional tensor
///     - Second N-Dimensional tensor
///
/// Output
///     An N-Dimensional tensor with the broadcast shape.
public struct PowBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes the exponential of all elements in the input tensor, with the base 2.
///
///
/// .. code::
///
///      y = Exp2Layer(x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct Exp2LayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor containing the indices of all non-zero
/// elements of input tensor.
/// It is similar in functionality to the numpy.where method with 1 input.
///
/// Requires 1 input and produces 1 output.
/// Output is of rank 2, of shape (N,R),
/// where N is the number of non-zero elements in the input and R is the rank of the input.
///
/// Output contains indices represented in the multi-index form
///
/// e.g.:
/// input {shape = (4,)}:
/// [0 1 0 2]
/// output {shape = (2,1)}:
/// [1]
/// [3]
///
///
/// input {shape = (3, 3)}:
/// [1 2 1]
/// [0 2 2]
/// [2 1 0]
/// output {shape = (7,1)}:
/// [0. 0.]
/// [0. 1.]
/// [0. 2.]
/// [1. 1.]
/// [1. 2.]
/// [2. 0.]
/// [2. 1.]
public struct WhereNonZeroLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that copies a tensor setting everything outside a central band in
/// each inner-most matrix to zero.
///
/// Requires 1 input and produces 1 output.
///
/// Parameters for matrix_band_part layer
/// band(m, n) = (num_lower < 0 || (m-n) <= num_lower) && (num_upper < 0 || (n-m) <= num_upper).
/// output[i, j, k, ..., m, n] = band(m, n) * input[i, j, k, ..., m, n]
///
///
/// Output shape is same as the input shape.
/// Rank of the input must be at least 2.
/// For rank higher than 2, the last 2 dimensions are treated as the matrix, while the rest are treated as batch.
public struct MatrixBandPartLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numLower: Int64 = 0

  public var numUpper: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that copies a tensor setting everything outside upper triangular to zero.
///
/// Requires 1 input and produces 1 output.
///
/// Output shape is same as the input shape.
/// Rank of the input must be at least 2.
/// For rank higher than 2, the last 2 dimensions are treated as the matrix, while the rest are treated as batch.
public struct UpperTriangularLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Diagonal below which to zero elements. k = 0 (the default) is the main diagonal, k < 0 is below it and k > 0 is above
  public var k: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that copies a tensor setting everything outside lower triangular to zero.
///
/// Requires 1 input and produces 1 output.
///
/// Output shape is same as the input shape.
/// Rank of the input must be at least 2.
/// For rank higher than 2, the last 2 dimensions are treated as the matrix, while the rest are treated as batch.
public struct LowerTriangularLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Diagonal above which to zero elements. k = 0 (the default) is the main diagonal, k < 0 is below it and k > 0 is above
  public var k: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
///
/// A layer that broadcasts a tensor to a new shape.
///
/// Requires 2 inputs and produces 1 output.
///
/// First input is broadcast to produce the output, while the second input is only
/// used to determine the shape of the output. Values of second input are not used.
///
/// Output is a tensor with the same shape as the second input.
public struct BroadcastToLikeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
///
/// A layer that broadcasts a tensor to a new shape.
///
/// Requires 1 input and produces 1 output.
///
/// Output tensor is the broadcasted version of the input and has shape as specified in the
/// parameter "targetShape".
public struct BroadcastToStaticLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetShape: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
///
/// A layer that broadcasts a tensor to a new shape.
///
/// Requires 2 inputs and produces 1 output.
///
/// First input is the one that is broadcasted to produce the output.
/// Second input is a rank 1 tensor specifying the shape of the output.
/// Output tensor has shape as specified by the values in the 2nd input tensor.
public struct BroadcastToDynamicLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise addition operation with broadcast support.
///
/// Requires 2 inputs and produces 1 output.
public struct AddBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise maximum operation with broadcast support.
///
/// Requires 2 inputs and produces 1 output.
public struct MaxBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise minimum operation with broadcast support.
///
/// Requires 2 inputs and produces 1 output.
public struct MinBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise modular operation with broadcast support.
///
/// Requires 2 inputs and produces 1 output.
public struct ModBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise floor division operation with broadcast support.
///
/// Requires 2 inputs and produces 1 output.
public struct FloorDivBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise subtract operation with broadcast support.
///
/// Requires 2 inputs and produces 1 output.
public struct SubtractBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise multiply operation with broadcast support.
///
/// Requires 2 inputs and produces 1 output.
public struct MultiplyBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise division operation with broadcast support.
///
/// Requires 2 inputs and produces 1 output.
public struct DivideBroadcastableLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Gather layer that gathers elements from the first input, along a specified axis,
/// at indices specified in the second input.
/// It is similar in functionality to the numpy.take method.
///
/// Requires 2 inputs and produces 1 output.
///
/// Given two inputs, 'data' and 'indices', gather the slices of 'data'
/// and store into output.
/// e.g.
/// for i in [0, length(indices) - 1]
///    output[i] = data[indices[i]]  (1-D case, axis=0)
///
/// if axis = 0:
/// for each vector index (i,...,j)
///    output[i,...,j,:,..,:] = data[indices[i,...,j],:,..,:]
///
/// output.rank = (data.rank - 1) + indices.rank
///
/// Negative indices and negative axis are supported.
///
/// e.g:
///
/// data shape = (2, 3)
/// indices shape = (6, 8)
/// axis = 0
/// output shape = (6, 8) + (3,) = (6, 8, 3)
///
/// data shape = (2, 3, 5)
/// indices shape = (6, 8)
/// axis = 1
/// output shape = (2,) + (6, 8) + (5,) =  (2, 6, 8, 5)
public struct GatherLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ScatterLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  /// mode of accumulation.
  public var mode: ScatterMode = .scatterUpdate

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that gathers elements from the first input, 'params', at the multi-indices specified
/// by the second input, 'indices'.
///
/// Requires 2 inputs and produces 1 output.
///
/// 'params' = input[0], 'indices' = input[1]
///
/// 'indices' is a rank K+1 tensor of shape [I_0, I_1, .., I_(K-1), I_K] which is viewed as a collection of
/// indices of (I_0 * I_1 * ... * I_(K-1)) points in the I_K dimensional space. For instance, the multi-index of the first point
/// is indices[0,0,...,0,:].
///
/// Here is how the output is constructed:
///
/// for i = 0,1,...,(I_0-1)
///   ...
///     for j = 0,1,....,(I_(K-1)-1)
///          output[i,....,j,:,:,..,:] = params[indices[i,...,j,:], :,:,..,:]
///
/// Hence, output shape is [I_0, I_1,...,I(K-1)] + params.shape[I_K:]
///
/// output.rank = indices.rank - 1 + params.rank - indices.shape[-1]
///
/// e.g:
///
/// input[0] shape = (4, 2, 3, 4)
/// input[1] shape = (6, 2)
/// output shape = (6,) + (3, 4) = (6, 3, 4)
///
/// input[0] shape = (3, 3, 3, 4, 7)
/// input[1] shape = (3, 5)
/// output shape = (3,) + () = (3,)
///
/// input[0] shape = (5, 3, 2, 5)
/// input[1] shape = (2, 7, 3, 2)
/// output shape = (2, 7, 3) + (2, 5) = (2, 7, 3, 2, 5)
public struct GatherNDLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that scatters data into a new tensor according to multi-indices from the input.
/// This is the inverse operation of GatherND.
///
/// Requires 3 inputs and produces 1 output.
/// 3 inputs, in order are denoted as "container", "indices", "updates".
///
/// 'indices' is a rank K+1 tensor of shape [I_0, I_1, .., I_(K-1), I_K] which is viewed as a collection of
/// indices of (I_0 * I_1 * ... * I_(K-1)) points in the I_K dimensional space. For instance, the multi-index of the first point
/// is indices[0,0,...,0,:].
///
/// container.rank >= I_K
/// updates.rank = K + (container.rank - I_K)
/// shape of 'updates' = [I_0, I_1,...,I(K-1)] + container.shape[I_K:]
///
/// output = container
/// For each vector index (i,...,j) s.t. 0<=i<I_0,..., 0<=j<I_K
///   output[indices[i,...,j,:], :,:,..,:] = updates[i,....,j,:,:,..,:] // if mode == "SCATTER_UPDATE"
///
/// The output has the same shape as the first input.
///
/// e.g:
///
/// container shape = (3, 2)
/// indices shape = (4, 2)
/// updates shape = (4,)
/// output shape = (3, 2)
///
/// container shape = (7, 6)
/// indices shape = (4, 7, 2, 5, 1)
/// updates shape = (4, 7, 2, 5, 6)
/// output shape = (7, 6)
public struct ScatterNDLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// mode of accumulation.
  public var mode: ScatterMode = .scatterUpdate

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Gather layer that gathers elements from the first input, along a specified axis,
/// at indices specified in the second input.
/// It is similar in functionality to the numpy.take_along_axis method.
///
/// Requires 2 inputs and produces 1 output.
///
/// Given two inputs, 'data' and 'indices', gather the slices of 'data'
/// and store into output.
///
/// Both inputs and output have the same rank.
/// Output shape is same as the shape of 'indices'
/// Shapes of 'indices' and 'data' match, except at the 'axis' dimension.
///
/// This operation performs the following operation for axis=0:
/// for each vector index (i,j,....,k)
///    output[i,j,....,k] = data[index[i,j,....,k],j,....,k]
///
/// Negative indices and negative axis are supported.
///
/// e.g:
///
/// data shape = (4, 4, 7)
/// indices shape = (4, 5, 7)
/// axis = 1
/// output shape = (4, 5, 7)
public struct GatherAlongAxisLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that scatters data into a new tensor according to indices from
/// the input along the given axis into the output tensor.
/// This is the inverse operation of GatherAlongAxis.
/// It is similar in functionality to the numpy.put_along_axis method.
///
/// Requires 3 inputs and produces 1 output.
/// 3 inputs, in order are denoted as "container", "indices", "updates".
///
/// All inputs and output have the same rank.
/// Output shape is same as the shape of 'container'
/// Shapes of 'indices' and 'updates' match, which is same as the shape of 'container' except at the 'axis' dimension.
///
/// Negative indices and negative axis are supported.
///
/// This operation performs the following operation for axis=0:
/// output = container
/// for each vector index (i,j,....,k)
///    output[index[i,j,....,k],j,....,k] = updates[i,j,....,k]
///
/// e.g.:
///
/// container shape = (2, 5, 6)
/// indices shape = (2, 2, 6)
/// updates shape = (2, 2, 6)
/// axis = -2
/// output shape = (2, 5, 6)
public struct ScatterAlongAxisLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  /// mode of accumulation.
  public var mode: ScatterMode = .scatterUpdate

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that stacks the input tensors along the given axis.
/// It is similar in functionality to the numpy.stack method.
///
/// Requires at least 2 inputs and produces 1 output.
/// All inputs must have the same shape.
/// Rank of the output is 1 greater than the rank of the inputs.
///
/// Negative indexing is supported for the "axis" parameter.
///
/// e.g.:
///
/// input shape = (2, 4, 2)
/// number of inputs = 5
/// axis = 3
/// output shape = (2, 4, 2, 5)
///
/// input shape = (2, 4, 2)
/// number of inputs = 5
/// axis = -2
/// output shape = (2, 4, 5, 2)
public struct StackLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that reshapes a tensor that does not alter the rank of the input.
/// Order of the data is left unchanged.
///
/// Requires 1 input and produces 1 output.
///
/// e.g:
///
/// input shape = (20,10)
/// targetShape = (5,-1)
/// output shape = (5,40)
///
/// input shape = (20,10,5)
/// targetShape = (0,2,25)
/// output shape = (20,2,25)
///
/// input shape = (10,3,5)
/// targetShape = (25,0,-1)
/// output shape = (25,3,2)
public struct RankPreservingReshapeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Length of this field must be same as the input/output rank.
  /// It can have 0's, in which case the corresponding input dimension is kept intact.
  /// At most one element can be -1, in which case the output dimension is calculated from rest of the shape.
  public var targetShape: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Constant padding layer.
/// Pad the input array with a constant value, either along a single given axis or along a set of axes.
///
/// Requires 1 or 2 inputs and produces 1 output.
/// The amount of padding can be either set as a parameter ("padAmounts") or provided as a second input.
///
/// Output rank is same as the rank of the first input.
///
/// when "padToGivenOutputSizeMode" is False:
///
/// output_shape[i] = input_shape[i] + padAmounts[2*i] + padAmounts[2*i+1], i=0,...,rank-1
///
/// Examples:
///
/// input shape = (20,10)
/// padAmounts = [0,1,4,0]
/// output shape = (21,14)
///
/// input shape = (20,10,5)
/// padAmounts = [0,0,3,4,0,9]
/// output shape = (20,17,14)
///
///
/// when "padToGivenOutputSizeMode" is True
///
/// output_shape[i] = max(input_shape[i], max(padAmounts[2*i] + padAmounts[2*i+1])), i=0,...,rank-1
///
/// input shape = (20,10)
/// padAmounts = [0,21,14,0]
/// output shape = (21,14)
///
/// input shape = (20,10,5)
/// padAmounts = [0,0,17,0,0,14]
/// output shape = (20,17,14)
public struct ConstantPaddingLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The value to be used for padding.
  public var value: Float = 0

  ///
  /// Length of this repeated field must be twice the rank of the first input.
  /// 2*i-th and (2*i+1)-th values represent the amount of padding to be applied to the the i-th input
  /// dimension, "before" and "after" the input values, respectively.
  public var padAmounts: [UInt64] = []

  ///
  /// When this is True, positive values in "padAmounts" are equivalent to the output shape.
  /// In that case only one of padAmounts[2*i] and padAmounts[2*i+1] can be non zero, for i=0,..,rank-1.
  public var padToGivenOutputSizeMode: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the normal distribution.
///
/// Requires 1 input and produces 1 output.
///
/// Parameters
///     seed: seed used for the normal distribution.
///     mean: mean of the normal distribution.
///     stdDev: standard deviation of the normal distribution.
///
/// Input
///     An N-Dimensional tensor, whose values are ignored. Only the shape is used to
///     infer the shape of the output.
///
/// Output
///     An N-Dimensional tensor with the same shape as the input tensor.
public struct RandomNormalLikeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var mean: Float = 0

  public var stdDev: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the normal distribution.
///
/// Requires no input and produces 1 output.
///
/// Parameters
///     seed: seed used for the normal distribution.
///     mean: mean of the normal distribution.
///     stdDev: standard deviation of the normal distribution.
///     outputShape: shape of the output tensor.
///
/// Output
///     An N-Dimensional tensor of shape "outputShape".
public struct RandomNormalStaticLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var mean: Float = 0

  public var stdDev: Float = 0

  public var outputShape: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the normal distribution.
///
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///     seed: seed used for the normal distribution.
///     mean: mean of the normal distribution.
///     stdDev: standard deviation of the normal distribution.
///
/// Input
///     A rank 1 tensor specifying the shape of the output
///
/// Output
///     An N-Dimensional tensor with the shape specified by the values in the input tensor.
public struct RandomNormalDynamicLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var mean: Float = 0

  public var stdDev: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the uniform distribution.
///
/// Requires 1 input and produces 1 output.
///
/// Parameters
///     seed: seed used for the uniform distribution.
///     minVal: lower bound on the range of random values for the uniform distribution.
///     maxVal: upper bound on the range of random values for the uniform distribution.
///
/// Input
///     An N-Dimensional tensor, whose values are ignored. Only the shape is used to
///     infer the shape of the output.
///
/// Output
///     An N-Dimensional tensor with the same shape as the input tensor.
public struct RandomUniformLikeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var minVal: Float = 0

  public var maxVal: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the uniform distribution.
///
/// Requires no input and produces 1 output.
///
/// Parameters
///     seed: seed used for the uniform distribution.
///     minVal: lower bound on the range of random values for the uniform distribution.
///     maxVal: upper bound on the range of random values for the uniform distribution.
///     outputShape: shape of the output tensor.
///
/// Output
///     An N-Dimensional tensor of shape "outputShape".
public struct RandomUniformStaticLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var minVal: Float = 0

  public var maxVal: Float = 0

  public var outputShape: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the uniform distribution.
///
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///     seed: seed used for the uniform distribution.
///     minVal: lower bound on the range of random values for the uniform distribution.
///     maxVal: upper bound on the range of random values for the uniform distribution.
///
/// Input
///     A rank 1 tensor specifying the shape of the output
///
/// Output
///     An N-Dimensional tensor with the shape specified by the values in the input tensor.
public struct RandomUniformDynamicLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var minVal: Float = 0

  public var maxVal: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the Bernoulli distribution.
///
/// Requires 1 input and produces 1 output.
///
/// Parameters
///     seed: seed used for the Bernoulli distribution.
///     prob: probability of a 1 event.
///
/// Input
///     An N-Dimensional tensor, whose values are ignored. Only the shape is used to
///     infer the shape of the output.
///
/// Output
///     An N-Dimensional tensor with the same shape as the input tensor.
public struct RandomBernoulliLikeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var prob: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the Bernoulli distribution.
///
/// Requires no input and produces 1 output.
///
/// Parameters
///     seed: seed used for the Bernoulli distribution.
///     prob: probability of a 1 event.
///     outputShape: shape of the output tensor.
///
/// Output
///     An N-Dimensional tensor of shape "outputShape".
public struct RandomBernoulliStaticLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var prob: Float = 0

  public var outputShape: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor filled with values from the Bernoulli distribution.
///
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///     seed: seed used for the Bernoulli distribution.
///     prob: probability of a 1 event.
///
/// Input
///     A rank 1 tensor specifying the shape of the output
///
/// Output
///     An N-Dimensional tensor with the shape specified by the values in the input tensor.
public struct RandomBernoulliDynamicLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var prob: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor of the specified shape filled with values from the categorical distribution.
///
/// Requires 1 input and produces 1 output.
///
/// Parameter:
///     seed: seed used for the categorical distribution.
///     numSamples: number of samples to draw.
///     isLogits: true if the inputs are logits, false if the inputs are probabilities.
///     eps: default value is 1e-10.
///     temperature: default value is 1.0.
///
/// Input tensor shape = [D_1, D_2, ... , D_(R-1), D_R] (Rank = R)
/// Then the shape of the output is [D_1, D_2, ... , D_(R-1), numSamples] (Rank = R)
public struct CategoricalDistributionLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: Int64 = 0

  public var numSamples: Int64 = 0

  public var isLogits: Bool = false

  public var eps: Float = 0

  public var temperature: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with L1 normalization operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceL1LayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with L2 normalization operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceL2LayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with max operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceMaxLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with min operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceMinLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with sum operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceSumLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with prod operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceProdLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with mean operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceMeanLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with logSum operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceLogSumLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with logSumExp operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceSumSquareLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs reduction with logSumExp operation.
///
/// Negative indexing is supported.
/// Requires 1 input and produces 1 output.
///
/// Parameters:
///    axes: dimensions along which to perform reduction
///    keepDims: if True, keep the reduced dimensions (value will be 1), otherwise, reduced dimensions are squeezed
///    reduceAll: ignore the "axes" parameter, perform reduction along all axes
public struct ReduceLogSumExpLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axes: [Int64] = []

  public var keepDims: Bool = false

  public var reduceAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that increases the rank of the input tensor by adding unit dimensions.
///
/// Requires 1 input and produces 1 output.
///
/// e.g.:
///
/// input shape = (10,5)
/// axes = (0,1)
/// output shape = (1,1,10,5)
///
/// input shape = (10,5)
/// axes = (0,2)
/// output shape = (1,10,1,5)
///
/// input shape = (10,5)
/// axes = (-2,-1)
/// output shape = (10,5,1,1)
public struct ExpandDimsLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Axis values provided here get dimension 1 in the output tensor.
  /// Negative indexing is supported.
  public var axes: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that flattens the input tensor into a 2-dimensional matrix.
///
/// Requires 1 input and produces 1 output.
/// Output tensor is always rank 2.
///
/// First dimension of output is the product of all the dimensions in input[:axis] ("axis" is exclusive)
/// Second dimension of output is the product of all the dimensions in input[axis:] ("axis" is inclusive)
///
/// e.g.:
/// input shape:  (3,)
/// axis:  -1
/// output shape:  (1, 3)
///
/// input shape:  (3,)
/// axis:  1
/// output shape:  (3, 1)
///
/// input shape:  (4, 3)
/// axis:  -1
/// output shape:  (4, 3)
///
/// input shape:  (5, 2)
/// axis:  0
/// output shape:  (1, 10)
///
/// input shape:  (5, 5, 3)
/// axis:  -2
/// output shape:  (5, 15)
///
/// input shape:  (2, 3, 2)
/// axis:  -1
/// output shape:  (6, 2)
public struct FlattenTo2DLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that reshapes a tensor.
///
/// Requires 1 input and produces 1 output.
///
/// Output tensor is the reshaped version of the input and has shape as specified in the
/// parameter "targetShape".
public struct ReshapeStaticLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetShape: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that reshapes a tensor.
///
/// Requires 2 inputs and produces 1 output.
///
/// First input is reshaped to produce the output, while the second input is only
/// used to determine the shape of the output. Values of the second input are not used.
///
/// Output is a tensor with the same shape as the second input.
public struct ReshapeLikeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that reshapes a tensor.
///
/// Requires 2 inputs and produces 1 output.
///
/// First input is the one that is reshaped to produce the output.
/// Second input is a rank 1 tensor specifying the shape of the output.
/// Output tensor has shape as specified by the values in the 2nd input tensor.
public struct ReshapeDynamicLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that decreases the rank of the input tensor by removing unit dimensions.
///
/// Requires 1 input and produces 1 output.
///
/// Output rank is one less than input rank, if input rank is more than 1.
/// If input rank is 1, output rank is also 1.
///
/// e.g.:
///
/// input shape = (1,1,10,5)
/// axes = (0,1)
/// output shape = (10,5)
///
/// input shape = (1,10,5,1)
/// axes = (0,3)
/// output shape = (10,5)
///
/// input shape = (10,5,1,1)
/// axes = (-2,-1)
/// output shape = (10,5)
///
/// input shape = (1,)
/// axes = (0)
/// output shape = (1,)
public struct SqueezeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Axis values provided here get removed from the input tensor.
  /// Negative indexing is supported.
  public var axes: [Int64] = []

  /// if true squeeze all dimensions that are 1.
  public var squeezeAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns top K (or bottom K) values and the corresponding indices
/// of the input along a given axis.
///
/// Requires 1 or 2 inputs and produces 2 outputs.
///
/// The second input is the value of the K, and is optional.
/// If there is only one input, value of K that is specified in the layer parameter is used.
///
/// Both outputs have the same rank as the first input.
/// Second input must correspond to a scalar tensor.
///
/// e.g.:
///
/// first input's shape = (45, 34, 10, 5)
/// axis = 1
/// output shape, for both outputs = (45, K, 10, 5)
public struct TopKLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///  negative indexing is supported
  public var axis: Int64 = 0

  /// is ignored if a second input is present.
  public var k: UInt64 = 0

  /// if true, bottom K (values, indices) are returned instead
  public var useBottomK: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns the indices of the maximum value along a specified axis in a tensor.
///
/// Requires 1 input and produces 1 output. Negative indexing is supported.
///
/// Output has the same rank as the input if "removeDim" is False (default).
/// Output has rank one less than the input if "removeDim" is True and input rank is more than 1.
///
/// e.g.:
///
/// input shape = (45, 34, 10, 5)
/// axis = -2
/// output shape = (45, 1, 10, 5), if removeDim = False (default)
/// output shape = (45, 10, 5), if removeDim = True
///
/// input shape = (5,)
/// axis = 0
/// output shape = (1,), if removeDim = False or True
public struct ArgMaxLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  public var removeDim: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns the indices of the minimum value along a specified axis in a tensor.
///
/// Requires 1 input and produces 1 output. Negative indexing is supported.
///
/// Output has the same rank as the input if "removeDim" is False (default).
/// Output has rank one less than the input if "removeDim" is True and input rank is more than 1.
///
/// e.g.:
///
/// input shape = (45, 34, 10, 5)
/// axis = -2
/// output shape = (45, 1, 10, 5), if removeDim = False (default)
/// output shape = (45, 10, 5), if removeDim = True
///
/// input shape = (5,)
/// axis = 0
/// output shape = (1,), if removeDim = False or True
public struct ArgMinLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  public var removeDim: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer layer that splits the input tensor into multiple output tensors,
/// along the specified axis.
///
/// The layer either uniformly splits the input tensor into ``num_splits`` tensors, or
/// splits according to the given split sizes in ``split_sizes``.
/// Supports unequal splits and negative indexing.
///
/// Requires 1 input and produces at least 2 outputs.
/// Rank of all the outputs is same as that of the input.
///
/// If parameter "splitSizes" is provided, value of the parameter "numSplits" is ignored, since in that case
/// "numSplits" is automatically inferred to be the length of "splitSizes".
///
///
/// e.g.:
/// input shape:  (5, 3, 4)
/// axis = -3, split_sizes = [3, 2]
/// output shape:  (3, 3, 4)
/// output shape:  (2, 3, 4)
public struct SplitNDLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  public var numSplits: UInt64 = 0

  public var splitSizes: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise ceil operation on the input tensor that
/// rounds the value to the smallest integer not less than x.
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct CeilLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise round operation on the input tensor
/// that rounds the value to the nearest integer.
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct RoundLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise floor operation on the input tensor
/// that rounds the value to the largest integer not greater than x.
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct FloorLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise sign operation (+1 for positive values,
/// -1 for negative values, 0 for zeros).
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct SignLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise clip operation. Clip the values in the
/// input tensor to the threshold values [min_value, max_value].
///
/// Requires 1 input and produces 1 output.
///
/// Parameter minVal: the minimum threshold.
/// Parameter maxVal: the maximum threshold.
///
/// output =  min(max(input, minVal), maxVal)
///
/// Output shape is same as the input.
public struct ClipLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var minVal: Float = 0

  public var maxVal: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that extracts a slice of size ``(end - begin) / stride``
/// from the given input tensor.
/// Support negative indexing and negative strides.
///
/// Requires 1 input and produces 1 output.
/// Output rank is same as the input rank.
///
/// Value of beginIds, beginMasks, endIds, endMasks, strides are required parameters.
/// Lengths of all the parameters must equal the rank of the input.
///
/// i-th element of "beginIds" is ignored and assumed to be 0 if the i-th element of
/// "beginMasks" is True
///
/// i-th element of "endIds" is ignored and assumed to be -1 if the i-th element of
/// "endMasks" is True
///
/// e.g.:
/// if i-th element of "squeezeMasks" is set to True, only beginIds[i] would be sliced
/// out, and all other masks and inputs are ignored.
///
/// e.g. (without squeezeMasks):
/// input shape:  (5, 5, 5)
/// beginIds:  [1, 2, 3]
/// beginMasks:  [True, False, True]
/// endIds:  [3, -3, 2]
/// endMasks:  [False, True, True]
/// strides:  [2, 2, 2]
/// SqueezeMasks:  [False, False, False]
/// output shape:  (2, 2, 3)
/// This is equivalent to input[:3:2, 2::2, ::2]
///
/// e.g. (with squeezeMasks):
/// input shape:  (5, 5, 5)
/// beginIds:  [1, 2, 3]
/// beginMasks:  [True, False, True]
/// endIds:  [3, -3, 2]
/// endMasks:  [False, True, True]
/// strides:  [2, 2, 2]
/// SqueezeMasks:  [False, True, False]
/// output shape:  (2, 3)
/// This is equivalent to input[:3:2, 2, ::2]
public struct SliceStaticLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beginIds: [Int64] = []

  public var beginMasks: [Bool] = []

  public var endIds: [Int64] = []

  public var endMasks: [Bool] = []

  public var strides: [Int64] = []

  public var squeezeMasks: [Bool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that extracts a slice of size ``(end - begin) / stride``
/// from the given input tensor.
/// Support negative indexing and negative strides.
/// See "SliceStaticLayerParams" for the description and an example of the functionality of the layer.
///
/// Requires 2 to 7 inputs and produces 1 output.
/// Rank of the output is same as the rank of the first input unless squeezeMask is set.
///
/// Value of beginIds, beginMasks, endIds, endMasks, strides can be passed in either
/// as dynamic inputs or as static parameters.
/// Lengths of all the parameters or inputs from 2-6 must equal the rank of the first input.
///
/// The 2nd input represents the "beginIds".
/// The 3rd input, if present, corresponds to "endIds". In this case the value of the "endIds" parameter is ignored.
/// The 4th input, if present, corresponds to "strides". In this case the value of the "strides" parameter is ignored.
/// The 5th input, if present, corresponds to "beginMasks". In this case the value of the "beginMasks" parameter is ignored.
/// The 6th input, if present, corresponds to "endMasks". In this case the value of the "endMasks" parameter is ignored.
/// The 7th input, if present, corresponds to "squeezeMasks". In this case the value of the "squeezeMasks" parameter is ignored.
public struct SliceDynamicLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beginMasks: [Bool] = []

  public var endIds: [Int64] = []

  public var endMasks: [Bool] = []

  public var strides: [Int64] = []

  public var squeezeMasks: [Bool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that constructs a tensor by repeating the input tensor multiple
/// number of times.
///
/// Requires 1 or 2 inputs and produces 1 output.
/// Output rank is same as the input rank.
///
/// If two inputs are provided, second input is used as "reps"
/// and "reps" parameter is ignored.
///
/// If only one input is provided,
/// length of the "reps" parameter must be at least 1 and
/// not greater than the rank of the input.
/// If it is less than the input rank, it is made equal to the input rank by prepending 1's to it.
///
/// e.g.:
///
/// input shape = (2, 4, 2)
/// reps = (1, 2, 6)
/// output shape = (2, 8, 12)
///
/// input shape = (2, 4, 2)
/// reps = (6)
/// reps after prepending ones = (1, 1, 6)
/// output shape = (2, 4, 12)
///
/// input shape = (2, 4, 2)
/// second input = [1, 2, 6] -> shape: (3,)
/// reps = N/A [Ignored]
/// output shape = (2, 8, 12)
public struct TileLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reps: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns the shape of an input tensor.
///
/// Requires 1 input and produces 1 output.
///
/// Input: a tensor.
/// Output: a vector of length R, where R is the rank of the input tensor
/// Output is always a rank 1 tensor.
public struct GetShapeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that computes the Gauss error function,
/// which is defined as:
///
/// .. math::
///     f(x) = \dfrac{1}{\sqrt{\pi}}\int_{-x}^{x}{e^{-t^2}dt}
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct ErfLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that evaluates the Gaussian Error Linear Unit (GELU) activation.
/// Following equations are used to compute the activation based on the value of the "mode" parameter:
///
/// mode == 'EXACT':
/// .. math::
///     f(x) = 0.5x\left ( 1+\rm{erf}\left ( \frac{x}{\sqrt{2}} \right ) \right )
///
/// mode == 'TANH_APPROXIMATION':
/// .. math::
///     f(x) = 0.5x\left ( 1+\rm{tanh}\left ( \sqrt{2/\pi}\left ( x + 0.044715x^3 \right ) \right ) \right )
///
/// mode == 'SIGMOID_APPROXIMATION':
/// .. math::
///     f(x) = x*\rm{sigmoid}(1.702x)
///
/// Requires 1 input and produces 1 output.
/// Output shape is same as the input.
public struct GeluLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// mode of GELU operation.
  public var mode: GeluLayerParams.GeluMode = .exact

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum GeluMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case exact // = 0
    case tanhApproximation // = 1
    case sigmoidApproximation // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .exact
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .exact
      case 1: self = .tanhApproximation
      case 2: self = .sigmoidApproximation
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .exact: return 0
      case .tanhApproximation: return 1
      case .sigmoidApproximation: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension GeluLayerParams.GeluMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [GeluLayerParams.GeluMode] = [
    .exact,
    .tanhApproximation,
    .sigmoidApproximation,
  ]
}

#endif  // swift(>=4.2)

///
/// RangeStatic layer that returns a tensor that contains evenly spaced values.
/// It is similar in functionality to the numpy.arange method.
///
/// Requires no input and produces 1 output.
/// Output is a rank 1 tensor.
public struct RangeStaticLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var endValue: Float = 0

  public var startValue: Float = 0

  public var stepSizeValue: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor that contains evenly spaced values.
/// Its functionality is similar to the numpy.arange method.
///
/// Requires at least 1 input, up to a maximum of 3 inputs.
/// Produces 1 output, which is a rank 1 tensor.
///
/// Each input must be a scalar, or rank 1 and shape (1,).
///
/// The first input represents the "endValue".
/// The second input, if present, corresponds to "startValue". In this case the value of the "startValue" parameter is ignored.
/// The third input, if present, corresponds to "stepSizeValue". In this case the value of the "stepSizeValue" parameter is ignored.
public struct RangeDynamicLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startValue: Float = 0

  public var stepSizeValue: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns a tensor containing all windows of size ``windowSize``
/// separated by ``step`` along the dimension ``axis``.
///
/// .. code::
///
///      y = SlidingWindows(x)
///
/// Requires 1 input and produces 1 output.
///
/// Input
///     An N-Dimensional tensor.
///
/// Output
///     An (N+1)-Dimensional tensor.
///
/// This operation behaves as following:
///      - if axis = 0 & input is rank 1 (L,). Output shape will be (M, W).
///      - if axis = 1 & input is rank 3 (B1, L, C1). Output shape will be (B1, M, W, C1)
///      - if axis = 2 & input is rank 5 (B1, B2, L, C1, C2) --> (B1 * B2, L, C1 * C2) --> (B1 * B2, M, W, C1 * C2). Output shape will be (B1, B2, M, W, C1, C2)
///      - etc.
/// where
///      - L, C, B refer to input length, feature dimension length & batch size respectively
///      - W is the window size.
///      - M is the number of windows/slices calculated as M = (L - W) / step + 1
public struct SlidingWindowsLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: Int64 = 0

  public var windowSize: UInt64 = 0

  public var step: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that applies layer normalization over the input tensor.
///
/// Requires 1 input and produces 1 output.
///
/// output = gamma * (input - computed_mean) / (sqrt(computed_variance + eps)) + beta
///
/// Parameters
///     normalizedShape: subset of the input shape, along with layer norm is performed, rest of the input shape is treated as the batch dimension. The mean and variance are computed for the input, over the last few dimensions as specified by the normalizedShape parameter.
///     gamma: must have shape = "normalizedShape"
///     beta: must have shape = "normalizedShape"
///     eps: small constant to avoid division by 0
///
/// Output shape is same as the input.
///
/// e.g.:
/// input shape = (10,5)
/// normalized shape = (5,) or (10,5)
///
/// input shape = (10,5,6,7)
/// normalized shape = (7,) or (6,7) or (5,6,7) or (10,5,6,7)
public struct LayerNormalizationLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var normalizedShape: [Int64] {
    get {return _storage._normalizedShape}
    set {_uniqueStorage()._normalizedShape = newValue}
  }

  public var eps: Float {
    get {return _storage._eps}
    set {_uniqueStorage()._eps = newValue}
  }

  public var gamma: WeightParams {
    get {return _storage._gamma ?? WeightParams()}
    set {_uniqueStorage()._gamma = newValue}
  }
  /// Returns true if `gamma` has been explicitly set.
  public var hasGamma: Bool {return _storage._gamma != nil}
  /// Clears the value of `gamma`. Subsequent reads from it will return its default value.
  public mutating func clearGamma() {_uniqueStorage()._gamma = nil}

  public var beta: WeightParams {
    get {return _storage._beta ?? WeightParams()}
    set {_uniqueStorage()._beta = newValue}
  }
  /// Returns true if `beta` has been explicitly set.
  public var hasBeta: Bool {return _storage._beta != nil}
  /// Clears the value of `beta`. Subsequent reads from it will return its default value.
  public mutating func clearBeta() {_uniqueStorage()._beta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Non maximum suppression (NMS) layer.
/// Applies the non maximum suppression algorithm to input bounding box coordinates.
/// The effect of this layer is similar to the functionality of the "NonMaximumSuppression"
/// model type (for details please see NonMaximumSuppression.proto) with a couple of differences.
/// One, this is a layer in a neural network model, whereas that is a different model type. Second,
/// this layer supports a batch of bounding boxes.
///
/// The NMS layer requires at least 2 inputs, and up to a maximum of 5 inputs. It produces 4 outputs.
/// Following is the description of inputs and outputs:
///
/// input 1, shape (B,N,4): coordinates of N boxes, for a batch size B.
/// input 2, shape (B,N,C): class scores for each box. C can be 1 when there is only 1 score per box, i.e., no class specific score.
///
/// input 3, optional, shape (1,): IoU threshold. When present, it overwrites the value provided in layer parameter "iouThreshold".
/// input 4, optional, shape (1,): Score threshold. When present, it overwrites the value provided in layer parameter "scoreThreshold".
/// input 5, optional, shape (1,): Maximum number of boxes. When present, it overwrites the value provided in layer parameter "maxBoxes".
///
/// output 1, shape (B,maxBoxes,4): box coordinates, corresponding to the surviving boxes.
/// output 2, shape (B,maxBoxes,C): box scores, corresponding to the surviving boxes.
/// output 3, shape (B,maxBoxes): indices of the surviving boxes. Hence it will have values in the range [0,N-1], except for padding.
/// output 4, shape (B,): number of boxes selected after the NMS algorithm, for each batch.
///
/// When surviving boxes are less than "maxBoxes", the first 3 outputs are padded.
/// For the first two outputs, the padding is done using values 0, whereas for the third output the
/// padding value used is -1, since the output values represent indices.
///
/// If no box survives, that is, all the scores are below the "scoreThreshold",
/// then for that batch, number of boxes (value of the fourth output) will be 1. The first 3 outputs will
/// correspond to the box with the highest score. This is to avoid generating an "empty" output.
///
/// The four values that describe the box dimensions are (in order):
///
///  - x (center location of the box along the horizontal axis)
///  - y (center location of the box along the vertical axis)
///  - width (size of box along the horizontal axis)
///  - height (size of box on along the vertical axis)
///
/// In each batch,
/// the N scores for N boxes, used for suppression, are generated by taking the max of the matrix (N,C)
/// along the columns.
/// If "perClassSuppression" flag is false, suppression happens across all classes.
/// If "perClassSuppression" flag is true, each box is assigned to the class with the highest
/// score and then the suppression happens separately for boxes within the same class.
///
/// Note that the 4th output can be used to dynamically slice the first 3 outputs, in case
/// the padded outputs are not required.
public struct NonMaximumSuppressionLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The intersection over union (IoU) threshold over which boxes are suppressed.
  public var iouThreshold: Float = 0

  ///
  /// Before IoU suppression is performed, boxes with class scores below this threshold are rejected.
  public var scoreThreshold: Float = 0

  ///
  /// The maximum number of boxes to be given out as output.
  /// If the number of surviving boxes are less, output is padded up to this number.
  public var maxBoxes: UInt64 = 0

  ///
  /// If true, suppression is performed independently within boxes of each class.
  public var perClassSuppression: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that performs element-wise clamped ReLU operation.
///
/// Requires 1 input and produces 1 output.
///
/// This function has the following formula:
///
/// .. math::
///     f(x) = \begin{cases}
///               \text{min}(\text{beta},x) \;\; \text{if} \;\; x \geq 0\\
///               \text{min}(\text{beta} ,\text{alpha}\cdot x) \;\; \text{if} \;\; x<0
///            \end{cases}
///
/// Output shape is same as the input.
///
/// Available (iOS >= 14, macOS >= 11.0, watchOS >= 7)
public struct ClampedReLULayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alpha: Float = 0

  public var beta: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that returns the indices that would sort the input tensor, along a specified axis.
///
/// Requires 1 input and produces 1 output.
///
/// Output has the same rank and shape as the input.
///
/// Value of "axis" must be positive and less than the rank of the input.
///
/// e.g.:
///
/// input shape = (5,)
/// axis = 0
/// input values = [3.1, 5.4, 32.9, 3.2, 77.0]
/// output shape = (5,)
/// output values = [0, 3, 1, 2, 4], descending = False
/// output values = [4, 2, 1, 3, 0], descending = True
///
/// input shape = (2,3)
/// axis = 1
/// input values = [[3, 5, 32], [3, 77, 6]]
/// output shape = (2,3)
/// output values = [[0, 1, 2], [0, 2, 1]], descending = False
/// output values = [[2, 1, 0], [1, 2, 0]], descending = True
public struct ArgSortLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// must be between [0, input_rank - 1]
  public var axis: Int64 = 0

  public var descending: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A layer that does slice operation by providing size to be extracted
/// from the given input tensor.
///
/// Requires 2 inputs and produces 1 output.
/// Rank of the output is same as the rank of the first input.
///
/// The 1st input represents the tensor to be sliced.
/// The 2nd input represents the beginning index to be sliced from.
///
/// Example:
/// Input 1: x (x.shape = (2, 3, 4))
/// Input 2: begin
/// size: 2
/// axis: 1
///
/// Output: x[:, begin:begin+2, :]
public struct SliceBySizeLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var size: Int64 = 0

  public var axis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A neural network specialized as a classifier.
public struct NeuralNetworkClassifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var layers: [NeuralNetworkLayer] = []

  public var preprocessing: [NeuralNetworkPreprocessing] = []

  /// use this enum value to determine the input tensor shapes to the neural network, for multiarray inputs
  public var arrayInputShapeMapping: NeuralNetworkMultiArrayShapeMapping = .rank5ArrayMapping

  /// use this enum value to determine the input tensor shapes to the neural network, for image inputs
  public var imageInputShapeMapping: NeuralNetworkImageShapeMapping = .rank5ImageMapping

  public var updateParams: NetworkUpdateParameters {
    get {return _updateParams ?? NetworkUpdateParameters()}
    set {_updateParams = newValue}
  }
  /// Returns true if `updateParams` has been explicitly set.
  public var hasUpdateParams: Bool {return self._updateParams != nil}
  /// Clears the value of `updateParams`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateParams() {self._updateParams = nil}

  /// The set of labels for every possible class.
  public var classLabels: NeuralNetworkClassifier.OneOf_ClassLabels? = nil

  public var stringClassLabels: StringVector {
    get {
      if case .stringClassLabels(let v)? = classLabels {return v}
      return StringVector()
    }
    set {classLabels = .stringClassLabels(newValue)}
  }

  public var int64ClassLabels: Int64Vector {
    get {
      if case .int64ClassLabels(let v)? = classLabels {return v}
      return Int64Vector()
    }
    set {classLabels = .int64ClassLabels(newValue)}
  }

  /// The name of the output blob containing the probability of each class.
  /// In other words, the score vector. Must be a 1-D tensor with the same
  /// number and order of elements as ClassLabels.
  public var labelProbabilityLayerName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The set of labels for every possible class.
  public enum OneOf_ClassLabels: Equatable {
    case stringClassLabels(StringVector)
    case int64ClassLabels(Int64Vector)

  #if !swift(>=4.1)
    public static func ==(lhs: NeuralNetworkClassifier.OneOf_ClassLabels, rhs: NeuralNetworkClassifier.OneOf_ClassLabels) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stringClassLabels, .stringClassLabels): return {
        guard case .stringClassLabels(let l) = lhs, case .stringClassLabels(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int64ClassLabels, .int64ClassLabels): return {
        guard case .int64ClassLabels(let l) = lhs, case .int64ClassLabels(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _updateParams: NetworkUpdateParameters? = nil
}

public struct OneHotLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// size of the one hot vector
  public var oneHotVectorSize: UInt64 = 0

  ///  negative indexing is supported. It refers to the axis in the output tensor.
  public var axis: Int64 = 0

  public var onValue: Float = 0

  public var offValue: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CumSumLayerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///  negative indexing is supported
  public var axis: Int64 = 0

  /// if true, the first element of the output is 0, and the last element contains the sum of the input up to the penultimate value
  /// if false, the first element of the output is same as the input and the last element is the sum of all the input values
  /// (this behavior is reversed when "reverse" flag is True)
  public var excludeFinalSum: Bool = false

  /// if true, cumsum is performed in the opposite direction
  public var reverse: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A neural network specialized as a regressor.
public struct NeuralNetworkRegressor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var layers: [NeuralNetworkLayer] = []

  public var preprocessing: [NeuralNetworkPreprocessing] = []

  /// use this enum value to determine the input tensor shapes to the neural network, for multiarray inputs
  public var arrayInputShapeMapping: NeuralNetworkMultiArrayShapeMapping = .rank5ArrayMapping

  /// use this enum value to determine the input tensor shapes to the neural network, for image inputs
  public var imageInputShapeMapping: NeuralNetworkImageShapeMapping = .rank5ImageMapping

  public var updateParams: NetworkUpdateParameters {
    get {return _updateParams ?? NetworkUpdateParameters()}
    set {_updateParams = newValue}
  }
  /// Returns true if `updateParams` has been explicitly set.
  public var hasUpdateParams: Bool {return self._updateParams != nil}
  /// Clears the value of `updateParams`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateParams() {self._updateParams = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateParams: NetworkUpdateParameters? = nil
}

///
/// Details on how the network will be updated
public struct NetworkUpdateParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lossLayers: [LossLayer] {
    get {return _storage._lossLayers}
    set {_uniqueStorage()._lossLayers = newValue}
  }

  public var optimizer: Optimizer {
    get {return _storage._optimizer ?? Optimizer()}
    set {_uniqueStorage()._optimizer = newValue}
  }
  /// Returns true if `optimizer` has been explicitly set.
  public var hasOptimizer: Bool {return _storage._optimizer != nil}
  /// Clears the value of `optimizer`. Subsequent reads from it will return its default value.
  public mutating func clearOptimizer() {_uniqueStorage()._optimizer = nil}

  public var epochs: Int64Parameter {
    get {return _storage._epochs ?? Int64Parameter()}
    set {_uniqueStorage()._epochs = newValue}
  }
  /// Returns true if `epochs` has been explicitly set.
  public var hasEpochs: Bool {return _storage._epochs != nil}
  /// Clears the value of `epochs`. Subsequent reads from it will return its default value.
  public mutating func clearEpochs() {_uniqueStorage()._epochs = nil}

  ///
  /// Describes whether to shuffle the batch of data between epochs.
  public var shuffle: BoolParameter {
    get {return _storage._shuffle ?? BoolParameter()}
    set {_uniqueStorage()._shuffle = newValue}
  }
  /// Returns true if `shuffle` has been explicitly set.
  public var hasShuffle: Bool {return _storage._shuffle != nil}
  /// Clears the value of `shuffle`. Subsequent reads from it will return its default value.
  public mutating func clearShuffle() {_uniqueStorage()._shuffle = nil}

  ///
  /// The seed to be used in an associated random number generator.
  public var seed: Int64Parameter {
    get {return _storage._seed ?? Int64Parameter()}
    set {_uniqueStorage()._seed = newValue}
  }
  /// Returns true if `seed` has been explicitly set.
  public var hasSeed: Bool {return _storage._seed != nil}
  /// Clears the value of `seed`. Subsequent reads from it will return its default value.
  public mutating func clearSeed() {_uniqueStorage()._seed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Loss layer - categorical cross entropy and mean squared error are the only supported loss functions currently
public struct LossLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var lossLayerType: LossLayer.OneOf_LossLayerType? = nil

  public var categoricalCrossEntropyLossLayer: CategoricalCrossEntropyLossLayer {
    get {
      if case .categoricalCrossEntropyLossLayer(let v)? = lossLayerType {return v}
      return CategoricalCrossEntropyLossLayer()
    }
    set {lossLayerType = .categoricalCrossEntropyLossLayer(newValue)}
  }

  public var meanSquaredErrorLossLayer: MeanSquaredErrorLossLayer {
    get {
      if case .meanSquaredErrorLossLayer(let v)? = lossLayerType {return v}
      return MeanSquaredErrorLossLayer()
    }
    set {lossLayerType = .meanSquaredErrorLossLayer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_LossLayerType: Equatable {
    case categoricalCrossEntropyLossLayer(CategoricalCrossEntropyLossLayer)
    case meanSquaredErrorLossLayer(MeanSquaredErrorLossLayer)

  #if !swift(>=4.1)
    public static func ==(lhs: LossLayer.OneOf_LossLayerType, rhs: LossLayer.OneOf_LossLayerType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.categoricalCrossEntropyLossLayer, .categoricalCrossEntropyLossLayer): return {
        guard case .categoricalCrossEntropyLossLayer(let l) = lhs, case .categoricalCrossEntropyLossLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.meanSquaredErrorLossLayer, .meanSquaredErrorLossLayer): return {
        guard case .meanSquaredErrorLossLayer(let l) = lhs, case .meanSquaredErrorLossLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///
/// Categorical cross entropy loss layer
/// Categorical cross entropy is used for single label categorization (only one category is applicable for each data point).
///
/// The input is a vector of length N representing the distribution over N categories.  It must be the output of a softmax.
///
/// The target is a single value representing the true category or class label. If the target is the predictedFeatureName of a neural network classifier it will be inverse mapped to the corresponding categorical index for you.
///
/// math:
/// Loss_{CCE}(input, target) = -\sum_{i=1}^{N} (target == i) log( input[i] ) = - log (input[target])
public struct CategoricalCrossEntropyLossLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: String = String()

  public var target: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Mean squared error loss layer,
/// specifying input and target
public struct MeanSquaredErrorLossLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: String = String()

  public var target: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Optimizer - stochastic gradient descent and adam are the only supported optimizers currently
public struct Optimizer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var optimizerType: Optimizer.OneOf_OptimizerType? = nil

  public var sgdOptimizer: SGDOptimizer {
    get {
      if case .sgdOptimizer(let v)? = optimizerType {return v}
      return SGDOptimizer()
    }
    set {optimizerType = .sgdOptimizer(newValue)}
  }

  public var adamOptimizer: AdamOptimizer {
    get {
      if case .adamOptimizer(let v)? = optimizerType {return v}
      return AdamOptimizer()
    }
    set {optimizerType = .adamOptimizer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_OptimizerType: Equatable {
    case sgdOptimizer(SGDOptimizer)
    case adamOptimizer(AdamOptimizer)

  #if !swift(>=4.1)
    public static func ==(lhs: Optimizer.OneOf_OptimizerType, rhs: Optimizer.OneOf_OptimizerType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sgdOptimizer, .sgdOptimizer): return {
        guard case .sgdOptimizer(let l) = lhs, case .sgdOptimizer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.adamOptimizer, .adamOptimizer): return {
        guard case .adamOptimizer(let l) = lhs, case .adamOptimizer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///
/// Stochastic gradient descent optimizer,
/// specifying configurable learning rate, mini batch size, and momentum
public struct SGDOptimizer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var learningRate: DoubleParameter {
    get {return _learningRate ?? DoubleParameter()}
    set {_learningRate = newValue}
  }
  /// Returns true if `learningRate` has been explicitly set.
  public var hasLearningRate: Bool {return self._learningRate != nil}
  /// Clears the value of `learningRate`. Subsequent reads from it will return its default value.
  public mutating func clearLearningRate() {self._learningRate = nil}

  public var miniBatchSize: Int64Parameter {
    get {return _miniBatchSize ?? Int64Parameter()}
    set {_miniBatchSize = newValue}
  }
  /// Returns true if `miniBatchSize` has been explicitly set.
  public var hasMiniBatchSize: Bool {return self._miniBatchSize != nil}
  /// Clears the value of `miniBatchSize`. Subsequent reads from it will return its default value.
  public mutating func clearMiniBatchSize() {self._miniBatchSize = nil}

  public var momentum: DoubleParameter {
    get {return _momentum ?? DoubleParameter()}
    set {_momentum = newValue}
  }
  /// Returns true if `momentum` has been explicitly set.
  public var hasMomentum: Bool {return self._momentum != nil}
  /// Clears the value of `momentum`. Subsequent reads from it will return its default value.
  public mutating func clearMomentum() {self._momentum = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _learningRate: DoubleParameter? = nil
  fileprivate var _miniBatchSize: Int64Parameter? = nil
  fileprivate var _momentum: DoubleParameter? = nil
}

///
/// Adam optimizer,
/// specifying configurable learning rate, mini batch size, betas, and eps
public struct AdamOptimizer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var learningRate: DoubleParameter {
    get {return _learningRate ?? DoubleParameter()}
    set {_learningRate = newValue}
  }
  /// Returns true if `learningRate` has been explicitly set.
  public var hasLearningRate: Bool {return self._learningRate != nil}
  /// Clears the value of `learningRate`. Subsequent reads from it will return its default value.
  public mutating func clearLearningRate() {self._learningRate = nil}

  public var miniBatchSize: Int64Parameter {
    get {return _miniBatchSize ?? Int64Parameter()}
    set {_miniBatchSize = newValue}
  }
  /// Returns true if `miniBatchSize` has been explicitly set.
  public var hasMiniBatchSize: Bool {return self._miniBatchSize != nil}
  /// Clears the value of `miniBatchSize`. Subsequent reads from it will return its default value.
  public mutating func clearMiniBatchSize() {self._miniBatchSize = nil}

  public var beta1: DoubleParameter {
    get {return _beta1 ?? DoubleParameter()}
    set {_beta1 = newValue}
  }
  /// Returns true if `beta1` has been explicitly set.
  public var hasBeta1: Bool {return self._beta1 != nil}
  /// Clears the value of `beta1`. Subsequent reads from it will return its default value.
  public mutating func clearBeta1() {self._beta1 = nil}

  public var beta2: DoubleParameter {
    get {return _beta2 ?? DoubleParameter()}
    set {_beta2 = newValue}
  }
  /// Returns true if `beta2` has been explicitly set.
  public var hasBeta2: Bool {return self._beta2 != nil}
  /// Clears the value of `beta2`. Subsequent reads from it will return its default value.
  public mutating func clearBeta2() {self._beta2 = nil}

  public var eps: DoubleParameter {
    get {return _eps ?? DoubleParameter()}
    set {_eps = newValue}
  }
  /// Returns true if `eps` has been explicitly set.
  public var hasEps: Bool {return self._eps != nil}
  /// Clears the value of `eps`. Subsequent reads from it will return its default value.
  public mutating func clearEps() {self._eps = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _learningRate: DoubleParameter? = nil
  fileprivate var _miniBatchSize: Int64Parameter? = nil
  fileprivate var _beta1: DoubleParameter? = nil
  fileprivate var _beta2: DoubleParameter? = nil
  fileprivate var _eps: DoubleParameter? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension NeuralNetworkMultiArrayShapeMapping: @unchecked Sendable {}
extension NeuralNetworkImageShapeMapping: @unchecked Sendable {}
extension ScatterMode: @unchecked Sendable {}
extension NeuralNetwork: @unchecked Sendable {}
extension NeuralNetworkImageScaler: @unchecked Sendable {}
extension NeuralNetworkMeanImage: @unchecked Sendable {}
extension NeuralNetworkPreprocessing: @unchecked Sendable {}
extension NeuralNetworkPreprocessing.OneOf_Preprocessor: @unchecked Sendable {}
extension ActivationReLU: @unchecked Sendable {}
extension ActivationLeakyReLU: @unchecked Sendable {}
extension ActivationTanh: @unchecked Sendable {}
extension ActivationScaledTanh: @unchecked Sendable {}
extension ActivationSigmoid: @unchecked Sendable {}
extension ActivationLinear: @unchecked Sendable {}
extension ActivationSigmoidHard: @unchecked Sendable {}
extension ActivationPReLU: @unchecked Sendable {}
extension ActivationELU: @unchecked Sendable {}
extension ActivationThresholdedReLU: @unchecked Sendable {}
extension ActivationSoftsign: @unchecked Sendable {}
extension ActivationSoftplus: @unchecked Sendable {}
extension ActivationParametricSoftplus: @unchecked Sendable {}
extension ActivationParams: @unchecked Sendable {}
extension ActivationParams.OneOf_NonlinearityType: @unchecked Sendable {}
extension Tensor: @unchecked Sendable {}
extension NeuralNetworkLayer: @unchecked Sendable {}
extension NeuralNetworkLayer.OneOf_Layer: @unchecked Sendable {}
extension BranchLayerParams: @unchecked Sendable {}
extension LoopLayerParams: @unchecked Sendable {}
extension LoopBreakLayerParams: @unchecked Sendable {}
extension LoopContinueLayerParams: @unchecked Sendable {}
extension CopyLayerParams: @unchecked Sendable {}
extension GreaterThanLayerParams: @unchecked Sendable {}
extension GreaterEqualLayerParams: @unchecked Sendable {}
extension LessThanLayerParams: @unchecked Sendable {}
extension LessEqualLayerParams: @unchecked Sendable {}
extension EqualLayerParams: @unchecked Sendable {}
extension NotEqualLayerParams: @unchecked Sendable {}
extension LogicalAndLayerParams: @unchecked Sendable {}
extension LogicalOrLayerParams: @unchecked Sendable {}
extension LogicalXorLayerParams: @unchecked Sendable {}
extension LogicalNotLayerParams: @unchecked Sendable {}
extension BorderAmounts: @unchecked Sendable {}
extension BorderAmounts.EdgeSizes: @unchecked Sendable {}
extension ValidPadding: @unchecked Sendable {}
extension SamePadding: @unchecked Sendable {}
extension SamePadding.SamePaddingMode: @unchecked Sendable {}
extension SamplingMode: @unchecked Sendable {}
extension SamplingMode.Method: @unchecked Sendable {}
extension BoxCoordinatesMode: @unchecked Sendable {}
extension BoxCoordinatesMode.Coordinates: @unchecked Sendable {}
extension WeightParams: @unchecked Sendable {}
extension QuantizationParams: @unchecked Sendable {}
extension QuantizationParams.OneOf_QuantizationType: @unchecked Sendable {}
extension LinearQuantizationParams: @unchecked Sendable {}
extension LookUpTableQuantizationParams: @unchecked Sendable {}
extension ConvolutionLayerParams: @unchecked Sendable {}
extension ConvolutionLayerParams.OneOf_ConvolutionPaddingType: @unchecked Sendable {}
extension Convolution3DLayerParams: @unchecked Sendable {}
extension Convolution3DLayerParams.PaddingType: @unchecked Sendable {}
extension InnerProductLayerParams: @unchecked Sendable {}
extension EmbeddingLayerParams: @unchecked Sendable {}
extension EmbeddingNDLayerParams: @unchecked Sendable {}
extension BatchnormLayerParams: @unchecked Sendable {}
extension PoolingLayerParams: @unchecked Sendable {}
extension PoolingLayerParams.OneOf_PoolingPaddingType: @unchecked Sendable {}
extension PoolingLayerParams.PoolingType: @unchecked Sendable {}
extension PoolingLayerParams.ValidCompletePadding: @unchecked Sendable {}
extension Pooling3DLayerParams: @unchecked Sendable {}
extension Pooling3DLayerParams.PoolingType3D: @unchecked Sendable {}
extension Pooling3DLayerParams.Pooling3DPaddingType: @unchecked Sendable {}
extension GlobalPooling3DLayerParams: @unchecked Sendable {}
extension GlobalPooling3DLayerParams.GlobalPoolingType3D: @unchecked Sendable {}
extension PaddingLayerParams: @unchecked Sendable {}
extension PaddingLayerParams.OneOf_PaddingType: @unchecked Sendable {}
extension PaddingLayerParams.PaddingConstant: @unchecked Sendable {}
extension PaddingLayerParams.PaddingReflection: @unchecked Sendable {}
extension PaddingLayerParams.PaddingReplication: @unchecked Sendable {}
extension ConcatLayerParams: @unchecked Sendable {}
extension LRNLayerParams: @unchecked Sendable {}
extension SoftmaxLayerParams: @unchecked Sendable {}
extension SplitLayerParams: @unchecked Sendable {}
extension AddLayerParams: @unchecked Sendable {}
extension MultiplyLayerParams: @unchecked Sendable {}
extension UnaryFunctionLayerParams: @unchecked Sendable {}
extension UnaryFunctionLayerParams.Operation: @unchecked Sendable {}
extension UpsampleLayerParams: @unchecked Sendable {}
extension UpsampleLayerParams.InterpolationMode: @unchecked Sendable {}
extension UpsampleLayerParams.LinearUpsampleMode: @unchecked Sendable {}
extension ResizeBilinearLayerParams: @unchecked Sendable {}
extension CropResizeLayerParams: @unchecked Sendable {}
extension BiasLayerParams: @unchecked Sendable {}
extension ScaleLayerParams: @unchecked Sendable {}
extension LoadConstantLayerParams: @unchecked Sendable {}
extension L2NormalizeLayerParams: @unchecked Sendable {}
extension FlattenLayerParams: @unchecked Sendable {}
extension FlattenLayerParams.FlattenOrder: @unchecked Sendable {}
extension ReshapeLayerParams: @unchecked Sendable {}
extension ReshapeLayerParams.ReshapeOrder: @unchecked Sendable {}
extension PermuteLayerParams: @unchecked Sendable {}
extension ReorganizeDataLayerParams: @unchecked Sendable {}
extension ReorganizeDataLayerParams.ReorganizationType: @unchecked Sendable {}
extension SliceLayerParams: @unchecked Sendable {}
extension SliceLayerParams.SliceAxis: @unchecked Sendable {}
extension ReduceLayerParams: @unchecked Sendable {}
extension ReduceLayerParams.ReduceOperation: @unchecked Sendable {}
extension ReduceLayerParams.ReduceAxis: @unchecked Sendable {}
extension CropLayerParams: @unchecked Sendable {}
extension AverageLayerParams: @unchecked Sendable {}
extension MaxLayerParams: @unchecked Sendable {}
extension MinLayerParams: @unchecked Sendable {}
extension DotProductLayerParams: @unchecked Sendable {}
extension MeanVarianceNormalizeLayerParams: @unchecked Sendable {}
extension SequenceRepeatLayerParams: @unchecked Sendable {}
extension SimpleRecurrentLayerParams: @unchecked Sendable {}
extension GRULayerParams: @unchecked Sendable {}
extension LSTMParams: @unchecked Sendable {}
extension LSTMWeightParams: @unchecked Sendable {}
extension UniDirectionalLSTMLayerParams: @unchecked Sendable {}
extension BiDirectionalLSTMLayerParams: @unchecked Sendable {}
extension CustomLayerParams: @unchecked Sendable {}
extension CustomLayerParams.CustomLayerParamValue: @unchecked Sendable {}
extension CustomLayerParams.CustomLayerParamValue.OneOf_Value: @unchecked Sendable {}
extension TransposeLayerParams: @unchecked Sendable {}
extension BatchedMatMulLayerParams: @unchecked Sendable {}
extension ConcatNDLayerParams: @unchecked Sendable {}
extension SoftmaxNDLayerParams: @unchecked Sendable {}
extension ReverseLayerParams: @unchecked Sendable {}
extension ReverseSeqLayerParams: @unchecked Sendable {}
extension LoadConstantNDLayerParams: @unchecked Sendable {}
extension FillLikeLayerParams: @unchecked Sendable {}
extension FillStaticLayerParams: @unchecked Sendable {}
extension FillDynamicLayerParams: @unchecked Sendable {}
extension WhereBroadcastableLayerParams: @unchecked Sendable {}
extension SinLayerParams: @unchecked Sendable {}
extension CosLayerParams: @unchecked Sendable {}
extension TanLayerParams: @unchecked Sendable {}
extension AsinLayerParams: @unchecked Sendable {}
extension AcosLayerParams: @unchecked Sendable {}
extension AtanLayerParams: @unchecked Sendable {}
extension SinhLayerParams: @unchecked Sendable {}
extension CoshLayerParams: @unchecked Sendable {}
extension TanhLayerParams: @unchecked Sendable {}
extension AsinhLayerParams: @unchecked Sendable {}
extension AcoshLayerParams: @unchecked Sendable {}
extension AtanhLayerParams: @unchecked Sendable {}
extension PowBroadcastableLayerParams: @unchecked Sendable {}
extension Exp2LayerParams: @unchecked Sendable {}
extension WhereNonZeroLayerParams: @unchecked Sendable {}
extension MatrixBandPartLayerParams: @unchecked Sendable {}
extension UpperTriangularLayerParams: @unchecked Sendable {}
extension LowerTriangularLayerParams: @unchecked Sendable {}
extension BroadcastToLikeLayerParams: @unchecked Sendable {}
extension BroadcastToStaticLayerParams: @unchecked Sendable {}
extension BroadcastToDynamicLayerParams: @unchecked Sendable {}
extension AddBroadcastableLayerParams: @unchecked Sendable {}
extension MaxBroadcastableLayerParams: @unchecked Sendable {}
extension MinBroadcastableLayerParams: @unchecked Sendable {}
extension ModBroadcastableLayerParams: @unchecked Sendable {}
extension FloorDivBroadcastableLayerParams: @unchecked Sendable {}
extension SubtractBroadcastableLayerParams: @unchecked Sendable {}
extension MultiplyBroadcastableLayerParams: @unchecked Sendable {}
extension DivideBroadcastableLayerParams: @unchecked Sendable {}
extension GatherLayerParams: @unchecked Sendable {}
extension ScatterLayerParams: @unchecked Sendable {}
extension GatherNDLayerParams: @unchecked Sendable {}
extension ScatterNDLayerParams: @unchecked Sendable {}
extension GatherAlongAxisLayerParams: @unchecked Sendable {}
extension ScatterAlongAxisLayerParams: @unchecked Sendable {}
extension StackLayerParams: @unchecked Sendable {}
extension RankPreservingReshapeLayerParams: @unchecked Sendable {}
extension ConstantPaddingLayerParams: @unchecked Sendable {}
extension RandomNormalLikeLayerParams: @unchecked Sendable {}
extension RandomNormalStaticLayerParams: @unchecked Sendable {}
extension RandomNormalDynamicLayerParams: @unchecked Sendable {}
extension RandomUniformLikeLayerParams: @unchecked Sendable {}
extension RandomUniformStaticLayerParams: @unchecked Sendable {}
extension RandomUniformDynamicLayerParams: @unchecked Sendable {}
extension RandomBernoulliLikeLayerParams: @unchecked Sendable {}
extension RandomBernoulliStaticLayerParams: @unchecked Sendable {}
extension RandomBernoulliDynamicLayerParams: @unchecked Sendable {}
extension CategoricalDistributionLayerParams: @unchecked Sendable {}
extension ReduceL1LayerParams: @unchecked Sendable {}
extension ReduceL2LayerParams: @unchecked Sendable {}
extension ReduceMaxLayerParams: @unchecked Sendable {}
extension ReduceMinLayerParams: @unchecked Sendable {}
extension ReduceSumLayerParams: @unchecked Sendable {}
extension ReduceProdLayerParams: @unchecked Sendable {}
extension ReduceMeanLayerParams: @unchecked Sendable {}
extension ReduceLogSumLayerParams: @unchecked Sendable {}
extension ReduceSumSquareLayerParams: @unchecked Sendable {}
extension ReduceLogSumExpLayerParams: @unchecked Sendable {}
extension ExpandDimsLayerParams: @unchecked Sendable {}
extension FlattenTo2DLayerParams: @unchecked Sendable {}
extension ReshapeStaticLayerParams: @unchecked Sendable {}
extension ReshapeLikeLayerParams: @unchecked Sendable {}
extension ReshapeDynamicLayerParams: @unchecked Sendable {}
extension SqueezeLayerParams: @unchecked Sendable {}
extension TopKLayerParams: @unchecked Sendable {}
extension ArgMaxLayerParams: @unchecked Sendable {}
extension ArgMinLayerParams: @unchecked Sendable {}
extension SplitNDLayerParams: @unchecked Sendable {}
extension CeilLayerParams: @unchecked Sendable {}
extension RoundLayerParams: @unchecked Sendable {}
extension FloorLayerParams: @unchecked Sendable {}
extension SignLayerParams: @unchecked Sendable {}
extension ClipLayerParams: @unchecked Sendable {}
extension SliceStaticLayerParams: @unchecked Sendable {}
extension SliceDynamicLayerParams: @unchecked Sendable {}
extension TileLayerParams: @unchecked Sendable {}
extension GetShapeLayerParams: @unchecked Sendable {}
extension ErfLayerParams: @unchecked Sendable {}
extension GeluLayerParams: @unchecked Sendable {}
extension GeluLayerParams.GeluMode: @unchecked Sendable {}
extension RangeStaticLayerParams: @unchecked Sendable {}
extension RangeDynamicLayerParams: @unchecked Sendable {}
extension SlidingWindowsLayerParams: @unchecked Sendable {}
extension LayerNormalizationLayerParams: @unchecked Sendable {}
extension NonMaximumSuppressionLayerParams: @unchecked Sendable {}
extension ClampedReLULayerParams: @unchecked Sendable {}
extension ArgSortLayerParams: @unchecked Sendable {}
extension SliceBySizeLayerParams: @unchecked Sendable {}
extension NeuralNetworkClassifier: @unchecked Sendable {}
extension NeuralNetworkClassifier.OneOf_ClassLabels: @unchecked Sendable {}
extension OneHotLayerParams: @unchecked Sendable {}
extension CumSumLayerParams: @unchecked Sendable {}
extension NeuralNetworkRegressor: @unchecked Sendable {}
extension NetworkUpdateParameters: @unchecked Sendable {}
extension LossLayer: @unchecked Sendable {}
extension LossLayer.OneOf_LossLayerType: @unchecked Sendable {}
extension CategoricalCrossEntropyLossLayer: @unchecked Sendable {}
extension MeanSquaredErrorLossLayer: @unchecked Sendable {}
extension Optimizer: @unchecked Sendable {}
extension Optimizer.OneOf_OptimizerType: @unchecked Sendable {}
extension SGDOptimizer: @unchecked Sendable {}
extension AdamOptimizer: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension NeuralNetworkMultiArrayShapeMapping: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RANK5_ARRAY_MAPPING"),
    1: .same(proto: "EXACT_ARRAY_MAPPING"),
  ]
}

extension NeuralNetworkImageShapeMapping: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RANK5_IMAGE_MAPPING"),
    1: .same(proto: "RANK4_IMAGE_MAPPING"),
  ]
}

extension ScatterMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCATTER_UPDATE"),
    1: .same(proto: "SCATTER_ADD"),
    2: .same(proto: "SCATTER_SUB"),
    3: .same(proto: "SCATTER_MUL"),
    4: .same(proto: "SCATTER_DIV"),
    5: .same(proto: "SCATTER_MAX"),
    6: .same(proto: "SCATTER_MIN"),
  ]
}

extension NeuralNetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetwork"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
    5: .same(proto: "arrayInputShapeMapping"),
    6: .same(proto: "imageInputShapeMapping"),
    10: .same(proto: "updateParams"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.preprocessing) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.arrayInputShapeMapping) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.imageInputShapeMapping) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._updateParams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    if !self.preprocessing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preprocessing, fieldNumber: 2)
    }
    if self.arrayInputShapeMapping != .rank5ArrayMapping {
      try visitor.visitSingularEnumField(value: self.arrayInputShapeMapping, fieldNumber: 5)
    }
    if self.imageInputShapeMapping != .rank5ImageMapping {
      try visitor.visitSingularEnumField(value: self.imageInputShapeMapping, fieldNumber: 6)
    }
    try { if let v = self._updateParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NeuralNetwork, rhs: NeuralNetwork) -> Bool {
    if lhs.layers != rhs.layers {return false}
    if lhs.preprocessing != rhs.preprocessing {return false}
    if lhs.arrayInputShapeMapping != rhs.arrayInputShapeMapping {return false}
    if lhs.imageInputShapeMapping != rhs.imageInputShapeMapping {return false}
    if lhs._updateParams != rhs._updateParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NeuralNetworkImageScaler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkImageScaler"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "channelScale"),
    20: .same(proto: "blueBias"),
    21: .same(proto: "greenBias"),
    22: .same(proto: "redBias"),
    30: .same(proto: "grayBias"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try { try decoder.decodeSingularFloatField(value: &self.channelScale) }()
      case 20: try { try decoder.decodeSingularFloatField(value: &self.blueBias) }()
      case 21: try { try decoder.decodeSingularFloatField(value: &self.greenBias) }()
      case 22: try { try decoder.decodeSingularFloatField(value: &self.redBias) }()
      case 30: try { try decoder.decodeSingularFloatField(value: &self.grayBias) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelScale != 0 {
      try visitor.visitSingularFloatField(value: self.channelScale, fieldNumber: 10)
    }
    if self.blueBias != 0 {
      try visitor.visitSingularFloatField(value: self.blueBias, fieldNumber: 20)
    }
    if self.greenBias != 0 {
      try visitor.visitSingularFloatField(value: self.greenBias, fieldNumber: 21)
    }
    if self.redBias != 0 {
      try visitor.visitSingularFloatField(value: self.redBias, fieldNumber: 22)
    }
    if self.grayBias != 0 {
      try visitor.visitSingularFloatField(value: self.grayBias, fieldNumber: 30)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NeuralNetworkImageScaler, rhs: NeuralNetworkImageScaler) -> Bool {
    if lhs.channelScale != rhs.channelScale {return false}
    if lhs.blueBias != rhs.blueBias {return false}
    if lhs.greenBias != rhs.greenBias {return false}
    if lhs.redBias != rhs.redBias {return false}
    if lhs.grayBias != rhs.grayBias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NeuralNetworkMeanImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkMeanImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "meanImage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.meanImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.meanImage.isEmpty {
      try visitor.visitPackedFloatField(value: self.meanImage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NeuralNetworkMeanImage, rhs: NeuralNetworkMeanImage) -> Bool {
    if lhs.meanImage != rhs.meanImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NeuralNetworkPreprocessing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkPreprocessing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "featureName"),
    10: .same(proto: "scaler"),
    11: .same(proto: "meanImage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.featureName) }()
      case 10: try {
        var v: NeuralNetworkImageScaler?
        var hadOneofValue = false
        if let current = self.preprocessor {
          hadOneofValue = true
          if case .scaler(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.preprocessor = .scaler(v)
        }
      }()
      case 11: try {
        var v: NeuralNetworkMeanImage?
        var hadOneofValue = false
        if let current = self.preprocessor {
          hadOneofValue = true
          if case .meanImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.preprocessor = .meanImage(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.featureName.isEmpty {
      try visitor.visitSingularStringField(value: self.featureName, fieldNumber: 1)
    }
    switch self.preprocessor {
    case .scaler?: try {
      guard case .scaler(let v)? = self.preprocessor else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .meanImage?: try {
      guard case .meanImage(let v)? = self.preprocessor else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NeuralNetworkPreprocessing, rhs: NeuralNetworkPreprocessing) -> Bool {
    if lhs.featureName != rhs.featureName {return false}
    if lhs.preprocessor != rhs.preprocessor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationReLU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationReLU"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationReLU, rhs: ActivationReLU) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationLeakyReLU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationLeakyReLU"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationLeakyReLU, rhs: ActivationLeakyReLU) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationTanh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationTanh"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationTanh, rhs: ActivationTanh) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationScaledTanh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationScaledTanh"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.beta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationScaledTanh, rhs: ActivationScaledTanh) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationSigmoid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationSigmoid"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationSigmoid, rhs: ActivationSigmoid) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationLinear: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationLinear"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.beta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationLinear, rhs: ActivationLinear) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationSigmoidHard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationSigmoidHard"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.beta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationSigmoidHard, rhs: ActivationSigmoidHard) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationPReLU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationPReLU"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._alpha {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationPReLU, rhs: ActivationPReLU) -> Bool {
    if lhs._alpha != rhs._alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationELU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationELU"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationELU, rhs: ActivationELU) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationThresholdedReLU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationThresholdedReLU"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationThresholdedReLU, rhs: ActivationThresholdedReLU) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationSoftsign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationSoftsign"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationSoftsign, rhs: ActivationSoftsign) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationSoftplus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationSoftplus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationSoftplus, rhs: ActivationSoftplus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationParametricSoftplus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationParametricSoftplus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._alpha) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._beta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._alpha {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._beta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationParametricSoftplus, rhs: ActivationParametricSoftplus) -> Bool {
    if lhs._alpha != rhs._alpha {return false}
    if lhs._beta != rhs._beta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActivationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivationParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "linear"),
    10: .same(proto: "ReLU"),
    15: .same(proto: "leakyReLU"),
    20: .same(proto: "thresholdedReLU"),
    25: .same(proto: "PReLU"),
    30: .same(proto: "tanh"),
    31: .same(proto: "scaledTanh"),
    40: .same(proto: "sigmoid"),
    41: .same(proto: "sigmoidHard"),
    50: .same(proto: "ELU"),
    60: .same(proto: "softsign"),
    70: .same(proto: "softplus"),
    71: .same(proto: "parametricSoftplus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try {
        var v: ActivationLinear?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .linear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .linear(v)
        }
      }()
      case 10: try {
        var v: ActivationReLU?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .reLu(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .reLu(v)
        }
      }()
      case 15: try {
        var v: ActivationLeakyReLU?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .leakyReLu(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .leakyReLu(v)
        }
      }()
      case 20: try {
        var v: ActivationThresholdedReLU?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .thresholdedReLu(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .thresholdedReLu(v)
        }
      }()
      case 25: try {
        var v: ActivationPReLU?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .preLu(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .preLu(v)
        }
      }()
      case 30: try {
        var v: ActivationTanh?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .tanh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .tanh(v)
        }
      }()
      case 31: try {
        var v: ActivationScaledTanh?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .scaledTanh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .scaledTanh(v)
        }
      }()
      case 40: try {
        var v: ActivationSigmoid?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .sigmoid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .sigmoid(v)
        }
      }()
      case 41: try {
        var v: ActivationSigmoidHard?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .sigmoidHard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .sigmoidHard(v)
        }
      }()
      case 50: try {
        var v: ActivationELU?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .elu(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .elu(v)
        }
      }()
      case 60: try {
        var v: ActivationSoftsign?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .softsign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .softsign(v)
        }
      }()
      case 70: try {
        var v: ActivationSoftplus?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .softplus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .softplus(v)
        }
      }()
      case 71: try {
        var v: ActivationParametricSoftplus?
        var hadOneofValue = false
        if let current = self.nonlinearityType {
          hadOneofValue = true
          if case .parametricSoftplus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nonlinearityType = .parametricSoftplus(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.nonlinearityType {
    case .linear?: try {
      guard case .linear(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .reLu?: try {
      guard case .reLu(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .leakyReLu?: try {
      guard case .leakyReLu(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .thresholdedReLu?: try {
      guard case .thresholdedReLu(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .preLu?: try {
      guard case .preLu(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .tanh?: try {
      guard case .tanh(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .scaledTanh?: try {
      guard case .scaledTanh(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .sigmoid?: try {
      guard case .sigmoid(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .sigmoidHard?: try {
      guard case .sigmoidHard(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .elu?: try {
      guard case .elu(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .softsign?: try {
      guard case .softsign(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .softplus?: try {
      guard case .softplus(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
    }()
    case .parametricSoftplus?: try {
      guard case .parametricSoftplus(let v)? = self.nonlinearityType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ActivationParams, rhs: ActivationParams) -> Bool {
    if lhs.nonlinearityType != rhs.nonlinearityType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tensor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rank"),
    2: .same(proto: "dimValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.rank) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.dimValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rank != 0 {
      try visitor.visitSingularUInt32Field(value: self.rank, fieldNumber: 1)
    }
    if !self.dimValue.isEmpty {
      try visitor.visitPackedInt64Field(value: self.dimValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensor, rhs: Tensor) -> Bool {
    if lhs.rank != rhs.rank {return false}
    if lhs.dimValue != rhs.dimValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NeuralNetworkLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "input"),
    3: .same(proto: "output"),
    4: .same(proto: "inputTensor"),
    5: .same(proto: "outputTensor"),
    10: .same(proto: "isUpdatable"),
    100: .same(proto: "convolution"),
    120: .same(proto: "pooling"),
    130: .same(proto: "activation"),
    140: .same(proto: "innerProduct"),
    150: .same(proto: "embedding"),
    160: .same(proto: "batchnorm"),
    165: .same(proto: "mvn"),
    170: .same(proto: "l2normalize"),
    175: .same(proto: "softmax"),
    180: .same(proto: "lrn"),
    190: .same(proto: "crop"),
    200: .same(proto: "padding"),
    210: .same(proto: "upsample"),
    211: .same(proto: "resizeBilinear"),
    212: .same(proto: "cropResize"),
    220: .same(proto: "unary"),
    230: .same(proto: "add"),
    231: .same(proto: "multiply"),
    240: .same(proto: "average"),
    245: .same(proto: "scale"),
    250: .same(proto: "bias"),
    260: .same(proto: "max"),
    261: .same(proto: "min"),
    270: .same(proto: "dot"),
    280: .same(proto: "reduce"),
    290: .same(proto: "loadConstant"),
    300: .same(proto: "reshape"),
    301: .same(proto: "flatten"),
    310: .same(proto: "permute"),
    320: .same(proto: "concat"),
    330: .same(proto: "split"),
    340: .same(proto: "sequenceRepeat"),
    345: .same(proto: "reorganizeData"),
    350: .same(proto: "slice"),
    400: .same(proto: "simpleRecurrent"),
    410: .same(proto: "gru"),
    420: .same(proto: "uniDirectionalLSTM"),
    430: .same(proto: "biDirectionalLSTM"),
    500: .same(proto: "custom"),
    600: .same(proto: "copy"),
    605: .same(proto: "branch"),
    615: .same(proto: "loop"),
    620: .same(proto: "loopBreak"),
    625: .same(proto: "loopContinue"),
    635: .same(proto: "rangeStatic"),
    640: .same(proto: "rangeDynamic"),
    660: .same(proto: "clip"),
    665: .same(proto: "ceil"),
    670: .same(proto: "floor"),
    680: .same(proto: "sign"),
    685: .same(proto: "round"),
    700: .same(proto: "exp2"),
    710: .same(proto: "sin"),
    715: .same(proto: "cos"),
    720: .same(proto: "tan"),
    730: .same(proto: "asin"),
    735: .same(proto: "acos"),
    740: .same(proto: "atan"),
    750: .same(proto: "sinh"),
    755: .same(proto: "cosh"),
    760: .same(proto: "tanh"),
    770: .same(proto: "asinh"),
    775: .same(proto: "acosh"),
    780: .same(proto: "atanh"),
    790: .same(proto: "erf"),
    795: .same(proto: "gelu"),
    815: .same(proto: "equal"),
    820: .same(proto: "notEqual"),
    825: .same(proto: "lessThan"),
    827: .same(proto: "lessEqual"),
    830: .same(proto: "greaterThan"),
    832: .same(proto: "greaterEqual"),
    840: .same(proto: "logicalOr"),
    845: .same(proto: "logicalXor"),
    850: .same(proto: "logicalNot"),
    855: .same(proto: "logicalAnd"),
    865: .same(proto: "modBroadcastable"),
    870: .same(proto: "minBroadcastable"),
    875: .same(proto: "maxBroadcastable"),
    880: .same(proto: "addBroadcastable"),
    885: .same(proto: "powBroadcastable"),
    890: .same(proto: "divideBroadcastable"),
    895: .same(proto: "floorDivBroadcastable"),
    900: .same(proto: "multiplyBroadcastable"),
    905: .same(proto: "subtractBroadcastable"),
    920: .same(proto: "tile"),
    925: .same(proto: "stack"),
    930: .same(proto: "gather"),
    935: .same(proto: "scatter"),
    940: .same(proto: "gatherND"),
    945: .same(proto: "scatterND"),
    950: .same(proto: "softmaxND"),
    952: .same(proto: "gatherAlongAxis"),
    954: .same(proto: "scatterAlongAxis"),
    960: .same(proto: "reverse"),
    965: .same(proto: "reverseSeq"),
    975: .same(proto: "splitND"),
    980: .same(proto: "concatND"),
    985: .same(proto: "transpose"),
    995: .same(proto: "sliceStatic"),
    1000: .same(proto: "sliceDynamic"),
    1005: .same(proto: "slidingWindows"),
    1015: .same(proto: "topK"),
    1020: .same(proto: "argMin"),
    1025: .same(proto: "argMax"),
    1040: .same(proto: "embeddingND"),
    1045: .same(proto: "batchedMatmul"),
    1065: .same(proto: "getShape"),
    1070: .same(proto: "loadConstantND"),
    1080: .same(proto: "fillLike"),
    1085: .same(proto: "fillStatic"),
    1090: .same(proto: "fillDynamic"),
    1100: .same(proto: "broadcastToLike"),
    1105: .same(proto: "broadcastToStatic"),
    1110: .same(proto: "broadcastToDynamic"),
    1120: .same(proto: "squeeze"),
    1125: .same(proto: "expandDims"),
    1130: .same(proto: "flattenTo2D"),
    1135: .same(proto: "reshapeLike"),
    1140: .same(proto: "reshapeStatic"),
    1145: .same(proto: "reshapeDynamic"),
    1150: .same(proto: "rankPreservingReshape"),
    1155: .same(proto: "constantPad"),
    1170: .same(proto: "randomNormalLike"),
    1175: .same(proto: "randomNormalStatic"),
    1180: .same(proto: "randomNormalDynamic"),
    1190: .same(proto: "randomUniformLike"),
    1195: .same(proto: "randomUniformStatic"),
    1200: .same(proto: "randomUniformDynamic"),
    1210: .same(proto: "randomBernoulliLike"),
    1215: .same(proto: "randomBernoulliStatic"),
    1220: .same(proto: "randomBernoulliDynamic"),
    1230: .same(proto: "categoricalDistribution"),
    1250: .same(proto: "reduceL1"),
    1255: .same(proto: "reduceL2"),
    1260: .same(proto: "reduceMax"),
    1265: .same(proto: "reduceMin"),
    1270: .same(proto: "reduceSum"),
    1275: .same(proto: "reduceProd"),
    1280: .same(proto: "reduceMean"),
    1285: .same(proto: "reduceLogSum"),
    1290: .same(proto: "reduceSumSquare"),
    1295: .same(proto: "reduceLogSumExp"),
    1313: .same(proto: "whereNonZero"),
    1315: .same(proto: "matrixBandPart"),
    1320: .same(proto: "lowerTriangular"),
    1325: .same(proto: "upperTriangular"),
    1330: .same(proto: "whereBroadcastable"),
    1350: .same(proto: "layerNormalization"),
    1400: .same(proto: "NonMaximumSuppression"),
    1450: .same(proto: "oneHot"),
    1455: .same(proto: "cumSum"),
    1460: .same(proto: "clampedReLU"),
    1461: .same(proto: "argSort"),
    1465: .same(proto: "pooling3d"),
    1466: .same(proto: "globalPooling3d"),
    1470: .same(proto: "sliceBySize"),
    1471: .same(proto: "convolution3d"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _input: [String] = []
    var _output: [String] = []
    var _inputTensor: [Tensor] = []
    var _outputTensor: [Tensor] = []
    var _isUpdatable: Bool = false
    var _layer: NeuralNetworkLayer.OneOf_Layer?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _input = source._input
      _output = source._output
      _inputTensor = source._inputTensor
      _outputTensor = source._outputTensor
      _isUpdatable = source._isUpdatable
      _layer = source._layer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._input) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._output) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._inputTensor) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._outputTensor) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isUpdatable) }()
        case 100: try {
          var v: ConvolutionLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .convolution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .convolution(v)
          }
        }()
        case 120: try {
          var v: PoolingLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .pooling(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .pooling(v)
          }
        }()
        case 130: try {
          var v: ActivationParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .activation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .activation(v)
          }
        }()
        case 140: try {
          var v: InnerProductLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .innerProduct(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .innerProduct(v)
          }
        }()
        case 150: try {
          var v: EmbeddingLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .embedding(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .embedding(v)
          }
        }()
        case 160: try {
          var v: BatchnormLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .batchnorm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .batchnorm(v)
          }
        }()
        case 165: try {
          var v: MeanVarianceNormalizeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .mvn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .mvn(v)
          }
        }()
        case 170: try {
          var v: L2NormalizeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .l2Normalize(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .l2Normalize(v)
          }
        }()
        case 175: try {
          var v: SoftmaxLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .softmax(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .softmax(v)
          }
        }()
        case 180: try {
          var v: LRNLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .lrn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .lrn(v)
          }
        }()
        case 190: try {
          var v: CropLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .crop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .crop(v)
          }
        }()
        case 200: try {
          var v: PaddingLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .padding(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .padding(v)
          }
        }()
        case 210: try {
          var v: UpsampleLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .upsample(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .upsample(v)
          }
        }()
        case 211: try {
          var v: ResizeBilinearLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .resizeBilinear(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .resizeBilinear(v)
          }
        }()
        case 212: try {
          var v: CropResizeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .cropResize(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .cropResize(v)
          }
        }()
        case 220: try {
          var v: UnaryFunctionLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .unary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .unary(v)
          }
        }()
        case 230: try {
          var v: AddLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .add(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .add(v)
          }
        }()
        case 231: try {
          var v: MultiplyLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .multiply(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .multiply(v)
          }
        }()
        case 240: try {
          var v: AverageLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .average(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .average(v)
          }
        }()
        case 245: try {
          var v: ScaleLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .scale(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .scale(v)
          }
        }()
        case 250: try {
          var v: BiasLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .bias(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .bias(v)
          }
        }()
        case 260: try {
          var v: MaxLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .max(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .max(v)
          }
        }()
        case 261: try {
          var v: MinLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .min(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .min(v)
          }
        }()
        case 270: try {
          var v: DotProductLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .dot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .dot(v)
          }
        }()
        case 280: try {
          var v: ReduceLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduce(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduce(v)
          }
        }()
        case 290: try {
          var v: LoadConstantLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .loadConstant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .loadConstant(v)
          }
        }()
        case 300: try {
          var v: ReshapeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reshape(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reshape(v)
          }
        }()
        case 301: try {
          var v: FlattenLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .flatten(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .flatten(v)
          }
        }()
        case 310: try {
          var v: PermuteLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .permute(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .permute(v)
          }
        }()
        case 320: try {
          var v: ConcatLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .concat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .concat(v)
          }
        }()
        case 330: try {
          var v: SplitLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .split(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .split(v)
          }
        }()
        case 340: try {
          var v: SequenceRepeatLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .sequenceRepeat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .sequenceRepeat(v)
          }
        }()
        case 345: try {
          var v: ReorganizeDataLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reorganizeData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reorganizeData(v)
          }
        }()
        case 350: try {
          var v: SliceLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .slice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .slice(v)
          }
        }()
        case 400: try {
          var v: SimpleRecurrentLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .simpleRecurrent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .simpleRecurrent(v)
          }
        }()
        case 410: try {
          var v: GRULayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .gru(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .gru(v)
          }
        }()
        case 420: try {
          var v: UniDirectionalLSTMLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .uniDirectionalLstm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .uniDirectionalLstm(v)
          }
        }()
        case 430: try {
          var v: BiDirectionalLSTMLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .biDirectionalLstm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .biDirectionalLstm(v)
          }
        }()
        case 500: try {
          var v: CustomLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .custom(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .custom(v)
          }
        }()
        case 600: try {
          var v: CopyLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .copy(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .copy(v)
          }
        }()
        case 605: try {
          var v: BranchLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .branch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .branch(v)
          }
        }()
        case 615: try {
          var v: LoopLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .loop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .loop(v)
          }
        }()
        case 620: try {
          var v: LoopBreakLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .loopBreak(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .loopBreak(v)
          }
        }()
        case 625: try {
          var v: LoopContinueLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .loopContinue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .loopContinue(v)
          }
        }()
        case 635: try {
          var v: RangeStaticLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .rangeStatic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .rangeStatic(v)
          }
        }()
        case 640: try {
          var v: RangeDynamicLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .rangeDynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .rangeDynamic(v)
          }
        }()
        case 660: try {
          var v: ClipLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .clip(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .clip(v)
          }
        }()
        case 665: try {
          var v: CeilLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .ceil(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .ceil(v)
          }
        }()
        case 670: try {
          var v: FloorLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .floor(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .floor(v)
          }
        }()
        case 680: try {
          var v: SignLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .sign(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .sign(v)
          }
        }()
        case 685: try {
          var v: RoundLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .round(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .round(v)
          }
        }()
        case 700: try {
          var v: Exp2LayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .exp2(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .exp2(v)
          }
        }()
        case 710: try {
          var v: SinLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .sin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .sin(v)
          }
        }()
        case 715: try {
          var v: CosLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .cos(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .cos(v)
          }
        }()
        case 720: try {
          var v: TanLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .tan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .tan(v)
          }
        }()
        case 730: try {
          var v: AsinLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .asin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .asin(v)
          }
        }()
        case 735: try {
          var v: AcosLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .acos(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .acos(v)
          }
        }()
        case 740: try {
          var v: AtanLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .atan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .atan(v)
          }
        }()
        case 750: try {
          var v: SinhLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .sinh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .sinh(v)
          }
        }()
        case 755: try {
          var v: CoshLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .cosh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .cosh(v)
          }
        }()
        case 760: try {
          var v: TanhLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .tanh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .tanh(v)
          }
        }()
        case 770: try {
          var v: AsinhLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .asinh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .asinh(v)
          }
        }()
        case 775: try {
          var v: AcoshLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .acosh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .acosh(v)
          }
        }()
        case 780: try {
          var v: AtanhLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .atanh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .atanh(v)
          }
        }()
        case 790: try {
          var v: ErfLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .erf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .erf(v)
          }
        }()
        case 795: try {
          var v: GeluLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .gelu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .gelu(v)
          }
        }()
        case 815: try {
          var v: EqualLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .equal(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .equal(v)
          }
        }()
        case 820: try {
          var v: NotEqualLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .notEqual(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .notEqual(v)
          }
        }()
        case 825: try {
          var v: LessThanLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .lessThan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .lessThan(v)
          }
        }()
        case 827: try {
          var v: LessEqualLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .lessEqual(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .lessEqual(v)
          }
        }()
        case 830: try {
          var v: GreaterThanLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .greaterThan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .greaterThan(v)
          }
        }()
        case 832: try {
          var v: GreaterEqualLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .greaterEqual(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .greaterEqual(v)
          }
        }()
        case 840: try {
          var v: LogicalOrLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .logicalOr(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .logicalOr(v)
          }
        }()
        case 845: try {
          var v: LogicalXorLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .logicalXor(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .logicalXor(v)
          }
        }()
        case 850: try {
          var v: LogicalNotLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .logicalNot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .logicalNot(v)
          }
        }()
        case 855: try {
          var v: LogicalAndLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .logicalAnd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .logicalAnd(v)
          }
        }()
        case 865: try {
          var v: ModBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .modBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .modBroadcastable(v)
          }
        }()
        case 870: try {
          var v: MinBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .minBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .minBroadcastable(v)
          }
        }()
        case 875: try {
          var v: MaxBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .maxBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .maxBroadcastable(v)
          }
        }()
        case 880: try {
          var v: AddBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .addBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .addBroadcastable(v)
          }
        }()
        case 885: try {
          var v: PowBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .powBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .powBroadcastable(v)
          }
        }()
        case 890: try {
          var v: DivideBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .divideBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .divideBroadcastable(v)
          }
        }()
        case 895: try {
          var v: FloorDivBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .floorDivBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .floorDivBroadcastable(v)
          }
        }()
        case 900: try {
          var v: MultiplyBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .multiplyBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .multiplyBroadcastable(v)
          }
        }()
        case 905: try {
          var v: SubtractBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .subtractBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .subtractBroadcastable(v)
          }
        }()
        case 920: try {
          var v: TileLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .tile(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .tile(v)
          }
        }()
        case 925: try {
          var v: StackLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .stack(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .stack(v)
          }
        }()
        case 930: try {
          var v: GatherLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .gather(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .gather(v)
          }
        }()
        case 935: try {
          var v: ScatterLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .scatter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .scatter(v)
          }
        }()
        case 940: try {
          var v: GatherNDLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .gatherNd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .gatherNd(v)
          }
        }()
        case 945: try {
          var v: ScatterNDLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .scatterNd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .scatterNd(v)
          }
        }()
        case 950: try {
          var v: SoftmaxNDLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .softmaxNd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .softmaxNd(v)
          }
        }()
        case 952: try {
          var v: GatherAlongAxisLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .gatherAlongAxis(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .gatherAlongAxis(v)
          }
        }()
        case 954: try {
          var v: ScatterAlongAxisLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .scatterAlongAxis(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .scatterAlongAxis(v)
          }
        }()
        case 960: try {
          var v: ReverseLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reverse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reverse(v)
          }
        }()
        case 965: try {
          var v: ReverseSeqLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reverseSeq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reverseSeq(v)
          }
        }()
        case 975: try {
          var v: SplitNDLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .splitNd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .splitNd(v)
          }
        }()
        case 980: try {
          var v: ConcatNDLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .concatNd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .concatNd(v)
          }
        }()
        case 985: try {
          var v: TransposeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .transpose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .transpose(v)
          }
        }()
        case 995: try {
          var v: SliceStaticLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .sliceStatic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .sliceStatic(v)
          }
        }()
        case 1000: try {
          var v: SliceDynamicLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .sliceDynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .sliceDynamic(v)
          }
        }()
        case 1005: try {
          var v: SlidingWindowsLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .slidingWindows(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .slidingWindows(v)
          }
        }()
        case 1015: try {
          var v: TopKLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .topK(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .topK(v)
          }
        }()
        case 1020: try {
          var v: ArgMinLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .argMin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .argMin(v)
          }
        }()
        case 1025: try {
          var v: ArgMaxLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .argMax(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .argMax(v)
          }
        }()
        case 1040: try {
          var v: EmbeddingNDLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .embeddingNd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .embeddingNd(v)
          }
        }()
        case 1045: try {
          var v: BatchedMatMulLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .batchedMatmul(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .batchedMatmul(v)
          }
        }()
        case 1065: try {
          var v: GetShapeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .getShape(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .getShape(v)
          }
        }()
        case 1070: try {
          var v: LoadConstantNDLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .loadConstantNd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .loadConstantNd(v)
          }
        }()
        case 1080: try {
          var v: FillLikeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .fillLike(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .fillLike(v)
          }
        }()
        case 1085: try {
          var v: FillStaticLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .fillStatic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .fillStatic(v)
          }
        }()
        case 1090: try {
          var v: FillDynamicLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .fillDynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .fillDynamic(v)
          }
        }()
        case 1100: try {
          var v: BroadcastToLikeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .broadcastToLike(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .broadcastToLike(v)
          }
        }()
        case 1105: try {
          var v: BroadcastToStaticLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .broadcastToStatic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .broadcastToStatic(v)
          }
        }()
        case 1110: try {
          var v: BroadcastToDynamicLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .broadcastToDynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .broadcastToDynamic(v)
          }
        }()
        case 1120: try {
          var v: SqueezeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .squeeze(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .squeeze(v)
          }
        }()
        case 1125: try {
          var v: ExpandDimsLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .expandDims(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .expandDims(v)
          }
        }()
        case 1130: try {
          var v: FlattenTo2DLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .flattenTo2D(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .flattenTo2D(v)
          }
        }()
        case 1135: try {
          var v: ReshapeLikeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reshapeLike(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reshapeLike(v)
          }
        }()
        case 1140: try {
          var v: ReshapeStaticLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reshapeStatic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reshapeStatic(v)
          }
        }()
        case 1145: try {
          var v: ReshapeDynamicLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reshapeDynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reshapeDynamic(v)
          }
        }()
        case 1150: try {
          var v: RankPreservingReshapeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .rankPreservingReshape(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .rankPreservingReshape(v)
          }
        }()
        case 1155: try {
          var v: ConstantPaddingLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .constantPad(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .constantPad(v)
          }
        }()
        case 1170: try {
          var v: RandomNormalLikeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomNormalLike(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomNormalLike(v)
          }
        }()
        case 1175: try {
          var v: RandomNormalStaticLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomNormalStatic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomNormalStatic(v)
          }
        }()
        case 1180: try {
          var v: RandomNormalDynamicLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomNormalDynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomNormalDynamic(v)
          }
        }()
        case 1190: try {
          var v: RandomUniformLikeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomUniformLike(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomUniformLike(v)
          }
        }()
        case 1195: try {
          var v: RandomUniformStaticLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomUniformStatic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomUniformStatic(v)
          }
        }()
        case 1200: try {
          var v: RandomUniformDynamicLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomUniformDynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomUniformDynamic(v)
          }
        }()
        case 1210: try {
          var v: RandomBernoulliLikeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomBernoulliLike(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomBernoulliLike(v)
          }
        }()
        case 1215: try {
          var v: RandomBernoulliStaticLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomBernoulliStatic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomBernoulliStatic(v)
          }
        }()
        case 1220: try {
          var v: RandomBernoulliDynamicLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .randomBernoulliDynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .randomBernoulliDynamic(v)
          }
        }()
        case 1230: try {
          var v: CategoricalDistributionLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .categoricalDistribution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .categoricalDistribution(v)
          }
        }()
        case 1250: try {
          var v: ReduceL1LayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceL1(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceL1(v)
          }
        }()
        case 1255: try {
          var v: ReduceL2LayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceL2(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceL2(v)
          }
        }()
        case 1260: try {
          var v: ReduceMaxLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceMax(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceMax(v)
          }
        }()
        case 1265: try {
          var v: ReduceMinLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceMin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceMin(v)
          }
        }()
        case 1270: try {
          var v: ReduceSumLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceSum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceSum(v)
          }
        }()
        case 1275: try {
          var v: ReduceProdLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceProd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceProd(v)
          }
        }()
        case 1280: try {
          var v: ReduceMeanLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceMean(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceMean(v)
          }
        }()
        case 1285: try {
          var v: ReduceLogSumLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceLogSum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceLogSum(v)
          }
        }()
        case 1290: try {
          var v: ReduceSumSquareLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceSumSquare(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceSumSquare(v)
          }
        }()
        case 1295: try {
          var v: ReduceLogSumExpLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .reduceLogSumExp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .reduceLogSumExp(v)
          }
        }()
        case 1313: try {
          var v: WhereNonZeroLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .whereNonZero(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .whereNonZero(v)
          }
        }()
        case 1315: try {
          var v: MatrixBandPartLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .matrixBandPart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .matrixBandPart(v)
          }
        }()
        case 1320: try {
          var v: LowerTriangularLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .lowerTriangular(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .lowerTriangular(v)
          }
        }()
        case 1325: try {
          var v: UpperTriangularLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .upperTriangular(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .upperTriangular(v)
          }
        }()
        case 1330: try {
          var v: WhereBroadcastableLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .whereBroadcastable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .whereBroadcastable(v)
          }
        }()
        case 1350: try {
          var v: LayerNormalizationLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .layerNormalization(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .layerNormalization(v)
          }
        }()
        case 1400: try {
          var v: NonMaximumSuppressionLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .nonMaximumSuppression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .nonMaximumSuppression(v)
          }
        }()
        case 1450: try {
          var v: OneHotLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .oneHot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .oneHot(v)
          }
        }()
        case 1455: try {
          var v: CumSumLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .cumSum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .cumSum(v)
          }
        }()
        case 1460: try {
          var v: ClampedReLULayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .clampedReLu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .clampedReLu(v)
          }
        }()
        case 1461: try {
          var v: ArgSortLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .argSort(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .argSort(v)
          }
        }()
        case 1465: try {
          var v: Pooling3DLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .pooling3D(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .pooling3D(v)
          }
        }()
        case 1466: try {
          var v: GlobalPooling3DLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .globalPooling3D(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .globalPooling3D(v)
          }
        }()
        case 1470: try {
          var v: SliceBySizeLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .sliceBySize(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .sliceBySize(v)
          }
        }()
        case 1471: try {
          var v: Convolution3DLayerParams?
          var hadOneofValue = false
          if let current = _storage._layer {
            hadOneofValue = true
            if case .convolution3D(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._layer = .convolution3D(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._input.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._input, fieldNumber: 2)
      }
      if !_storage._output.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._output, fieldNumber: 3)
      }
      if !_storage._inputTensor.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inputTensor, fieldNumber: 4)
      }
      if !_storage._outputTensor.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outputTensor, fieldNumber: 5)
      }
      if _storage._isUpdatable != false {
        try visitor.visitSingularBoolField(value: _storage._isUpdatable, fieldNumber: 10)
      }
      switch _storage._layer {
      case .convolution?: try {
        guard case .convolution(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      }()
      case .pooling?: try {
        guard case .pooling(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
      }()
      case .activation?: try {
        guard case .activation(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
      }()
      case .innerProduct?: try {
        guard case .innerProduct(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 140)
      }()
      case .embedding?: try {
        guard case .embedding(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 150)
      }()
      case .batchnorm?: try {
        guard case .batchnorm(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 160)
      }()
      case .mvn?: try {
        guard case .mvn(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 165)
      }()
      case .l2Normalize?: try {
        guard case .l2Normalize(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 170)
      }()
      case .softmax?: try {
        guard case .softmax(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 175)
      }()
      case .lrn?: try {
        guard case .lrn(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 180)
      }()
      case .crop?: try {
        guard case .crop(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 190)
      }()
      case .padding?: try {
        guard case .padding(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
      }()
      case .upsample?: try {
        guard case .upsample(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 210)
      }()
      case .resizeBilinear?: try {
        guard case .resizeBilinear(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 211)
      }()
      case .cropResize?: try {
        guard case .cropResize(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 212)
      }()
      case .unary?: try {
        guard case .unary(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 220)
      }()
      case .add?: try {
        guard case .add(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 230)
      }()
      case .multiply?: try {
        guard case .multiply(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 231)
      }()
      case .average?: try {
        guard case .average(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 240)
      }()
      case .scale?: try {
        guard case .scale(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 245)
      }()
      case .bias?: try {
        guard case .bias(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 250)
      }()
      case .max?: try {
        guard case .max(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 260)
      }()
      case .min?: try {
        guard case .min(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 261)
      }()
      case .dot?: try {
        guard case .dot(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 270)
      }()
      case .reduce?: try {
        guard case .reduce(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 280)
      }()
      case .loadConstant?: try {
        guard case .loadConstant(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 290)
      }()
      case .reshape?: try {
        guard case .reshape(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 300)
      }()
      case .flatten?: try {
        guard case .flatten(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
      }()
      case .permute?: try {
        guard case .permute(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 310)
      }()
      case .concat?: try {
        guard case .concat(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 320)
      }()
      case .split?: try {
        guard case .split(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 330)
      }()
      case .sequenceRepeat?: try {
        guard case .sequenceRepeat(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 340)
      }()
      case .reorganizeData?: try {
        guard case .reorganizeData(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 345)
      }()
      case .slice?: try {
        guard case .slice(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 350)
      }()
      case .simpleRecurrent?: try {
        guard case .simpleRecurrent(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 400)
      }()
      case .gru?: try {
        guard case .gru(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 410)
      }()
      case .uniDirectionalLstm?: try {
        guard case .uniDirectionalLstm(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 420)
      }()
      case .biDirectionalLstm?: try {
        guard case .biDirectionalLstm(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 430)
      }()
      case .custom?: try {
        guard case .custom(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 500)
      }()
      case .copy?: try {
        guard case .copy(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 600)
      }()
      case .branch?: try {
        guard case .branch(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 605)
      }()
      case .loop?: try {
        guard case .loop(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 615)
      }()
      case .loopBreak?: try {
        guard case .loopBreak(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 620)
      }()
      case .loopContinue?: try {
        guard case .loopContinue(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 625)
      }()
      case .rangeStatic?: try {
        guard case .rangeStatic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 635)
      }()
      case .rangeDynamic?: try {
        guard case .rangeDynamic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 640)
      }()
      case .clip?: try {
        guard case .clip(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 660)
      }()
      case .ceil?: try {
        guard case .ceil(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 665)
      }()
      case .floor?: try {
        guard case .floor(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 670)
      }()
      case .sign?: try {
        guard case .sign(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 680)
      }()
      case .round?: try {
        guard case .round(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 685)
      }()
      case .exp2?: try {
        guard case .exp2(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 700)
      }()
      case .sin?: try {
        guard case .sin(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 710)
      }()
      case .cos?: try {
        guard case .cos(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 715)
      }()
      case .tan?: try {
        guard case .tan(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 720)
      }()
      case .asin?: try {
        guard case .asin(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 730)
      }()
      case .acos?: try {
        guard case .acos(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 735)
      }()
      case .atan?: try {
        guard case .atan(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 740)
      }()
      case .sinh?: try {
        guard case .sinh(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 750)
      }()
      case .cosh?: try {
        guard case .cosh(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 755)
      }()
      case .tanh?: try {
        guard case .tanh(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 760)
      }()
      case .asinh?: try {
        guard case .asinh(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 770)
      }()
      case .acosh?: try {
        guard case .acosh(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 775)
      }()
      case .atanh?: try {
        guard case .atanh(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 780)
      }()
      case .erf?: try {
        guard case .erf(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 790)
      }()
      case .gelu?: try {
        guard case .gelu(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 795)
      }()
      case .equal?: try {
        guard case .equal(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 815)
      }()
      case .notEqual?: try {
        guard case .notEqual(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 820)
      }()
      case .lessThan?: try {
        guard case .lessThan(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 825)
      }()
      case .lessEqual?: try {
        guard case .lessEqual(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 827)
      }()
      case .greaterThan?: try {
        guard case .greaterThan(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 830)
      }()
      case .greaterEqual?: try {
        guard case .greaterEqual(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 832)
      }()
      case .logicalOr?: try {
        guard case .logicalOr(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 840)
      }()
      case .logicalXor?: try {
        guard case .logicalXor(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 845)
      }()
      case .logicalNot?: try {
        guard case .logicalNot(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 850)
      }()
      case .logicalAnd?: try {
        guard case .logicalAnd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 855)
      }()
      case .modBroadcastable?: try {
        guard case .modBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 865)
      }()
      case .minBroadcastable?: try {
        guard case .minBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 870)
      }()
      case .maxBroadcastable?: try {
        guard case .maxBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 875)
      }()
      case .addBroadcastable?: try {
        guard case .addBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 880)
      }()
      case .powBroadcastable?: try {
        guard case .powBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 885)
      }()
      case .divideBroadcastable?: try {
        guard case .divideBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 890)
      }()
      case .floorDivBroadcastable?: try {
        guard case .floorDivBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 895)
      }()
      case .multiplyBroadcastable?: try {
        guard case .multiplyBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 900)
      }()
      case .subtractBroadcastable?: try {
        guard case .subtractBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 905)
      }()
      case .tile?: try {
        guard case .tile(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 920)
      }()
      case .stack?: try {
        guard case .stack(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 925)
      }()
      case .gather?: try {
        guard case .gather(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 930)
      }()
      case .scatter?: try {
        guard case .scatter(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 935)
      }()
      case .gatherNd?: try {
        guard case .gatherNd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 940)
      }()
      case .scatterNd?: try {
        guard case .scatterNd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 945)
      }()
      case .softmaxNd?: try {
        guard case .softmaxNd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 950)
      }()
      case .gatherAlongAxis?: try {
        guard case .gatherAlongAxis(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 952)
      }()
      case .scatterAlongAxis?: try {
        guard case .scatterAlongAxis(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 954)
      }()
      case .reverse?: try {
        guard case .reverse(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 960)
      }()
      case .reverseSeq?: try {
        guard case .reverseSeq(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 965)
      }()
      case .splitNd?: try {
        guard case .splitNd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 975)
      }()
      case .concatNd?: try {
        guard case .concatNd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 980)
      }()
      case .transpose?: try {
        guard case .transpose(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 985)
      }()
      case .sliceStatic?: try {
        guard case .sliceStatic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 995)
      }()
      case .sliceDynamic?: try {
        guard case .sliceDynamic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
      }()
      case .slidingWindows?: try {
        guard case .slidingWindows(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1005)
      }()
      case .topK?: try {
        guard case .topK(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1015)
      }()
      case .argMin?: try {
        guard case .argMin(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1020)
      }()
      case .argMax?: try {
        guard case .argMax(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1025)
      }()
      case .embeddingNd?: try {
        guard case .embeddingNd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1040)
      }()
      case .batchedMatmul?: try {
        guard case .batchedMatmul(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1045)
      }()
      case .getShape?: try {
        guard case .getShape(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1065)
      }()
      case .loadConstantNd?: try {
        guard case .loadConstantNd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1070)
      }()
      case .fillLike?: try {
        guard case .fillLike(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1080)
      }()
      case .fillStatic?: try {
        guard case .fillStatic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1085)
      }()
      case .fillDynamic?: try {
        guard case .fillDynamic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1090)
      }()
      case .broadcastToLike?: try {
        guard case .broadcastToLike(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1100)
      }()
      case .broadcastToStatic?: try {
        guard case .broadcastToStatic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1105)
      }()
      case .broadcastToDynamic?: try {
        guard case .broadcastToDynamic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1110)
      }()
      case .squeeze?: try {
        guard case .squeeze(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1120)
      }()
      case .expandDims?: try {
        guard case .expandDims(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1125)
      }()
      case .flattenTo2D?: try {
        guard case .flattenTo2D(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1130)
      }()
      case .reshapeLike?: try {
        guard case .reshapeLike(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1135)
      }()
      case .reshapeStatic?: try {
        guard case .reshapeStatic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1140)
      }()
      case .reshapeDynamic?: try {
        guard case .reshapeDynamic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1145)
      }()
      case .rankPreservingReshape?: try {
        guard case .rankPreservingReshape(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1150)
      }()
      case .constantPad?: try {
        guard case .constantPad(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1155)
      }()
      case .randomNormalLike?: try {
        guard case .randomNormalLike(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1170)
      }()
      case .randomNormalStatic?: try {
        guard case .randomNormalStatic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1175)
      }()
      case .randomNormalDynamic?: try {
        guard case .randomNormalDynamic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1180)
      }()
      case .randomUniformLike?: try {
        guard case .randomUniformLike(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1190)
      }()
      case .randomUniformStatic?: try {
        guard case .randomUniformStatic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1195)
      }()
      case .randomUniformDynamic?: try {
        guard case .randomUniformDynamic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1200)
      }()
      case .randomBernoulliLike?: try {
        guard case .randomBernoulliLike(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1210)
      }()
      case .randomBernoulliStatic?: try {
        guard case .randomBernoulliStatic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1215)
      }()
      case .randomBernoulliDynamic?: try {
        guard case .randomBernoulliDynamic(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1220)
      }()
      case .categoricalDistribution?: try {
        guard case .categoricalDistribution(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1230)
      }()
      case .reduceL1?: try {
        guard case .reduceL1(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1250)
      }()
      case .reduceL2?: try {
        guard case .reduceL2(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1255)
      }()
      case .reduceMax?: try {
        guard case .reduceMax(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1260)
      }()
      case .reduceMin?: try {
        guard case .reduceMin(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1265)
      }()
      case .reduceSum?: try {
        guard case .reduceSum(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1270)
      }()
      case .reduceProd?: try {
        guard case .reduceProd(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1275)
      }()
      case .reduceMean?: try {
        guard case .reduceMean(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1280)
      }()
      case .reduceLogSum?: try {
        guard case .reduceLogSum(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1285)
      }()
      case .reduceSumSquare?: try {
        guard case .reduceSumSquare(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1290)
      }()
      case .reduceLogSumExp?: try {
        guard case .reduceLogSumExp(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1295)
      }()
      case .whereNonZero?: try {
        guard case .whereNonZero(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1313)
      }()
      case .matrixBandPart?: try {
        guard case .matrixBandPart(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1315)
      }()
      case .lowerTriangular?: try {
        guard case .lowerTriangular(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1320)
      }()
      case .upperTriangular?: try {
        guard case .upperTriangular(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1325)
      }()
      case .whereBroadcastable?: try {
        guard case .whereBroadcastable(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1330)
      }()
      case .layerNormalization?: try {
        guard case .layerNormalization(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1350)
      }()
      case .nonMaximumSuppression?: try {
        guard case .nonMaximumSuppression(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1400)
      }()
      case .oneHot?: try {
        guard case .oneHot(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1450)
      }()
      case .cumSum?: try {
        guard case .cumSum(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1455)
      }()
      case .clampedReLu?: try {
        guard case .clampedReLu(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1460)
      }()
      case .argSort?: try {
        guard case .argSort(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1461)
      }()
      case .pooling3D?: try {
        guard case .pooling3D(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1465)
      }()
      case .globalPooling3D?: try {
        guard case .globalPooling3D(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1466)
      }()
      case .sliceBySize?: try {
        guard case .sliceBySize(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1470)
      }()
      case .convolution3D?: try {
        guard case .convolution3D(let v)? = _storage._layer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1471)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NeuralNetworkLayer, rhs: NeuralNetworkLayer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._inputTensor != rhs_storage._inputTensor {return false}
        if _storage._outputTensor != rhs_storage._outputTensor {return false}
        if _storage._isUpdatable != rhs_storage._isUpdatable {return false}
        if _storage._layer != rhs_storage._layer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BranchLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BranchLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ifBranch"),
    2: .same(proto: "elseBranch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ifBranch) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._elseBranch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ifBranch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._elseBranch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BranchLayerParams, rhs: BranchLayerParams) -> Bool {
    if lhs._ifBranch != rhs._ifBranch {return false}
    if lhs._elseBranch != rhs._elseBranch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoopLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoopLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxLoopIterations"),
    2: .same(proto: "conditionVar"),
    3: .same(proto: "conditionNetwork"),
    4: .same(proto: "bodyNetwork"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxLoopIterations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conditionVar) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._conditionNetwork) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bodyNetwork) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.maxLoopIterations != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxLoopIterations, fieldNumber: 1)
    }
    if !self.conditionVar.isEmpty {
      try visitor.visitSingularStringField(value: self.conditionVar, fieldNumber: 2)
    }
    try { if let v = self._conditionNetwork {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bodyNetwork {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LoopLayerParams, rhs: LoopLayerParams) -> Bool {
    if lhs.maxLoopIterations != rhs.maxLoopIterations {return false}
    if lhs.conditionVar != rhs.conditionVar {return false}
    if lhs._conditionNetwork != rhs._conditionNetwork {return false}
    if lhs._bodyNetwork != rhs._bodyNetwork {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoopBreakLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoopBreakLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LoopBreakLayerParams, rhs: LoopBreakLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoopContinueLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoopContinueLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LoopContinueLayerParams, rhs: LoopContinueLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CopyLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CopyLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CopyLayerParams, rhs: CopyLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GreaterThanLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GreaterThanLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GreaterThanLayerParams, rhs: GreaterThanLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GreaterEqualLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GreaterEqualLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GreaterEqualLayerParams, rhs: GreaterEqualLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LessThanLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LessThanLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LessThanLayerParams, rhs: LessThanLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LessEqualLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LessEqualLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LessEqualLayerParams, rhs: LessEqualLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EqualLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EqualLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EqualLayerParams, rhs: EqualLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotEqualLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotEqualLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotEqualLayerParams, rhs: NotEqualLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogicalAndLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogicalAndLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LogicalAndLayerParams, rhs: LogicalAndLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogicalOrLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogicalOrLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LogicalOrLayerParams, rhs: LogicalOrLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogicalXorLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogicalXorLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LogicalXorLayerParams, rhs: LogicalXorLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogicalNotLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogicalNotLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LogicalNotLayerParams, rhs: LogicalNotLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BorderAmounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BorderAmounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "borderAmounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.borderAmounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.borderAmounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.borderAmounts, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BorderAmounts, rhs: BorderAmounts) -> Bool {
    if lhs.borderAmounts != rhs.borderAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BorderAmounts.EdgeSizes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BorderAmounts.protoMessageName + ".EdgeSizes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startEdgeSize"),
    2: .same(proto: "endEdgeSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.startEdgeSize) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.endEdgeSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startEdgeSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.startEdgeSize, fieldNumber: 1)
    }
    if self.endEdgeSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.endEdgeSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BorderAmounts.EdgeSizes, rhs: BorderAmounts.EdgeSizes) -> Bool {
    if lhs.startEdgeSize != rhs.startEdgeSize {return false}
    if lhs.endEdgeSize != rhs.endEdgeSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValidPadding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidPadding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paddingAmounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paddingAmounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paddingAmounts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ValidPadding, rhs: ValidPadding) -> Bool {
    if lhs._paddingAmounts != rhs._paddingAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SamePadding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SamePadding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asymmetryMode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.asymmetryMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.asymmetryMode != .bottomRightHeavy {
      try visitor.visitSingularEnumField(value: self.asymmetryMode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SamePadding, rhs: SamePadding) -> Bool {
    if lhs.asymmetryMode != rhs.asymmetryMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SamePadding.SamePaddingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOTTOM_RIGHT_HEAVY"),
    1: .same(proto: "TOP_LEFT_HEAVY"),
  ]
}

extension SamplingMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SamplingMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "samplingMethod"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.samplingMethod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplingMethod != .strictAlignEndpointsMode {
      try visitor.visitSingularEnumField(value: self.samplingMethod, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SamplingMode, rhs: SamplingMode) -> Bool {
    if lhs.samplingMethod != rhs.samplingMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SamplingMode.Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STRICT_ALIGN_ENDPOINTS_MODE"),
    1: .same(proto: "ALIGN_ENDPOINTS_MODE"),
    2: .same(proto: "UPSAMPLE_MODE"),
    3: .same(proto: "ROI_ALIGN_MODE"),
  ]
}

extension BoxCoordinatesMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoxCoordinatesMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "boxMode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.boxMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.boxMode != .cornersHeightFirst {
      try visitor.visitSingularEnumField(value: self.boxMode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BoxCoordinatesMode, rhs: BoxCoordinatesMode) -> Bool {
    if lhs.boxMode != rhs.boxMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BoxCoordinatesMode.Coordinates: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CORNERS_HEIGHT_FIRST"),
    1: .same(proto: "CORNERS_WIDTH_FIRST"),
    2: .same(proto: "CENTER_SIZE_HEIGHT_FIRST"),
    3: .same(proto: "CENTER_SIZE_WIDTH_FIRST"),
  ]
}

extension WeightParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WeightParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "floatValue"),
    2: .same(proto: "float16Value"),
    30: .same(proto: "rawValue"),
    31: .same(proto: "int8RawValue"),
    40: .same(proto: "quantization"),
    50: .same(proto: "isUpdatable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.floatValue) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.float16Value) }()
      case 30: try { try decoder.decodeSingularBytesField(value: &self.rawValue) }()
      case 31: try { try decoder.decodeSingularBytesField(value: &self.int8RawValue) }()
      case 40: try { try decoder.decodeSingularMessageField(value: &self._quantization) }()
      case 50: try { try decoder.decodeSingularBoolField(value: &self.isUpdatable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.floatValue.isEmpty {
      try visitor.visitPackedFloatField(value: self.floatValue, fieldNumber: 1)
    }
    if !self.float16Value.isEmpty {
      try visitor.visitSingularBytesField(value: self.float16Value, fieldNumber: 2)
    }
    if !self.rawValue.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawValue, fieldNumber: 30)
    }
    if !self.int8RawValue.isEmpty {
      try visitor.visitSingularBytesField(value: self.int8RawValue, fieldNumber: 31)
    }
    try { if let v = self._quantization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    } }()
    if self.isUpdatable != false {
      try visitor.visitSingularBoolField(value: self.isUpdatable, fieldNumber: 50)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WeightParams, rhs: WeightParams) -> Bool {
    if lhs.floatValue != rhs.floatValue {return false}
    if lhs.float16Value != rhs.float16Value {return false}
    if lhs.rawValue != rhs.rawValue {return false}
    if lhs.int8RawValue != rhs.int8RawValue {return false}
    if lhs._quantization != rhs._quantization {return false}
    if lhs.isUpdatable != rhs.isUpdatable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QuantizationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuantizationParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numberOfBits"),
    101: .same(proto: "linearQuantization"),
    102: .same(proto: "lookupTableQuantization"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.numberOfBits) }()
      case 101: try {
        var v: LinearQuantizationParams?
        var hadOneofValue = false
        if let current = self.quantizationType {
          hadOneofValue = true
          if case .linearQuantization(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantizationType = .linearQuantization(v)
        }
      }()
      case 102: try {
        var v: LookUpTableQuantizationParams?
        var hadOneofValue = false
        if let current = self.quantizationType {
          hadOneofValue = true
          if case .lookupTableQuantization(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantizationType = .lookupTableQuantization(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.numberOfBits != 0 {
      try visitor.visitSingularUInt64Field(value: self.numberOfBits, fieldNumber: 1)
    }
    switch self.quantizationType {
    case .linearQuantization?: try {
      guard case .linearQuantization(let v)? = self.quantizationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .lookupTableQuantization?: try {
      guard case .lookupTableQuantization(let v)? = self.quantizationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: QuantizationParams, rhs: QuantizationParams) -> Bool {
    if lhs.numberOfBits != rhs.numberOfBits {return false}
    if lhs.quantizationType != rhs.quantizationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinearQuantizationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinearQuantizationParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scale"),
    2: .same(proto: "bias"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.scale) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.bias) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scale.isEmpty {
      try visitor.visitPackedFloatField(value: self.scale, fieldNumber: 1)
    }
    if !self.bias.isEmpty {
      try visitor.visitPackedFloatField(value: self.bias, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LinearQuantizationParams, rhs: LinearQuantizationParams) -> Bool {
    if lhs.scale != rhs.scale {return false}
    if lhs.bias != rhs.bias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LookUpTableQuantizationParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookUpTableQuantizationParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "floatValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.floatValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.floatValue.isEmpty {
      try visitor.visitPackedFloatField(value: self.floatValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LookUpTableQuantizationParams, rhs: LookUpTableQuantizationParams) -> Bool {
    if lhs.floatValue != rhs.floatValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConvolutionLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvolutionLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputChannels"),
    2: .same(proto: "kernelChannels"),
    10: .same(proto: "nGroups"),
    20: .same(proto: "kernelSize"),
    30: .same(proto: "stride"),
    40: .same(proto: "dilationFactor"),
    50: .same(proto: "valid"),
    51: .same(proto: "same"),
    60: .same(proto: "isDeconvolution"),
    70: .same(proto: "hasBias"),
    90: .same(proto: "weights"),
    91: .same(proto: "bias"),
    100: .same(proto: "outputShape"),
  ]

  fileprivate class _StorageClass {
    var _outputChannels: UInt64 = 0
    var _kernelChannels: UInt64 = 0
    var _nGroups: UInt64 = 0
    var _kernelSize: [UInt64] = []
    var _stride: [UInt64] = []
    var _dilationFactor: [UInt64] = []
    var _convolutionPaddingType: ConvolutionLayerParams.OneOf_ConvolutionPaddingType?
    var _isDeconvolution: Bool = false
    var _hasBias_p: Bool = false
    var _weights: WeightParams? = nil
    var _bias: WeightParams? = nil
    var _outputShape: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _outputChannels = source._outputChannels
      _kernelChannels = source._kernelChannels
      _nGroups = source._nGroups
      _kernelSize = source._kernelSize
      _stride = source._stride
      _dilationFactor = source._dilationFactor
      _convolutionPaddingType = source._convolutionPaddingType
      _isDeconvolution = source._isDeconvolution
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
      _outputShape = source._outputShape
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._kernelChannels) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._nGroups) }()
        case 20: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._kernelSize) }()
        case 30: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._stride) }()
        case 40: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._dilationFactor) }()
        case 50: try {
          var v: ValidPadding?
          var hadOneofValue = false
          if let current = _storage._convolutionPaddingType {
            hadOneofValue = true
            if case .valid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._convolutionPaddingType = .valid(v)
          }
        }()
        case 51: try {
          var v: SamePadding?
          var hadOneofValue = false
          if let current = _storage._convolutionPaddingType {
            hadOneofValue = true
            if case .same(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._convolutionPaddingType = .same(v)
          }
        }()
        case 60: try { try decoder.decodeSingularBoolField(value: &_storage._isDeconvolution) }()
        case 70: try { try decoder.decodeSingularBoolField(value: &_storage._hasBias_p) }()
        case 90: try { try decoder.decodeSingularMessageField(value: &_storage._weights) }()
        case 91: try { try decoder.decodeSingularMessageField(value: &_storage._bias) }()
        case 100: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._outputShape) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 1)
      }
      if _storage._kernelChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._kernelChannels, fieldNumber: 2)
      }
      if _storage._nGroups != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nGroups, fieldNumber: 10)
      }
      if !_storage._kernelSize.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._kernelSize, fieldNumber: 20)
      }
      if !_storage._stride.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._stride, fieldNumber: 30)
      }
      if !_storage._dilationFactor.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._dilationFactor, fieldNumber: 40)
      }
      switch _storage._convolutionPaddingType {
      case .valid?: try {
        guard case .valid(let v)? = _storage._convolutionPaddingType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .same?: try {
        guard case .same(let v)? = _storage._convolutionPaddingType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case nil: break
      }
      if _storage._isDeconvolution != false {
        try visitor.visitSingularBoolField(value: _storage._isDeconvolution, fieldNumber: 60)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 70)
      }
      try { if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      } }()
      try { if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      } }()
      if !_storage._outputShape.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._outputShape, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConvolutionLayerParams, rhs: ConvolutionLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._outputChannels != rhs_storage._outputChannels {return false}
        if _storage._kernelChannels != rhs_storage._kernelChannels {return false}
        if _storage._nGroups != rhs_storage._nGroups {return false}
        if _storage._kernelSize != rhs_storage._kernelSize {return false}
        if _storage._stride != rhs_storage._stride {return false}
        if _storage._dilationFactor != rhs_storage._dilationFactor {return false}
        if _storage._convolutionPaddingType != rhs_storage._convolutionPaddingType {return false}
        if _storage._isDeconvolution != rhs_storage._isDeconvolution {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        if _storage._outputShape != rhs_storage._outputShape {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Convolution3DLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Convolution3DLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputChannels"),
    2: .same(proto: "inputChannels"),
    10: .same(proto: "nGroups"),
    20: .same(proto: "kernelDepth"),
    21: .same(proto: "kernelHeight"),
    22: .same(proto: "kernelWidth"),
    31: .same(proto: "strideDepth"),
    32: .same(proto: "strideHeight"),
    33: .same(proto: "strideWidth"),
    40: .same(proto: "dilationDepth"),
    41: .same(proto: "dilationHeight"),
    42: .same(proto: "dilationWidth"),
    50: .same(proto: "hasBias"),
    60: .same(proto: "weights"),
    61: .same(proto: "bias"),
    70: .same(proto: "paddingType"),
    80: .same(proto: "customPaddingFront"),
    81: .same(proto: "customPaddingBack"),
    82: .same(proto: "customPaddingTop"),
    83: .same(proto: "customPaddingBottom"),
    84: .same(proto: "customPaddingLeft"),
    85: .same(proto: "customPaddingRight"),
    86: .same(proto: "isDeconvolution"),
    87: .same(proto: "outputShape"),
  ]

  fileprivate class _StorageClass {
    var _outputChannels: Int32 = 0
    var _inputChannels: Int32 = 0
    var _nGroups: Int32 = 0
    var _kernelDepth: Int32 = 0
    var _kernelHeight: Int32 = 0
    var _kernelWidth: Int32 = 0
    var _strideDepth: Int32 = 0
    var _strideHeight: Int32 = 0
    var _strideWidth: Int32 = 0
    var _dilationDepth: Int32 = 0
    var _dilationHeight: Int32 = 0
    var _dilationWidth: Int32 = 0
    var _hasBias_p: Bool = false
    var _weights: WeightParams? = nil
    var _bias: WeightParams? = nil
    var _paddingType: Convolution3DLayerParams.PaddingType = .custom
    var _customPaddingFront: Int32 = 0
    var _customPaddingBack: Int32 = 0
    var _customPaddingTop: Int32 = 0
    var _customPaddingBottom: Int32 = 0
    var _customPaddingLeft: Int32 = 0
    var _customPaddingRight: Int32 = 0
    var _isDeconvolution: Bool = false
    var _outputShape: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _outputChannels = source._outputChannels
      _inputChannels = source._inputChannels
      _nGroups = source._nGroups
      _kernelDepth = source._kernelDepth
      _kernelHeight = source._kernelHeight
      _kernelWidth = source._kernelWidth
      _strideDepth = source._strideDepth
      _strideHeight = source._strideHeight
      _strideWidth = source._strideWidth
      _dilationDepth = source._dilationDepth
      _dilationHeight = source._dilationHeight
      _dilationWidth = source._dilationWidth
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
      _paddingType = source._paddingType
      _customPaddingFront = source._customPaddingFront
      _customPaddingBack = source._customPaddingBack
      _customPaddingTop = source._customPaddingTop
      _customPaddingBottom = source._customPaddingBottom
      _customPaddingLeft = source._customPaddingLeft
      _customPaddingRight = source._customPaddingRight
      _isDeconvolution = source._isDeconvolution
      _outputShape = source._outputShape
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._outputChannels) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._inputChannels) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._nGroups) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._kernelDepth) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._kernelHeight) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._kernelWidth) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._strideDepth) }()
        case 32: try { try decoder.decodeSingularInt32Field(value: &_storage._strideHeight) }()
        case 33: try { try decoder.decodeSingularInt32Field(value: &_storage._strideWidth) }()
        case 40: try { try decoder.decodeSingularInt32Field(value: &_storage._dilationDepth) }()
        case 41: try { try decoder.decodeSingularInt32Field(value: &_storage._dilationHeight) }()
        case 42: try { try decoder.decodeSingularInt32Field(value: &_storage._dilationWidth) }()
        case 50: try { try decoder.decodeSingularBoolField(value: &_storage._hasBias_p) }()
        case 60: try { try decoder.decodeSingularMessageField(value: &_storage._weights) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._bias) }()
        case 70: try { try decoder.decodeSingularEnumField(value: &_storage._paddingType) }()
        case 80: try { try decoder.decodeSingularInt32Field(value: &_storage._customPaddingFront) }()
        case 81: try { try decoder.decodeSingularInt32Field(value: &_storage._customPaddingBack) }()
        case 82: try { try decoder.decodeSingularInt32Field(value: &_storage._customPaddingTop) }()
        case 83: try { try decoder.decodeSingularInt32Field(value: &_storage._customPaddingBottom) }()
        case 84: try { try decoder.decodeSingularInt32Field(value: &_storage._customPaddingLeft) }()
        case 85: try { try decoder.decodeSingularInt32Field(value: &_storage._customPaddingRight) }()
        case 86: try { try decoder.decodeSingularBoolField(value: &_storage._isDeconvolution) }()
        case 87: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._outputShape) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._outputChannels != 0 {
        try visitor.visitSingularInt32Field(value: _storage._outputChannels, fieldNumber: 1)
      }
      if _storage._inputChannels != 0 {
        try visitor.visitSingularInt32Field(value: _storage._inputChannels, fieldNumber: 2)
      }
      if _storage._nGroups != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nGroups, fieldNumber: 10)
      }
      if _storage._kernelDepth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._kernelDepth, fieldNumber: 20)
      }
      if _storage._kernelHeight != 0 {
        try visitor.visitSingularInt32Field(value: _storage._kernelHeight, fieldNumber: 21)
      }
      if _storage._kernelWidth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._kernelWidth, fieldNumber: 22)
      }
      if _storage._strideDepth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._strideDepth, fieldNumber: 31)
      }
      if _storage._strideHeight != 0 {
        try visitor.visitSingularInt32Field(value: _storage._strideHeight, fieldNumber: 32)
      }
      if _storage._strideWidth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._strideWidth, fieldNumber: 33)
      }
      if _storage._dilationDepth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dilationDepth, fieldNumber: 40)
      }
      if _storage._dilationHeight != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dilationHeight, fieldNumber: 41)
      }
      if _storage._dilationWidth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dilationWidth, fieldNumber: 42)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 50)
      }
      try { if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
      if _storage._paddingType != .custom {
        try visitor.visitSingularEnumField(value: _storage._paddingType, fieldNumber: 70)
      }
      if _storage._customPaddingFront != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customPaddingFront, fieldNumber: 80)
      }
      if _storage._customPaddingBack != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customPaddingBack, fieldNumber: 81)
      }
      if _storage._customPaddingTop != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customPaddingTop, fieldNumber: 82)
      }
      if _storage._customPaddingBottom != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customPaddingBottom, fieldNumber: 83)
      }
      if _storage._customPaddingLeft != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customPaddingLeft, fieldNumber: 84)
      }
      if _storage._customPaddingRight != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customPaddingRight, fieldNumber: 85)
      }
      if _storage._isDeconvolution != false {
        try visitor.visitSingularBoolField(value: _storage._isDeconvolution, fieldNumber: 86)
      }
      if !_storage._outputShape.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._outputShape, fieldNumber: 87)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Convolution3DLayerParams, rhs: Convolution3DLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._outputChannels != rhs_storage._outputChannels {return false}
        if _storage._inputChannels != rhs_storage._inputChannels {return false}
        if _storage._nGroups != rhs_storage._nGroups {return false}
        if _storage._kernelDepth != rhs_storage._kernelDepth {return false}
        if _storage._kernelHeight != rhs_storage._kernelHeight {return false}
        if _storage._kernelWidth != rhs_storage._kernelWidth {return false}
        if _storage._strideDepth != rhs_storage._strideDepth {return false}
        if _storage._strideHeight != rhs_storage._strideHeight {return false}
        if _storage._strideWidth != rhs_storage._strideWidth {return false}
        if _storage._dilationDepth != rhs_storage._dilationDepth {return false}
        if _storage._dilationHeight != rhs_storage._dilationHeight {return false}
        if _storage._dilationWidth != rhs_storage._dilationWidth {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        if _storage._paddingType != rhs_storage._paddingType {return false}
        if _storage._customPaddingFront != rhs_storage._customPaddingFront {return false}
        if _storage._customPaddingBack != rhs_storage._customPaddingBack {return false}
        if _storage._customPaddingTop != rhs_storage._customPaddingTop {return false}
        if _storage._customPaddingBottom != rhs_storage._customPaddingBottom {return false}
        if _storage._customPaddingLeft != rhs_storage._customPaddingLeft {return false}
        if _storage._customPaddingRight != rhs_storage._customPaddingRight {return false}
        if _storage._isDeconvolution != rhs_storage._isDeconvolution {return false}
        if _storage._outputShape != rhs_storage._outputShape {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Convolution3DLayerParams.PaddingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    1: .same(proto: "VALID"),
    2: .same(proto: "SAME"),
  ]
}

extension InnerProductLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InnerProductLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputChannels"),
    2: .same(proto: "outputChannels"),
    10: .same(proto: "hasBias"),
    20: .same(proto: "weights"),
    21: .same(proto: "bias"),
    22: .same(proto: "int8DynamicQuantize"),
  ]

  fileprivate class _StorageClass {
    var _inputChannels: UInt64 = 0
    var _outputChannels: UInt64 = 0
    var _hasBias_p: Bool = false
    var _weights: WeightParams? = nil
    var _bias: WeightParams? = nil
    var _int8DynamicQuantize: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputChannels = source._inputChannels
      _outputChannels = source._outputChannels
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
      _int8DynamicQuantize = source._int8DynamicQuantize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._inputChannels) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._hasBias_p) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._weights) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._bias) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._int8DynamicQuantize) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._inputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputChannels, fieldNumber: 1)
      }
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 10)
      }
      try { if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if _storage._int8DynamicQuantize != false {
        try visitor.visitSingularBoolField(value: _storage._int8DynamicQuantize, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InnerProductLayerParams, rhs: InnerProductLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputChannels != rhs_storage._inputChannels {return false}
        if _storage._outputChannels != rhs_storage._outputChannels {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        if _storage._int8DynamicQuantize != rhs_storage._int8DynamicQuantize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EmbeddingLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmbeddingLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputDim"),
    2: .same(proto: "outputChannels"),
    10: .same(proto: "hasBias"),
    20: .same(proto: "weights"),
    21: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _inputDim: UInt64 = 0
    var _outputChannels: UInt64 = 0
    var _hasBias_p: Bool = false
    var _weights: WeightParams? = nil
    var _bias: WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputDim = source._inputDim
      _outputChannels = source._outputChannels
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._inputDim) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._outputChannels) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._hasBias_p) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._weights) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._bias) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._inputDim != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputDim, fieldNumber: 1)
      }
      if _storage._outputChannels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputChannels, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 10)
      }
      try { if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EmbeddingLayerParams, rhs: EmbeddingLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputDim != rhs_storage._inputDim {return false}
        if _storage._outputChannels != rhs_storage._outputChannels {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EmbeddingNDLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmbeddingNDLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vocabSize"),
    2: .same(proto: "embeddingSize"),
    3: .same(proto: "hasBias"),
    20: .same(proto: "weights"),
    21: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _vocabSize: UInt64 = 0
    var _embeddingSize: UInt64 = 0
    var _hasBias_p: Bool = false
    var _weights: WeightParams? = nil
    var _bias: WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _vocabSize = source._vocabSize
      _embeddingSize = source._embeddingSize
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._vocabSize) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._embeddingSize) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._hasBias_p) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._weights) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._bias) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._vocabSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._vocabSize, fieldNumber: 1)
      }
      if _storage._embeddingSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._embeddingSize, fieldNumber: 2)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 3)
      }
      try { if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EmbeddingNDLayerParams, rhs: EmbeddingNDLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._vocabSize != rhs_storage._vocabSize {return false}
        if _storage._embeddingSize != rhs_storage._embeddingSize {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BatchnormLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchnormLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
    5: .same(proto: "computeMeanVar"),
    6: .same(proto: "instanceNormalization"),
    10: .same(proto: "epsilon"),
    15: .same(proto: "gamma"),
    16: .same(proto: "beta"),
    17: .same(proto: "mean"),
    18: .same(proto: "variance"),
  ]

  fileprivate class _StorageClass {
    var _channels: UInt64 = 0
    var _computeMeanVar: Bool = false
    var _instanceNormalization: Bool = false
    var _epsilon: Float = 0
    var _gamma: WeightParams? = nil
    var _beta: WeightParams? = nil
    var _mean: WeightParams? = nil
    var _variance: WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channels = source._channels
      _computeMeanVar = source._computeMeanVar
      _instanceNormalization = source._instanceNormalization
      _epsilon = source._epsilon
      _gamma = source._gamma
      _beta = source._beta
      _mean = source._mean
      _variance = source._variance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._channels) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._computeMeanVar) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._instanceNormalization) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._epsilon) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._gamma) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._beta) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._mean) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._variance) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._channels != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._channels, fieldNumber: 1)
      }
      if _storage._computeMeanVar != false {
        try visitor.visitSingularBoolField(value: _storage._computeMeanVar, fieldNumber: 5)
      }
      if _storage._instanceNormalization != false {
        try visitor.visitSingularBoolField(value: _storage._instanceNormalization, fieldNumber: 6)
      }
      if _storage._epsilon != 0 {
        try visitor.visitSingularFloatField(value: _storage._epsilon, fieldNumber: 10)
      }
      try { if let v = _storage._gamma {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._beta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._mean {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._variance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BatchnormLayerParams, rhs: BatchnormLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channels != rhs_storage._channels {return false}
        if _storage._computeMeanVar != rhs_storage._computeMeanVar {return false}
        if _storage._instanceNormalization != rhs_storage._instanceNormalization {return false}
        if _storage._epsilon != rhs_storage._epsilon {return false}
        if _storage._gamma != rhs_storage._gamma {return false}
        if _storage._beta != rhs_storage._beta {return false}
        if _storage._mean != rhs_storage._mean {return false}
        if _storage._variance != rhs_storage._variance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PoolingLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoolingLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    10: .same(proto: "kernelSize"),
    20: .same(proto: "stride"),
    30: .same(proto: "valid"),
    31: .same(proto: "same"),
    32: .same(proto: "includeLastPixel"),
    50: .same(proto: "avgPoolExcludePadding"),
    60: .same(proto: "globalPooling"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 10: try { try decoder.decodeRepeatedUInt64Field(value: &self.kernelSize) }()
      case 20: try { try decoder.decodeRepeatedUInt64Field(value: &self.stride) }()
      case 30: try {
        var v: ValidPadding?
        var hadOneofValue = false
        if let current = self.poolingPaddingType {
          hadOneofValue = true
          if case .valid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.poolingPaddingType = .valid(v)
        }
      }()
      case 31: try {
        var v: SamePadding?
        var hadOneofValue = false
        if let current = self.poolingPaddingType {
          hadOneofValue = true
          if case .same(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.poolingPaddingType = .same(v)
        }
      }()
      case 32: try {
        var v: PoolingLayerParams.ValidCompletePadding?
        var hadOneofValue = false
        if let current = self.poolingPaddingType {
          hadOneofValue = true
          if case .includeLastPixel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.poolingPaddingType = .includeLastPixel(v)
        }
      }()
      case 50: try { try decoder.decodeSingularBoolField(value: &self.avgPoolExcludePadding) }()
      case 60: try { try decoder.decodeSingularBoolField(value: &self.globalPooling) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .max {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.kernelSize.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.kernelSize, fieldNumber: 10)
    }
    if !self.stride.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.stride, fieldNumber: 20)
    }
    switch self.poolingPaddingType {
    case .valid?: try {
      guard case .valid(let v)? = self.poolingPaddingType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .same?: try {
      guard case .same(let v)? = self.poolingPaddingType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .includeLastPixel?: try {
      guard case .includeLastPixel(let v)? = self.poolingPaddingType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case nil: break
    }
    if self.avgPoolExcludePadding != false {
      try visitor.visitSingularBoolField(value: self.avgPoolExcludePadding, fieldNumber: 50)
    }
    if self.globalPooling != false {
      try visitor.visitSingularBoolField(value: self.globalPooling, fieldNumber: 60)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PoolingLayerParams, rhs: PoolingLayerParams) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.kernelSize != rhs.kernelSize {return false}
    if lhs.stride != rhs.stride {return false}
    if lhs.poolingPaddingType != rhs.poolingPaddingType {return false}
    if lhs.avgPoolExcludePadding != rhs.avgPoolExcludePadding {return false}
    if lhs.globalPooling != rhs.globalPooling {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PoolingLayerParams.PoolingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAX"),
    1: .same(proto: "AVERAGE"),
    2: .same(proto: "L2"),
  ]
}

extension PoolingLayerParams.ValidCompletePadding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PoolingLayerParams.protoMessageName + ".ValidCompletePadding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "paddingAmounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try { try decoder.decodeRepeatedUInt64Field(value: &self.paddingAmounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paddingAmounts.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.paddingAmounts, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PoolingLayerParams.ValidCompletePadding, rhs: PoolingLayerParams.ValidCompletePadding) -> Bool {
    if lhs.paddingAmounts != rhs.paddingAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pooling3DLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pooling3DLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "kernelDepth"),
    3: .same(proto: "kernelHeight"),
    4: .same(proto: "kernelWidth"),
    5: .same(proto: "strideDepth"),
    6: .same(proto: "strideHeight"),
    7: .same(proto: "strideWidth"),
    15: .same(proto: "paddingType"),
    8: .same(proto: "customPaddingFront"),
    9: .same(proto: "customPaddingBack"),
    10: .same(proto: "customPaddingTop"),
    11: .same(proto: "customPaddingBottom"),
    12: .same(proto: "customPaddingLeft"),
    13: .same(proto: "customPaddingRight"),
    14: .same(proto: "countExcludePadding"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.kernelDepth) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.kernelHeight) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.kernelWidth) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.strideDepth) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.strideHeight) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.strideWidth) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.customPaddingFront) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.customPaddingBack) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.customPaddingTop) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.customPaddingBottom) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.customPaddingLeft) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.customPaddingRight) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.countExcludePadding) }()
      case 15: try { try decoder.decodeSingularEnumField(value: &self.paddingType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .max {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.kernelDepth != 0 {
      try visitor.visitSingularInt32Field(value: self.kernelDepth, fieldNumber: 2)
    }
    if self.kernelHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.kernelHeight, fieldNumber: 3)
    }
    if self.kernelWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.kernelWidth, fieldNumber: 4)
    }
    if self.strideDepth != 0 {
      try visitor.visitSingularInt32Field(value: self.strideDepth, fieldNumber: 5)
    }
    if self.strideHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.strideHeight, fieldNumber: 6)
    }
    if self.strideWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.strideWidth, fieldNumber: 7)
    }
    if self.customPaddingFront != 0 {
      try visitor.visitSingularInt32Field(value: self.customPaddingFront, fieldNumber: 8)
    }
    if self.customPaddingBack != 0 {
      try visitor.visitSingularInt32Field(value: self.customPaddingBack, fieldNumber: 9)
    }
    if self.customPaddingTop != 0 {
      try visitor.visitSingularInt32Field(value: self.customPaddingTop, fieldNumber: 10)
    }
    if self.customPaddingBottom != 0 {
      try visitor.visitSingularInt32Field(value: self.customPaddingBottom, fieldNumber: 11)
    }
    if self.customPaddingLeft != 0 {
      try visitor.visitSingularInt32Field(value: self.customPaddingLeft, fieldNumber: 12)
    }
    if self.customPaddingRight != 0 {
      try visitor.visitSingularInt32Field(value: self.customPaddingRight, fieldNumber: 13)
    }
    if self.countExcludePadding != false {
      try visitor.visitSingularBoolField(value: self.countExcludePadding, fieldNumber: 14)
    }
    if self.paddingType != .custom {
      try visitor.visitSingularEnumField(value: self.paddingType, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pooling3DLayerParams, rhs: Pooling3DLayerParams) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.kernelDepth != rhs.kernelDepth {return false}
    if lhs.kernelHeight != rhs.kernelHeight {return false}
    if lhs.kernelWidth != rhs.kernelWidth {return false}
    if lhs.strideDepth != rhs.strideDepth {return false}
    if lhs.strideHeight != rhs.strideHeight {return false}
    if lhs.strideWidth != rhs.strideWidth {return false}
    if lhs.paddingType != rhs.paddingType {return false}
    if lhs.customPaddingFront != rhs.customPaddingFront {return false}
    if lhs.customPaddingBack != rhs.customPaddingBack {return false}
    if lhs.customPaddingTop != rhs.customPaddingTop {return false}
    if lhs.customPaddingBottom != rhs.customPaddingBottom {return false}
    if lhs.customPaddingLeft != rhs.customPaddingLeft {return false}
    if lhs.customPaddingRight != rhs.customPaddingRight {return false}
    if lhs.countExcludePadding != rhs.countExcludePadding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pooling3DLayerParams.PoolingType3D: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAX"),
    1: .same(proto: "AVERAGE"),
  ]
}

extension Pooling3DLayerParams.Pooling3DPaddingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    1: .same(proto: "VALID"),
    2: .same(proto: "SAME"),
  ]
}

extension GlobalPooling3DLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GlobalPooling3DLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .max {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GlobalPooling3DLayerParams, rhs: GlobalPooling3DLayerParams) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GlobalPooling3DLayerParams.GlobalPoolingType3D: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAX"),
    1: .same(proto: "AVERAGE"),
  ]
}

extension PaddingLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaddingLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "constant"),
    2: .same(proto: "reflection"),
    3: .same(proto: "replication"),
    10: .same(proto: "paddingAmounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PaddingLayerParams.PaddingConstant?
        var hadOneofValue = false
        if let current = self.paddingType {
          hadOneofValue = true
          if case .constant(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.paddingType = .constant(v)
        }
      }()
      case 2: try {
        var v: PaddingLayerParams.PaddingReflection?
        var hadOneofValue = false
        if let current = self.paddingType {
          hadOneofValue = true
          if case .reflection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.paddingType = .reflection(v)
        }
      }()
      case 3: try {
        var v: PaddingLayerParams.PaddingReplication?
        var hadOneofValue = false
        if let current = self.paddingType {
          hadOneofValue = true
          if case .replication(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.paddingType = .replication(v)
        }
      }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._paddingAmounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.paddingType {
    case .constant?: try {
      guard case .constant(let v)? = self.paddingType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .reflection?: try {
      guard case .reflection(let v)? = self.paddingType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .replication?: try {
      guard case .replication(let v)? = self.paddingType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._paddingAmounts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PaddingLayerParams, rhs: PaddingLayerParams) -> Bool {
    if lhs.paddingType != rhs.paddingType {return false}
    if lhs._paddingAmounts != rhs._paddingAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PaddingLayerParams.PaddingConstant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PaddingLayerParams.protoMessageName + ".PaddingConstant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PaddingLayerParams.PaddingConstant, rhs: PaddingLayerParams.PaddingConstant) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PaddingLayerParams.PaddingReflection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PaddingLayerParams.protoMessageName + ".PaddingReflection"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PaddingLayerParams.PaddingReflection, rhs: PaddingLayerParams.PaddingReflection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PaddingLayerParams.PaddingReplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PaddingLayerParams.protoMessageName + ".PaddingReplication"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PaddingLayerParams.PaddingReplication, rhs: PaddingLayerParams.PaddingReplication) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConcatLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConcatLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .same(proto: "sequenceConcat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 100: try { try decoder.decodeSingularBoolField(value: &self.sequenceConcat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceConcat != false {
      try visitor.visitSingularBoolField(value: self.sequenceConcat, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConcatLayerParams, rhs: ConcatLayerParams) -> Bool {
    if lhs.sequenceConcat != rhs.sequenceConcat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LRNLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LRNLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
    3: .same(proto: "localSize"),
    4: .same(proto: "k"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.beta) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.localSize) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.k) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    if self.localSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.localSize, fieldNumber: 3)
    }
    if self.k != 0 {
      try visitor.visitSingularFloatField(value: self.k, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LRNLayerParams, rhs: LRNLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.localSize != rhs.localSize {return false}
    if lhs.k != rhs.k {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SoftmaxLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SoftmaxLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SoftmaxLayerParams, rhs: SoftmaxLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SplitLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SplitLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nOutputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nOutputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nOutputs != 0 {
      try visitor.visitSingularUInt64Field(value: self.nOutputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SplitLayerParams, rhs: SplitLayerParams) -> Bool {
    if lhs.nOutputs != rhs.nOutputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddLayerParams, rhs: AddLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultiplyLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiplyLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultiplyLayerParams, rhs: MultiplyLayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnaryFunctionLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnaryFunctionLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "alpha"),
    3: .same(proto: "epsilon"),
    4: .same(proto: "shift"),
    5: .same(proto: "scale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.epsilon) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.shift) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .sqrt {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 2)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 3)
    }
    if self.shift != 0 {
      try visitor.visitSingularFloatField(value: self.shift, fieldNumber: 4)
    }
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UnaryFunctionLayerParams, rhs: UnaryFunctionLayerParams) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.shift != rhs.shift {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnaryFunctionLayerParams.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SQRT"),
    1: .same(proto: "RSQRT"),
    2: .same(proto: "INVERSE"),
    3: .same(proto: "POWER"),
    4: .same(proto: "EXP"),
    5: .same(proto: "LOG"),
    6: .same(proto: "ABS"),
    7: .same(proto: "THRESHOLD"),
  ]
}

extension UpsampleLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpsampleLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scalingFactor"),
    7: .same(proto: "fractionalScalingFactor"),
    5: .same(proto: "mode"),
    6: .same(proto: "linearUpsampleMode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.scalingFactor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.linearUpsampleMode) }()
      case 7: try { try decoder.decodeRepeatedFloatField(value: &self.fractionalScalingFactor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scalingFactor.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.scalingFactor, fieldNumber: 1)
    }
    if self.mode != .nn {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 5)
    }
    if self.linearUpsampleMode != .default {
      try visitor.visitSingularEnumField(value: self.linearUpsampleMode, fieldNumber: 6)
    }
    if !self.fractionalScalingFactor.isEmpty {
      try visitor.visitPackedFloatField(value: self.fractionalScalingFactor, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpsampleLayerParams, rhs: UpsampleLayerParams) -> Bool {
    if lhs.scalingFactor != rhs.scalingFactor {return false}
    if lhs.fractionalScalingFactor != rhs.fractionalScalingFactor {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.linearUpsampleMode != rhs.linearUpsampleMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpsampleLayerParams.InterpolationMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NN"),
    1: .same(proto: "BILINEAR"),
  ]
}

extension UpsampleLayerParams.LinearUpsampleMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "ALIGN_CORNERS_TRUE"),
    2: .same(proto: "ALIGN_CORNERS_FALSE"),
  ]
}

extension ResizeBilinearLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResizeBilinearLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSize"),
    2: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.targetSize) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetSize.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.targetSize, fieldNumber: 1)
    }
    try { if let v = self._mode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ResizeBilinearLayerParams, rhs: ResizeBilinearLayerParams) -> Bool {
    if lhs.targetSize != rhs.targetSize {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CropResizeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CropResizeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSize"),
    2: .same(proto: "normalizedCoordinates"),
    3: .same(proto: "mode"),
    4: .same(proto: "boxIndicesMode"),
    5: .same(proto: "spatialScale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.targetSize) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.normalizedCoordinates) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mode) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._boxIndicesMode) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.spatialScale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetSize.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.targetSize, fieldNumber: 1)
    }
    if self.normalizedCoordinates != false {
      try visitor.visitSingularBoolField(value: self.normalizedCoordinates, fieldNumber: 2)
    }
    try { if let v = self._mode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._boxIndicesMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.spatialScale != 0 {
      try visitor.visitSingularFloatField(value: self.spatialScale, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CropResizeLayerParams, rhs: CropResizeLayerParams) -> Bool {
    if lhs.targetSize != rhs.targetSize {return false}
    if lhs.normalizedCoordinates != rhs.normalizedCoordinates {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs._boxIndicesMode != rhs._boxIndicesMode {return false}
    if lhs.spatialScale != rhs.spatialScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BiasLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BiasLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "bias"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.shape) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bias) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shape.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.shape, fieldNumber: 1)
    }
    try { if let v = self._bias {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BiasLayerParams, rhs: BiasLayerParams) -> Bool {
    if lhs.shape != rhs.shape {return false}
    if lhs._bias != rhs._bias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ScaleLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScaleLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shapeScale"),
    2: .same(proto: "scale"),
    3: .same(proto: "hasBias"),
    4: .same(proto: "shapeBias"),
    5: .same(proto: "bias"),
  ]

  fileprivate class _StorageClass {
    var _shapeScale: [UInt64] = []
    var _scale: WeightParams? = nil
    var _hasBias_p: Bool = false
    var _shapeBias: [UInt64] = []
    var _bias: WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shapeScale = source._shapeScale
      _scale = source._scale
      _hasBias_p = source._hasBias_p
      _shapeBias = source._shapeBias
      _bias = source._bias
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._shapeScale) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._scale) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._hasBias_p) }()
        case 4: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._shapeBias) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._bias) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._shapeScale.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shapeScale, fieldNumber: 1)
      }
      try { if let v = _storage._scale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 3)
      }
      if !_storage._shapeBias.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._shapeBias, fieldNumber: 4)
      }
      try { if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ScaleLayerParams, rhs: ScaleLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._shapeScale != rhs_storage._shapeScale {return false}
        if _storage._scale != rhs_storage._scale {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._shapeBias != rhs_storage._shapeBias {return false}
        if _storage._bias != rhs_storage._bias {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoadConstantLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadConstantLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.shape) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shape.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.shape, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LoadConstantLayerParams, rhs: LoadConstantLayerParams) -> Bool {
    if lhs.shape != rhs.shape {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension L2NormalizeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".L2NormalizeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epsilon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.epsilon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: L2NormalizeLayerParams, rhs: L2NormalizeLayerParams) -> Bool {
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FlattenLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FlattenLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .channelFirst {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FlattenLayerParams, rhs: FlattenLayerParams) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FlattenLayerParams.FlattenOrder: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_FIRST"),
    1: .same(proto: "CHANNEL_LAST"),
  ]
}

extension ReshapeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReshapeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetShape"),
    2: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.targetShape) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetShape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.targetShape, fieldNumber: 1)
    }
    if self.mode != .channelFirst {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReshapeLayerParams, rhs: ReshapeLayerParams) -> Bool {
    if lhs.targetShape != rhs.targetShape {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReshapeLayerParams.ReshapeOrder: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_FIRST"),
    1: .same(proto: "CHANNEL_LAST"),
  ]
}

extension PermuteLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PermuteLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axis.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.axis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermuteLayerParams, rhs: PermuteLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReorganizeDataLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReorganizeDataLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "blockSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.blockSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .spaceToDepth {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.blockSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReorganizeDataLayerParams, rhs: ReorganizeDataLayerParams) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.blockSize != rhs.blockSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReorganizeDataLayerParams.ReorganizationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPACE_TO_DEPTH"),
    1: .same(proto: "DEPTH_TO_SPACE"),
    2: .same(proto: "PIXEL_SHUFFLE"),
  ]
}

extension SliceLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SliceLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startIndex"),
    2: .same(proto: "endIndex"),
    3: .same(proto: "stride"),
    4: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endIndex) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.stride) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.startIndex, fieldNumber: 1)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.endIndex, fieldNumber: 2)
    }
    if self.stride != 0 {
      try visitor.visitSingularUInt64Field(value: self.stride, fieldNumber: 3)
    }
    if self.axis != .channelAxis {
      try visitor.visitSingularEnumField(value: self.axis, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SliceLayerParams, rhs: SliceLayerParams) -> Bool {
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.stride != rhs.stride {return false}
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SliceLayerParams.SliceAxis: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_AXIS"),
    1: .same(proto: "HEIGHT_AXIS"),
    2: .same(proto: "WIDTH_AXIS"),
  ]
}

extension ReduceLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "epsilon"),
    3: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.epsilon) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .sum {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 2)
    }
    if self.axis != .chw {
      try visitor.visitSingularEnumField(value: self.axis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceLayerParams, rhs: ReduceLayerParams) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceLayerParams.ReduceOperation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUM"),
    1: .same(proto: "AVG"),
    2: .same(proto: "PROD"),
    3: .same(proto: "LOGSUM"),
    4: .same(proto: "SUMSQUARE"),
    5: .same(proto: "L1"),
    6: .same(proto: "L2"),
    7: .same(proto: "MAX"),
    8: .same(proto: "MIN"),
    9: .same(proto: "ARGMAX"),
  ]
}

extension ReduceLayerParams.ReduceAxis: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHW"),
    1: .same(proto: "HW"),
    2: .same(proto: "C"),
    3: .same(proto: "H"),
    4: .same(proto: "W"),
  ]
}

extension CropLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CropLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cropAmounts"),
    5: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cropAmounts) }()
      case 5: try { try decoder.decodeRepeatedUInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cropAmounts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.offset.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.offset, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CropLayerParams, rhs: CropLayerParams) -> Bool {
    if lhs._cropAmounts != rhs._cropAmounts {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AverageLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AverageLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AverageLayerParams, rhs: AverageLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MaxLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaxLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MaxLayerParams, rhs: MaxLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MinLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinLayerParams, rhs: MinLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DotProductLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DotProductLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cosineSimilarity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.cosineSimilarity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cosineSimilarity != false {
      try visitor.visitSingularBoolField(value: self.cosineSimilarity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DotProductLayerParams, rhs: DotProductLayerParams) -> Bool {
    if lhs.cosineSimilarity != rhs.cosineSimilarity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeanVarianceNormalizeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MeanVarianceNormalizeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "acrossChannels"),
    2: .same(proto: "normalizeVariance"),
    3: .same(proto: "epsilon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.acrossChannels) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.normalizeVariance) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.epsilon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.acrossChannels != false {
      try visitor.visitSingularBoolField(value: self.acrossChannels, fieldNumber: 1)
    }
    if self.normalizeVariance != false {
      try visitor.visitSingularBoolField(value: self.normalizeVariance, fieldNumber: 2)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MeanVarianceNormalizeLayerParams, rhs: MeanVarianceNormalizeLayerParams) -> Bool {
    if lhs.acrossChannels != rhs.acrossChannels {return false}
    if lhs.normalizeVariance != rhs.normalizeVariance {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SequenceRepeatLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SequenceRepeatLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nRepetitions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nRepetitions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nRepetitions != 0 {
      try visitor.visitSingularUInt64Field(value: self.nRepetitions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SequenceRepeatLayerParams, rhs: SequenceRepeatLayerParams) -> Bool {
    if lhs.nRepetitions != rhs.nRepetitions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SimpleRecurrentLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SimpleRecurrentLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activation"),
    15: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVector"),
    30: .same(proto: "weightMatrix"),
    31: .same(proto: "recursionMatrix"),
    32: .same(proto: "biasVector"),
    100: .same(proto: "reverseInput"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activation: ActivationParams? = nil
    var _sequenceOutput: Bool = false
    var _hasBiasVector_p: Bool = false
    var _weightMatrix: WeightParams? = nil
    var _recursionMatrix: WeightParams? = nil
    var _biasVector: WeightParams? = nil
    var _reverseInput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activation = source._activation
      _sequenceOutput = source._sequenceOutput
      _hasBiasVector_p = source._hasBiasVector_p
      _weightMatrix = source._weightMatrix
      _recursionMatrix = source._recursionMatrix
      _biasVector = source._biasVector
      _reverseInput = source._reverseInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._activation) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._sequenceOutput) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._hasBiasVector_p) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._weightMatrix) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._recursionMatrix) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._biasVector) }()
        case 100: try { try decoder.decodeSingularBoolField(value: &_storage._reverseInput) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      try { if let v = _storage._activation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._sequenceOutput != false {
        try visitor.visitSingularBoolField(value: _storage._sequenceOutput, fieldNumber: 15)
      }
      if _storage._hasBiasVector_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBiasVector_p, fieldNumber: 20)
      }
      try { if let v = _storage._weightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._recursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._biasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      if _storage._reverseInput != false {
        try visitor.visitSingularBoolField(value: _storage._reverseInput, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SimpleRecurrentLayerParams, rhs: SimpleRecurrentLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputVectorSize != rhs_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != rhs_storage._outputVectorSize {return false}
        if _storage._activation != rhs_storage._activation {return false}
        if _storage._sequenceOutput != rhs_storage._sequenceOutput {return false}
        if _storage._hasBiasVector_p != rhs_storage._hasBiasVector_p {return false}
        if _storage._weightMatrix != rhs_storage._weightMatrix {return false}
        if _storage._recursionMatrix != rhs_storage._recursionMatrix {return false}
        if _storage._biasVector != rhs_storage._biasVector {return false}
        if _storage._reverseInput != rhs_storage._reverseInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRULayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GRULayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activations"),
    15: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVectors"),
    30: .same(proto: "updateGateWeightMatrix"),
    31: .same(proto: "resetGateWeightMatrix"),
    32: .same(proto: "outputGateWeightMatrix"),
    50: .same(proto: "updateGateRecursionMatrix"),
    51: .same(proto: "resetGateRecursionMatrix"),
    52: .same(proto: "outputGateRecursionMatrix"),
    70: .same(proto: "updateGateBiasVector"),
    71: .same(proto: "resetGateBiasVector"),
    72: .same(proto: "outputGateBiasVector"),
    100: .same(proto: "reverseInput"),
  ]

  fileprivate class _StorageClass {
    var _inputVectorSize: UInt64 = 0
    var _outputVectorSize: UInt64 = 0
    var _activations: [ActivationParams] = []
    var _sequenceOutput: Bool = false
    var _hasBiasVectors_p: Bool = false
    var _updateGateWeightMatrix: WeightParams? = nil
    var _resetGateWeightMatrix: WeightParams? = nil
    var _outputGateWeightMatrix: WeightParams? = nil
    var _updateGateRecursionMatrix: WeightParams? = nil
    var _resetGateRecursionMatrix: WeightParams? = nil
    var _outputGateRecursionMatrix: WeightParams? = nil
    var _updateGateBiasVector: WeightParams? = nil
    var _resetGateBiasVector: WeightParams? = nil
    var _outputGateBiasVector: WeightParams? = nil
    var _reverseInput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputVectorSize = source._inputVectorSize
      _outputVectorSize = source._outputVectorSize
      _activations = source._activations
      _sequenceOutput = source._sequenceOutput
      _hasBiasVectors_p = source._hasBiasVectors_p
      _updateGateWeightMatrix = source._updateGateWeightMatrix
      _resetGateWeightMatrix = source._resetGateWeightMatrix
      _outputGateWeightMatrix = source._outputGateWeightMatrix
      _updateGateRecursionMatrix = source._updateGateRecursionMatrix
      _resetGateRecursionMatrix = source._resetGateRecursionMatrix
      _outputGateRecursionMatrix = source._outputGateRecursionMatrix
      _updateGateBiasVector = source._updateGateBiasVector
      _resetGateBiasVector = source._resetGateBiasVector
      _outputGateBiasVector = source._outputGateBiasVector
      _reverseInput = source._reverseInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._inputVectorSize) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._outputVectorSize) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._activations) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._sequenceOutput) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._hasBiasVectors_p) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._updateGateWeightMatrix) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._resetGateWeightMatrix) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._outputGateWeightMatrix) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._updateGateRecursionMatrix) }()
        case 51: try { try decoder.decodeSingularMessageField(value: &_storage._resetGateRecursionMatrix) }()
        case 52: try { try decoder.decodeSingularMessageField(value: &_storage._outputGateRecursionMatrix) }()
        case 70: try { try decoder.decodeSingularMessageField(value: &_storage._updateGateBiasVector) }()
        case 71: try { try decoder.decodeSingularMessageField(value: &_storage._resetGateBiasVector) }()
        case 72: try { try decoder.decodeSingularMessageField(value: &_storage._outputGateBiasVector) }()
        case 100: try { try decoder.decodeSingularBoolField(value: &_storage._reverseInput) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._inputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._inputVectorSize, fieldNumber: 1)
      }
      if _storage._outputVectorSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outputVectorSize, fieldNumber: 2)
      }
      if !_storage._activations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activations, fieldNumber: 10)
      }
      if _storage._sequenceOutput != false {
        try visitor.visitSingularBoolField(value: _storage._sequenceOutput, fieldNumber: 15)
      }
      if _storage._hasBiasVectors_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBiasVectors_p, fieldNumber: 20)
      }
      try { if let v = _storage._updateGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._resetGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._outputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._updateGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._resetGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      } }()
      try { if let v = _storage._outputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      } }()
      try { if let v = _storage._updateGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      } }()
      try { if let v = _storage._resetGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      } }()
      try { if let v = _storage._outputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      } }()
      if _storage._reverseInput != false {
        try visitor.visitSingularBoolField(value: _storage._reverseInput, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GRULayerParams, rhs: GRULayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputVectorSize != rhs_storage._inputVectorSize {return false}
        if _storage._outputVectorSize != rhs_storage._outputVectorSize {return false}
        if _storage._activations != rhs_storage._activations {return false}
        if _storage._sequenceOutput != rhs_storage._sequenceOutput {return false}
        if _storage._hasBiasVectors_p != rhs_storage._hasBiasVectors_p {return false}
        if _storage._updateGateWeightMatrix != rhs_storage._updateGateWeightMatrix {return false}
        if _storage._resetGateWeightMatrix != rhs_storage._resetGateWeightMatrix {return false}
        if _storage._outputGateWeightMatrix != rhs_storage._outputGateWeightMatrix {return false}
        if _storage._updateGateRecursionMatrix != rhs_storage._updateGateRecursionMatrix {return false}
        if _storage._resetGateRecursionMatrix != rhs_storage._resetGateRecursionMatrix {return false}
        if _storage._outputGateRecursionMatrix != rhs_storage._outputGateRecursionMatrix {return false}
        if _storage._updateGateBiasVector != rhs_storage._updateGateBiasVector {return false}
        if _storage._resetGateBiasVector != rhs_storage._resetGateBiasVector {return false}
        if _storage._outputGateBiasVector != rhs_storage._outputGateBiasVector {return false}
        if _storage._reverseInput != rhs_storage._reverseInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LSTMParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LSTMParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "sequenceOutput"),
    20: .same(proto: "hasBiasVectors"),
    30: .same(proto: "forgetBias"),
    40: .same(proto: "hasPeepholeVectors"),
    50: .same(proto: "coupledInputAndForgetGate"),
    60: .same(proto: "cellClipThreshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try { try decoder.decodeSingularBoolField(value: &self.sequenceOutput) }()
      case 20: try { try decoder.decodeSingularBoolField(value: &self.hasBiasVectors_p) }()
      case 30: try { try decoder.decodeSingularBoolField(value: &self.forgetBias) }()
      case 40: try { try decoder.decodeSingularBoolField(value: &self.hasPeepholeVectors_p) }()
      case 50: try { try decoder.decodeSingularBoolField(value: &self.coupledInputAndForgetGate) }()
      case 60: try { try decoder.decodeSingularFloatField(value: &self.cellClipThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceOutput != false {
      try visitor.visitSingularBoolField(value: self.sequenceOutput, fieldNumber: 10)
    }
    if self.hasBiasVectors_p != false {
      try visitor.visitSingularBoolField(value: self.hasBiasVectors_p, fieldNumber: 20)
    }
    if self.forgetBias != false {
      try visitor.visitSingularBoolField(value: self.forgetBias, fieldNumber: 30)
    }
    if self.hasPeepholeVectors_p != false {
      try visitor.visitSingularBoolField(value: self.hasPeepholeVectors_p, fieldNumber: 40)
    }
    if self.coupledInputAndForgetGate != false {
      try visitor.visitSingularBoolField(value: self.coupledInputAndForgetGate, fieldNumber: 50)
    }
    if self.cellClipThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.cellClipThreshold, fieldNumber: 60)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LSTMParams, rhs: LSTMParams) -> Bool {
    if lhs.sequenceOutput != rhs.sequenceOutput {return false}
    if lhs.hasBiasVectors_p != rhs.hasBiasVectors_p {return false}
    if lhs.forgetBias != rhs.forgetBias {return false}
    if lhs.hasPeepholeVectors_p != rhs.hasPeepholeVectors_p {return false}
    if lhs.coupledInputAndForgetGate != rhs.coupledInputAndForgetGate {return false}
    if lhs.cellClipThreshold != rhs.cellClipThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LSTMWeightParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LSTMWeightParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputGateWeightMatrix"),
    2: .same(proto: "forgetGateWeightMatrix"),
    3: .same(proto: "blockInputWeightMatrix"),
    4: .same(proto: "outputGateWeightMatrix"),
    20: .same(proto: "inputGateRecursionMatrix"),
    21: .same(proto: "forgetGateRecursionMatrix"),
    22: .same(proto: "blockInputRecursionMatrix"),
    23: .same(proto: "outputGateRecursionMatrix"),
    40: .same(proto: "inputGateBiasVector"),
    41: .same(proto: "forgetGateBiasVector"),
    42: .same(proto: "blockInputBiasVector"),
    43: .same(proto: "outputGateBiasVector"),
    60: .same(proto: "inputGatePeepholeVector"),
    61: .same(proto: "forgetGatePeepholeVector"),
    62: .same(proto: "outputGatePeepholeVector"),
  ]

  fileprivate class _StorageClass {
    var _inputGateWeightMatrix: WeightParams? = nil
    var _forgetGateWeightMatrix: WeightParams? = nil
    var _blockInputWeightMatrix: WeightParams? = nil
    var _outputGateWeightMatrix: WeightParams? = nil
    var _inputGateRecursionMatrix: WeightParams? = nil
    var _forgetGateRecursionMatrix: WeightParams? = nil
    var _blockInputRecursionMatrix: WeightParams? = nil
    var _outputGateRecursionMatrix: WeightParams? = nil
    var _inputGateBiasVector: WeightParams? = nil
    var _forgetGateBiasVector: WeightParams? = nil
    var _blockInputBiasVector: WeightParams? = nil
    var _outputGateBiasVector: WeightParams? = nil
    var _inputGatePeepholeVector: WeightParams? = nil
    var _forgetGatePeepholeVector: WeightParams? = nil
    var _outputGatePeepholeVector: WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputGateWeightMatrix = source._inputGateWeightMatrix
      _forgetGateWeightMatrix = source._forgetGateWeightMatrix
      _blockInputWeightMatrix = source._blockInputWeightMatrix
      _outputGateWeightMatrix = source._outputGateWeightMatrix
      _inputGateRecursionMatrix = source._inputGateRecursionMatrix
      _forgetGateRecursionMatrix = source._forgetGateRecursionMatrix
      _blockInputRecursionMatrix = source._blockInputRecursionMatrix
      _outputGateRecursionMatrix = source._outputGateRecursionMatrix
      _inputGateBiasVector = source._inputGateBiasVector
      _forgetGateBiasVector = source._forgetGateBiasVector
      _blockInputBiasVector = source._blockInputBiasVector
      _outputGateBiasVector = source._outputGateBiasVector
      _inputGatePeepholeVector = source._inputGatePeepholeVector
      _forgetGatePeepholeVector = source._forgetGatePeepholeVector
      _outputGatePeepholeVector = source._outputGatePeepholeVector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._inputGateWeightMatrix) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._forgetGateWeightMatrix) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._blockInputWeightMatrix) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._outputGateWeightMatrix) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._inputGateRecursionMatrix) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._forgetGateRecursionMatrix) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._blockInputRecursionMatrix) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._outputGateRecursionMatrix) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._inputGateBiasVector) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._forgetGateBiasVector) }()
        case 42: try { try decoder.decodeSingularMessageField(value: &_storage._blockInputBiasVector) }()
        case 43: try { try decoder.decodeSingularMessageField(value: &_storage._outputGateBiasVector) }()
        case 60: try { try decoder.decodeSingularMessageField(value: &_storage._inputGatePeepholeVector) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._forgetGatePeepholeVector) }()
        case 62: try { try decoder.decodeSingularMessageField(value: &_storage._outputGatePeepholeVector) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._inputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._forgetGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._blockInputWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._outputGateWeightMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._inputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._forgetGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._blockInputRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._outputGateRecursionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._inputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._forgetGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._blockInputBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._outputGateBiasVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._inputGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._forgetGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
      try { if let v = _storage._outputGatePeepholeVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LSTMWeightParams, rhs: LSTMWeightParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputGateWeightMatrix != rhs_storage._inputGateWeightMatrix {return false}
        if _storage._forgetGateWeightMatrix != rhs_storage._forgetGateWeightMatrix {return false}
        if _storage._blockInputWeightMatrix != rhs_storage._blockInputWeightMatrix {return false}
        if _storage._outputGateWeightMatrix != rhs_storage._outputGateWeightMatrix {return false}
        if _storage._inputGateRecursionMatrix != rhs_storage._inputGateRecursionMatrix {return false}
        if _storage._forgetGateRecursionMatrix != rhs_storage._forgetGateRecursionMatrix {return false}
        if _storage._blockInputRecursionMatrix != rhs_storage._blockInputRecursionMatrix {return false}
        if _storage._outputGateRecursionMatrix != rhs_storage._outputGateRecursionMatrix {return false}
        if _storage._inputGateBiasVector != rhs_storage._inputGateBiasVector {return false}
        if _storage._forgetGateBiasVector != rhs_storage._forgetGateBiasVector {return false}
        if _storage._blockInputBiasVector != rhs_storage._blockInputBiasVector {return false}
        if _storage._outputGateBiasVector != rhs_storage._outputGateBiasVector {return false}
        if _storage._inputGatePeepholeVector != rhs_storage._inputGatePeepholeVector {return false}
        if _storage._forgetGatePeepholeVector != rhs_storage._forgetGatePeepholeVector {return false}
        if _storage._outputGatePeepholeVector != rhs_storage._outputGatePeepholeVector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UniDirectionalLSTMLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UniDirectionalLSTMLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activations"),
    15: .same(proto: "params"),
    20: .same(proto: "weightParams"),
    100: .same(proto: "reverseInput"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.inputVectorSize) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.outputVectorSize) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.activations) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 20: try { try decoder.decodeSingularMessageField(value: &self._weightParams) }()
      case 100: try { try decoder.decodeSingularBoolField(value: &self.reverseInput) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.inputVectorSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.inputVectorSize, fieldNumber: 1)
    }
    if self.outputVectorSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.outputVectorSize, fieldNumber: 2)
    }
    if !self.activations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activations, fieldNumber: 10)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._weightParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    } }()
    if self.reverseInput != false {
      try visitor.visitSingularBoolField(value: self.reverseInput, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UniDirectionalLSTMLayerParams, rhs: UniDirectionalLSTMLayerParams) -> Bool {
    if lhs.inputVectorSize != rhs.inputVectorSize {return false}
    if lhs.outputVectorSize != rhs.outputVectorSize {return false}
    if lhs.activations != rhs.activations {return false}
    if lhs._params != rhs._params {return false}
    if lhs._weightParams != rhs._weightParams {return false}
    if lhs.reverseInput != rhs.reverseInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BiDirectionalLSTMLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BiDirectionalLSTMLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputVectorSize"),
    2: .same(proto: "outputVectorSize"),
    10: .same(proto: "activationsForwardLSTM"),
    11: .same(proto: "activationsBackwardLSTM"),
    15: .same(proto: "params"),
    20: .same(proto: "weightParams"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.inputVectorSize) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.outputVectorSize) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.activationsForwardLstm) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.activationsBackwardLstm) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 20: try { try decoder.decodeRepeatedMessageField(value: &self.weightParams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.inputVectorSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.inputVectorSize, fieldNumber: 1)
    }
    if self.outputVectorSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.outputVectorSize, fieldNumber: 2)
    }
    if !self.activationsForwardLstm.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activationsForwardLstm, fieldNumber: 10)
    }
    if !self.activationsBackwardLstm.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activationsBackwardLstm, fieldNumber: 11)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    if !self.weightParams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weightParams, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BiDirectionalLSTMLayerParams, rhs: BiDirectionalLSTMLayerParams) -> Bool {
    if lhs.inputVectorSize != rhs.inputVectorSize {return false}
    if lhs.outputVectorSize != rhs.outputVectorSize {return false}
    if lhs.activationsForwardLstm != rhs.activationsForwardLstm {return false}
    if lhs.activationsBackwardLstm != rhs.activationsBackwardLstm {return false}
    if lhs._params != rhs._params {return false}
    if lhs.weightParams != rhs.weightParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "className"),
    20: .same(proto: "weights"),
    30: .same(proto: "parameters"),
    40: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try { try decoder.decodeSingularStringField(value: &self.className) }()
      case 20: try { try decoder.decodeRepeatedMessageField(value: &self.weights) }()
      case 30: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CustomLayerParams.CustomLayerParamValue>.self, value: &self.parameters) }()
      case 40: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.className.isEmpty {
      try visitor.visitSingularStringField(value: self.className, fieldNumber: 10)
    }
    if !self.weights.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weights, fieldNumber: 20)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,CustomLayerParams.CustomLayerParamValue>.self, value: self.parameters, fieldNumber: 30)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 40)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CustomLayerParams, rhs: CustomLayerParams) -> Bool {
    if lhs.className != rhs.className {return false}
    if lhs.weights != rhs.weights {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomLayerParams.CustomLayerParamValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CustomLayerParams.protoMessageName + ".CustomLayerParamValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "doubleValue"),
    20: .same(proto: "stringValue"),
    30: .same(proto: "intValue"),
    40: .same(proto: "longValue"),
    50: .same(proto: "boolValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .doubleValue(v)
        }
      }()
      case 20: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 30: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .intValue(v)
        }
      }()
      case 40: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .longValue(v)
        }
      }()
      case 50: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 20)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 30)
    }()
    case .longValue?: try {
      guard case .longValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 40)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 50)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CustomLayerParams.CustomLayerParamValue, rhs: CustomLayerParams.CustomLayerParamValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransposeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransposeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.axes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.axes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransposeLayerParams, rhs: TransposeLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BatchedMatMulLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchedMatMulLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transposeA"),
    2: .same(proto: "transposeB"),
    5: .same(proto: "weightMatrixFirstDimension"),
    6: .same(proto: "weightMatrixSecondDimension"),
    7: .same(proto: "hasBias"),
    8: .same(proto: "weights"),
    9: .same(proto: "bias"),
    10: .same(proto: "int8DynamicQuantize"),
  ]

  fileprivate class _StorageClass {
    var _transposeA: Bool = false
    var _transposeB: Bool = false
    var _weightMatrixFirstDimension: UInt64 = 0
    var _weightMatrixSecondDimension: UInt64 = 0
    var _hasBias_p: Bool = false
    var _weights: WeightParams? = nil
    var _bias: WeightParams? = nil
    var _int8DynamicQuantize: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transposeA = source._transposeA
      _transposeB = source._transposeB
      _weightMatrixFirstDimension = source._weightMatrixFirstDimension
      _weightMatrixSecondDimension = source._weightMatrixSecondDimension
      _hasBias_p = source._hasBias_p
      _weights = source._weights
      _bias = source._bias
      _int8DynamicQuantize = source._int8DynamicQuantize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._transposeA) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._transposeB) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._weightMatrixFirstDimension) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._weightMatrixSecondDimension) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._hasBias_p) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._weights) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._bias) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._int8DynamicQuantize) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._transposeA != false {
        try visitor.visitSingularBoolField(value: _storage._transposeA, fieldNumber: 1)
      }
      if _storage._transposeB != false {
        try visitor.visitSingularBoolField(value: _storage._transposeB, fieldNumber: 2)
      }
      if _storage._weightMatrixFirstDimension != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._weightMatrixFirstDimension, fieldNumber: 5)
      }
      if _storage._weightMatrixSecondDimension != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._weightMatrixSecondDimension, fieldNumber: 6)
      }
      if _storage._hasBias_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBias_p, fieldNumber: 7)
      }
      try { if let v = _storage._weights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._int8DynamicQuantize != false {
        try visitor.visitSingularBoolField(value: _storage._int8DynamicQuantize, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BatchedMatMulLayerParams, rhs: BatchedMatMulLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transposeA != rhs_storage._transposeA {return false}
        if _storage._transposeB != rhs_storage._transposeB {return false}
        if _storage._weightMatrixFirstDimension != rhs_storage._weightMatrixFirstDimension {return false}
        if _storage._weightMatrixSecondDimension != rhs_storage._weightMatrixSecondDimension {return false}
        if _storage._hasBias_p != rhs_storage._hasBias_p {return false}
        if _storage._weights != rhs_storage._weights {return false}
        if _storage._bias != rhs_storage._bias {return false}
        if _storage._int8DynamicQuantize != rhs_storage._int8DynamicQuantize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConcatNDLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConcatNDLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "interleave"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.interleave) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.interleave != false {
      try visitor.visitSingularBoolField(value: self.interleave, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConcatNDLayerParams, rhs: ConcatNDLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.interleave != rhs.interleave {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SoftmaxNDLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SoftmaxNDLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SoftmaxNDLayerParams, rhs: SoftmaxNDLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReverseLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReverseLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reverseDim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.reverseDim) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reverseDim.isEmpty {
      try visitor.visitPackedBoolField(value: self.reverseDim, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReverseLayerParams, rhs: ReverseLayerParams) -> Bool {
    if lhs.reverseDim != rhs.reverseDim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReverseSeqLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReverseSeqLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batchAxis"),
    2: .same(proto: "sequenceAxis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.batchAxis) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sequenceAxis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batchAxis != 0 {
      try visitor.visitSingularInt64Field(value: self.batchAxis, fieldNumber: 1)
    }
    if self.sequenceAxis != 0 {
      try visitor.visitSingularInt64Field(value: self.sequenceAxis, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReverseSeqLayerParams, rhs: ReverseSeqLayerParams) -> Bool {
    if lhs.batchAxis != rhs.batchAxis {return false}
    if lhs.sequenceAxis != rhs.sequenceAxis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoadConstantNDLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadConstantNDLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.shape) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shape.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.shape, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LoadConstantNDLayerParams, rhs: LoadConstantNDLayerParams) -> Bool {
    if lhs.shape != rhs.shape {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FillLikeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FillLikeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FillLikeLayerParams, rhs: FillLikeLayerParams) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FillStaticLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FillStaticLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "targetShape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.targetShape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 1)
    }
    if !self.targetShape.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.targetShape, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FillStaticLayerParams, rhs: FillStaticLayerParams) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.targetShape != rhs.targetShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FillDynamicLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FillDynamicLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FillDynamicLayerParams, rhs: FillDynamicLayerParams) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WhereBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhereBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WhereBroadcastableLayerParams, rhs: WhereBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SinLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SinLayerParams, rhs: SinLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CosLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CosLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CosLayerParams, rhs: CosLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TanLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TanLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TanLayerParams, rhs: TanLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsinLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AsinLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsinLayerParams, rhs: AsinLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AcosLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcosLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AcosLayerParams, rhs: AcosLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AtanLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AtanLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AtanLayerParams, rhs: AtanLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SinhLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinhLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SinhLayerParams, rhs: SinhLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoshLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoshLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CoshLayerParams, rhs: CoshLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TanhLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TanhLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TanhLayerParams, rhs: TanhLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsinhLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AsinhLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsinhLayerParams, rhs: AsinhLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AcoshLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcoshLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AcoshLayerParams, rhs: AcoshLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AtanhLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AtanhLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AtanhLayerParams, rhs: AtanhLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PowBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PowBroadcastableLayerParams, rhs: PowBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exp2LayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Exp2LayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exp2LayerParams, rhs: Exp2LayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WhereNonZeroLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhereNonZeroLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WhereNonZeroLayerParams, rhs: WhereNonZeroLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MatrixBandPartLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatrixBandPartLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numLower"),
    2: .same(proto: "numUpper"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.numLower) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.numUpper) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numLower != 0 {
      try visitor.visitSingularInt64Field(value: self.numLower, fieldNumber: 1)
    }
    if self.numUpper != 0 {
      try visitor.visitSingularInt64Field(value: self.numUpper, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MatrixBandPartLayerParams, rhs: MatrixBandPartLayerParams) -> Bool {
    if lhs.numLower != rhs.numLower {return false}
    if lhs.numUpper != rhs.numUpper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpperTriangularLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpperTriangularLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "k"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.k) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.k != 0 {
      try visitor.visitSingularInt64Field(value: self.k, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpperTriangularLayerParams, rhs: UpperTriangularLayerParams) -> Bool {
    if lhs.k != rhs.k {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LowerTriangularLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LowerTriangularLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "k"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.k) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.k != 0 {
      try visitor.visitSingularInt64Field(value: self.k, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LowerTriangularLayerParams, rhs: LowerTriangularLayerParams) -> Bool {
    if lhs.k != rhs.k {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BroadcastToLikeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BroadcastToLikeLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BroadcastToLikeLayerParams, rhs: BroadcastToLikeLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BroadcastToStaticLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BroadcastToStaticLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetShape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.targetShape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetShape.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.targetShape, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BroadcastToStaticLayerParams, rhs: BroadcastToStaticLayerParams) -> Bool {
    if lhs.targetShape != rhs.targetShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BroadcastToDynamicLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BroadcastToDynamicLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BroadcastToDynamicLayerParams, rhs: BroadcastToDynamicLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddBroadcastableLayerParams, rhs: AddBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MaxBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaxBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MaxBroadcastableLayerParams, rhs: MaxBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MinBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MinBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MinBroadcastableLayerParams, rhs: MinBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModBroadcastableLayerParams, rhs: ModBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FloorDivBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FloorDivBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FloorDivBroadcastableLayerParams, rhs: FloorDivBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubtractBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubtractBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubtractBroadcastableLayerParams, rhs: SubtractBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MultiplyBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiplyBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MultiplyBroadcastableLayerParams, rhs: MultiplyBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DivideBroadcastableLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DivideBroadcastableLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DivideBroadcastableLayerParams, rhs: DivideBroadcastableLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GatherLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GatherLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GatherLayerParams, rhs: GatherLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ScatterLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScatterLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.mode != .scatterUpdate {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ScatterLayerParams, rhs: ScatterLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GatherNDLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GatherNDLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GatherNDLayerParams, rhs: GatherNDLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ScatterNDLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScatterNDLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .scatterUpdate {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ScatterNDLayerParams, rhs: ScatterNDLayerParams) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GatherAlongAxisLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GatherAlongAxisLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GatherAlongAxisLayerParams, rhs: GatherAlongAxisLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ScatterAlongAxisLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScatterAlongAxisLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.mode != .scatterUpdate {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ScatterAlongAxisLayerParams, rhs: ScatterAlongAxisLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StackLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StackLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StackLayerParams, rhs: StackLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RankPreservingReshapeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RankPreservingReshapeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetShape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.targetShape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetShape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.targetShape, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RankPreservingReshapeLayerParams, rhs: RankPreservingReshapeLayerParams) -> Bool {
    if lhs.targetShape != rhs.targetShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConstantPaddingLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConstantPaddingLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "padAmounts"),
    3: .same(proto: "padToGivenOutputSizeMode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.padAmounts) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.padToGivenOutputSizeMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 1)
    }
    if !self.padAmounts.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.padAmounts, fieldNumber: 2)
    }
    if self.padToGivenOutputSizeMode != false {
      try visitor.visitSingularBoolField(value: self.padToGivenOutputSizeMode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConstantPaddingLayerParams, rhs: ConstantPaddingLayerParams) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.padAmounts != rhs.padAmounts {return false}
    if lhs.padToGivenOutputSizeMode != rhs.padToGivenOutputSizeMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomNormalLikeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomNormalLikeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "mean"),
    3: .same(proto: "stdDev"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.mean) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.stdDev) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.mean != 0 {
      try visitor.visitSingularFloatField(value: self.mean, fieldNumber: 2)
    }
    if self.stdDev != 0 {
      try visitor.visitSingularFloatField(value: self.stdDev, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomNormalLikeLayerParams, rhs: RandomNormalLikeLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.mean != rhs.mean {return false}
    if lhs.stdDev != rhs.stdDev {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomNormalStaticLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomNormalStaticLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "mean"),
    3: .same(proto: "stdDev"),
    4: .same(proto: "outputShape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.mean) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.stdDev) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.outputShape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.mean != 0 {
      try visitor.visitSingularFloatField(value: self.mean, fieldNumber: 2)
    }
    if self.stdDev != 0 {
      try visitor.visitSingularFloatField(value: self.stdDev, fieldNumber: 3)
    }
    if !self.outputShape.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.outputShape, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomNormalStaticLayerParams, rhs: RandomNormalStaticLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.mean != rhs.mean {return false}
    if lhs.stdDev != rhs.stdDev {return false}
    if lhs.outputShape != rhs.outputShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomNormalDynamicLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomNormalDynamicLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "mean"),
    3: .same(proto: "stdDev"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.mean) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.stdDev) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.mean != 0 {
      try visitor.visitSingularFloatField(value: self.mean, fieldNumber: 2)
    }
    if self.stdDev != 0 {
      try visitor.visitSingularFloatField(value: self.stdDev, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomNormalDynamicLayerParams, rhs: RandomNormalDynamicLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.mean != rhs.mean {return false}
    if lhs.stdDev != rhs.stdDev {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomUniformLikeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomUniformLikeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "minVal"),
    3: .same(proto: "maxVal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.minVal) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.maxVal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.minVal != 0 {
      try visitor.visitSingularFloatField(value: self.minVal, fieldNumber: 2)
    }
    if self.maxVal != 0 {
      try visitor.visitSingularFloatField(value: self.maxVal, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomUniformLikeLayerParams, rhs: RandomUniformLikeLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.minVal != rhs.minVal {return false}
    if lhs.maxVal != rhs.maxVal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomUniformStaticLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomUniformStaticLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "minVal"),
    3: .same(proto: "maxVal"),
    4: .same(proto: "outputShape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.minVal) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.maxVal) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.outputShape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.minVal != 0 {
      try visitor.visitSingularFloatField(value: self.minVal, fieldNumber: 2)
    }
    if self.maxVal != 0 {
      try visitor.visitSingularFloatField(value: self.maxVal, fieldNumber: 3)
    }
    if !self.outputShape.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.outputShape, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomUniformStaticLayerParams, rhs: RandomUniformStaticLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.minVal != rhs.minVal {return false}
    if lhs.maxVal != rhs.maxVal {return false}
    if lhs.outputShape != rhs.outputShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomUniformDynamicLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomUniformDynamicLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "minVal"),
    3: .same(proto: "maxVal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.minVal) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.maxVal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.minVal != 0 {
      try visitor.visitSingularFloatField(value: self.minVal, fieldNumber: 2)
    }
    if self.maxVal != 0 {
      try visitor.visitSingularFloatField(value: self.maxVal, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomUniformDynamicLayerParams, rhs: RandomUniformDynamicLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.minVal != rhs.minVal {return false}
    if lhs.maxVal != rhs.maxVal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomBernoulliLikeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomBernoulliLikeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "prob"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.prob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.prob != 0 {
      try visitor.visitSingularFloatField(value: self.prob, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomBernoulliLikeLayerParams, rhs: RandomBernoulliLikeLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.prob != rhs.prob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomBernoulliStaticLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomBernoulliStaticLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "prob"),
    3: .same(proto: "outputShape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.prob) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.outputShape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.prob != 0 {
      try visitor.visitSingularFloatField(value: self.prob, fieldNumber: 2)
    }
    if !self.outputShape.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.outputShape, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomBernoulliStaticLayerParams, rhs: RandomBernoulliStaticLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.prob != rhs.prob {return false}
    if lhs.outputShape != rhs.outputShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RandomBernoulliDynamicLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomBernoulliDynamicLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "prob"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.prob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.prob != 0 {
      try visitor.visitSingularFloatField(value: self.prob, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RandomBernoulliDynamicLayerParams, rhs: RandomBernoulliDynamicLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.prob != rhs.prob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CategoricalDistributionLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CategoricalDistributionLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
    2: .same(proto: "numSamples"),
    3: .same(proto: "isLogits"),
    4: .same(proto: "eps"),
    5: .same(proto: "temperature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.numSamples) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isLogits) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.eps) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.temperature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 1)
    }
    if self.numSamples != 0 {
      try visitor.visitSingularInt64Field(value: self.numSamples, fieldNumber: 2)
    }
    if self.isLogits != false {
      try visitor.visitSingularBoolField(value: self.isLogits, fieldNumber: 3)
    }
    if self.eps != 0 {
      try visitor.visitSingularFloatField(value: self.eps, fieldNumber: 4)
    }
    if self.temperature != 0 {
      try visitor.visitSingularFloatField(value: self.temperature, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CategoricalDistributionLayerParams, rhs: CategoricalDistributionLayerParams) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.numSamples != rhs.numSamples {return false}
    if lhs.isLogits != rhs.isLogits {return false}
    if lhs.eps != rhs.eps {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceL1LayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceL1LayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceL1LayerParams, rhs: ReduceL1LayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceL2LayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceL2LayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceL2LayerParams, rhs: ReduceL2LayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceMaxLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceMaxLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceMaxLayerParams, rhs: ReduceMaxLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceMinLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceMinLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceMinLayerParams, rhs: ReduceMinLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceSumLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceSumLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceSumLayerParams, rhs: ReduceSumLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceProdLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceProdLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceProdLayerParams, rhs: ReduceProdLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceMeanLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceMeanLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceMeanLayerParams, rhs: ReduceMeanLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceLogSumLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceLogSumLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceLogSumLayerParams, rhs: ReduceLogSumLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceSumSquareLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceSumSquareLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceSumSquareLayerParams, rhs: ReduceSumSquareLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReduceLogSumExpLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReduceLogSumExpLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "keepDims"),
    3: .same(proto: "reduceAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepDims) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reduceAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.keepDims != false {
      try visitor.visitSingularBoolField(value: self.keepDims, fieldNumber: 2)
    }
    if self.reduceAll != false {
      try visitor.visitSingularBoolField(value: self.reduceAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReduceLogSumExpLayerParams, rhs: ReduceLogSumExpLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.keepDims != rhs.keepDims {return false}
    if lhs.reduceAll != rhs.reduceAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExpandDimsLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExpandDimsLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExpandDimsLayerParams, rhs: ExpandDimsLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FlattenTo2DLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FlattenTo2DLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FlattenTo2DLayerParams, rhs: FlattenTo2DLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReshapeStaticLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReshapeStaticLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetShape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.targetShape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetShape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.targetShape, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReshapeStaticLayerParams, rhs: ReshapeStaticLayerParams) -> Bool {
    if lhs.targetShape != rhs.targetShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReshapeLikeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReshapeLikeLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReshapeLikeLayerParams, rhs: ReshapeLikeLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReshapeDynamicLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReshapeDynamicLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReshapeDynamicLayerParams, rhs: ReshapeDynamicLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SqueezeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SqueezeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axes"),
    2: .same(proto: "squeezeAll"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.axes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.squeezeAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.axes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.axes, fieldNumber: 1)
    }
    if self.squeezeAll != false {
      try visitor.visitSingularBoolField(value: self.squeezeAll, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SqueezeLayerParams, rhs: SqueezeLayerParams) -> Bool {
    if lhs.axes != rhs.axes {return false}
    if lhs.squeezeAll != rhs.squeezeAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopKLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopKLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "K"),
    3: .same(proto: "useBottomK"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.k) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.useBottomK) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.k != 0 {
      try visitor.visitSingularUInt64Field(value: self.k, fieldNumber: 2)
    }
    if self.useBottomK != false {
      try visitor.visitSingularBoolField(value: self.useBottomK, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopKLayerParams, rhs: TopKLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.k != rhs.k {return false}
    if lhs.useBottomK != rhs.useBottomK {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArgMaxLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArgMaxLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "removeDim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.removeDim) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.removeDim != false {
      try visitor.visitSingularBoolField(value: self.removeDim, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArgMaxLayerParams, rhs: ArgMaxLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.removeDim != rhs.removeDim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArgMinLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArgMinLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "removeDim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.removeDim) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.removeDim != false {
      try visitor.visitSingularBoolField(value: self.removeDim, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArgMinLayerParams, rhs: ArgMinLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.removeDim != rhs.removeDim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SplitNDLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SplitNDLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "numSplits"),
    3: .same(proto: "splitSizes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numSplits) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.splitSizes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.numSplits != 0 {
      try visitor.visitSingularUInt64Field(value: self.numSplits, fieldNumber: 2)
    }
    if !self.splitSizes.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.splitSizes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SplitNDLayerParams, rhs: SplitNDLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.numSplits != rhs.numSplits {return false}
    if lhs.splitSizes != rhs.splitSizes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CeilLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CeilLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CeilLayerParams, rhs: CeilLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RoundLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RoundLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RoundLayerParams, rhs: RoundLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FloorLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FloorLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FloorLayerParams, rhs: FloorLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SignLayerParams, rhs: SignLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClipLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClipLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minVal"),
    2: .same(proto: "maxVal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.minVal) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxVal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minVal != 0 {
      try visitor.visitSingularFloatField(value: self.minVal, fieldNumber: 1)
    }
    if self.maxVal != 0 {
      try visitor.visitSingularFloatField(value: self.maxVal, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClipLayerParams, rhs: ClipLayerParams) -> Bool {
    if lhs.minVal != rhs.minVal {return false}
    if lhs.maxVal != rhs.maxVal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SliceStaticLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SliceStaticLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beginIds"),
    2: .same(proto: "beginMasks"),
    3: .same(proto: "endIds"),
    4: .same(proto: "endMasks"),
    5: .same(proto: "strides"),
    6: .same(proto: "squeezeMasks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.beginIds) }()
      case 2: try { try decoder.decodeRepeatedBoolField(value: &self.beginMasks) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.endIds) }()
      case 4: try { try decoder.decodeRepeatedBoolField(value: &self.endMasks) }()
      case 5: try { try decoder.decodeRepeatedInt64Field(value: &self.strides) }()
      case 6: try { try decoder.decodeRepeatedBoolField(value: &self.squeezeMasks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.beginIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.beginIds, fieldNumber: 1)
    }
    if !self.beginMasks.isEmpty {
      try visitor.visitPackedBoolField(value: self.beginMasks, fieldNumber: 2)
    }
    if !self.endIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.endIds, fieldNumber: 3)
    }
    if !self.endMasks.isEmpty {
      try visitor.visitPackedBoolField(value: self.endMasks, fieldNumber: 4)
    }
    if !self.strides.isEmpty {
      try visitor.visitPackedInt64Field(value: self.strides, fieldNumber: 5)
    }
    if !self.squeezeMasks.isEmpty {
      try visitor.visitPackedBoolField(value: self.squeezeMasks, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SliceStaticLayerParams, rhs: SliceStaticLayerParams) -> Bool {
    if lhs.beginIds != rhs.beginIds {return false}
    if lhs.beginMasks != rhs.beginMasks {return false}
    if lhs.endIds != rhs.endIds {return false}
    if lhs.endMasks != rhs.endMasks {return false}
    if lhs.strides != rhs.strides {return false}
    if lhs.squeezeMasks != rhs.squeezeMasks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SliceDynamicLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SliceDynamicLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "beginMasks"),
    3: .same(proto: "endIds"),
    4: .same(proto: "endMasks"),
    5: .same(proto: "strides"),
    6: .same(proto: "squeezeMasks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedBoolField(value: &self.beginMasks) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.endIds) }()
      case 4: try { try decoder.decodeRepeatedBoolField(value: &self.endMasks) }()
      case 5: try { try decoder.decodeRepeatedInt64Field(value: &self.strides) }()
      case 6: try { try decoder.decodeRepeatedBoolField(value: &self.squeezeMasks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.beginMasks.isEmpty {
      try visitor.visitPackedBoolField(value: self.beginMasks, fieldNumber: 2)
    }
    if !self.endIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.endIds, fieldNumber: 3)
    }
    if !self.endMasks.isEmpty {
      try visitor.visitPackedBoolField(value: self.endMasks, fieldNumber: 4)
    }
    if !self.strides.isEmpty {
      try visitor.visitPackedInt64Field(value: self.strides, fieldNumber: 5)
    }
    if !self.squeezeMasks.isEmpty {
      try visitor.visitPackedBoolField(value: self.squeezeMasks, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SliceDynamicLayerParams, rhs: SliceDynamicLayerParams) -> Bool {
    if lhs.beginMasks != rhs.beginMasks {return false}
    if lhs.endIds != rhs.endIds {return false}
    if lhs.endMasks != rhs.endMasks {return false}
    if lhs.strides != rhs.strides {return false}
    if lhs.squeezeMasks != rhs.squeezeMasks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TileLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TileLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.reps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reps.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.reps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TileLayerParams, rhs: TileLayerParams) -> Bool {
    if lhs.reps != rhs.reps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetShapeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetShapeLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetShapeLayerParams, rhs: GetShapeLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ErfLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErfLayerParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ErfLayerParams, rhs: ErfLayerParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeluLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeluLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .exact {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GeluLayerParams, rhs: GeluLayerParams) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeluLayerParams.GeluMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXACT"),
    1: .same(proto: "TANH_APPROXIMATION"),
    2: .same(proto: "SIGMOID_APPROXIMATION"),
  ]
}

extension RangeStaticLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RangeStaticLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endValue"),
    2: .same(proto: "startValue"),
    3: .same(proto: "stepSizeValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.endValue) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.startValue) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.stepSizeValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.endValue != 0 {
      try visitor.visitSingularFloatField(value: self.endValue, fieldNumber: 1)
    }
    if self.startValue != 0 {
      try visitor.visitSingularFloatField(value: self.startValue, fieldNumber: 2)
    }
    if self.stepSizeValue != 0 {
      try visitor.visitSingularFloatField(value: self.stepSizeValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RangeStaticLayerParams, rhs: RangeStaticLayerParams) -> Bool {
    if lhs.endValue != rhs.endValue {return false}
    if lhs.startValue != rhs.startValue {return false}
    if lhs.stepSizeValue != rhs.stepSizeValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RangeDynamicLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RangeDynamicLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "startValue"),
    3: .same(proto: "stepSizeValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self.startValue) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.stepSizeValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startValue != 0 {
      try visitor.visitSingularFloatField(value: self.startValue, fieldNumber: 2)
    }
    if self.stepSizeValue != 0 {
      try visitor.visitSingularFloatField(value: self.stepSizeValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RangeDynamicLayerParams, rhs: RangeDynamicLayerParams) -> Bool {
    if lhs.startValue != rhs.startValue {return false}
    if lhs.stepSizeValue != rhs.stepSizeValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SlidingWindowsLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SlidingWindowsLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "windowSize"),
    3: .same(proto: "step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.windowSize) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.step) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.windowSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.windowSize, fieldNumber: 2)
    }
    if self.step != 0 {
      try visitor.visitSingularUInt64Field(value: self.step, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SlidingWindowsLayerParams, rhs: SlidingWindowsLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.windowSize != rhs.windowSize {return false}
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LayerNormalizationLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LayerNormalizationLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "normalizedShape"),
    2: .same(proto: "eps"),
    3: .same(proto: "gamma"),
    4: .same(proto: "beta"),
  ]

  fileprivate class _StorageClass {
    var _normalizedShape: [Int64] = []
    var _eps: Float = 0
    var _gamma: WeightParams? = nil
    var _beta: WeightParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _normalizedShape = source._normalizedShape
      _eps = source._eps
      _gamma = source._gamma
      _beta = source._beta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedInt64Field(value: &_storage._normalizedShape) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._eps) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._gamma) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._beta) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._normalizedShape.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._normalizedShape, fieldNumber: 1)
      }
      if _storage._eps != 0 {
        try visitor.visitSingularFloatField(value: _storage._eps, fieldNumber: 2)
      }
      try { if let v = _storage._gamma {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._beta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LayerNormalizationLayerParams, rhs: LayerNormalizationLayerParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._normalizedShape != rhs_storage._normalizedShape {return false}
        if _storage._eps != rhs_storage._eps {return false}
        if _storage._gamma != rhs_storage._gamma {return false}
        if _storage._beta != rhs_storage._beta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NonMaximumSuppressionLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NonMaximumSuppressionLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "iouThreshold"),
    2: .same(proto: "scoreThreshold"),
    3: .same(proto: "maxBoxes"),
    4: .same(proto: "perClassSuppression"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.iouThreshold) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.scoreThreshold) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.maxBoxes) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.perClassSuppression) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.iouThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.iouThreshold, fieldNumber: 1)
    }
    if self.scoreThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.scoreThreshold, fieldNumber: 2)
    }
    if self.maxBoxes != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxBoxes, fieldNumber: 3)
    }
    if self.perClassSuppression != false {
      try visitor.visitSingularBoolField(value: self.perClassSuppression, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NonMaximumSuppressionLayerParams, rhs: NonMaximumSuppressionLayerParams) -> Bool {
    if lhs.iouThreshold != rhs.iouThreshold {return false}
    if lhs.scoreThreshold != rhs.scoreThreshold {return false}
    if lhs.maxBoxes != rhs.maxBoxes {return false}
    if lhs.perClassSuppression != rhs.perClassSuppression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClampedReLULayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClampedReLULayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
    2: .same(proto: "beta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.alpha) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.beta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alpha != 0 {
      try visitor.visitSingularFloatField(value: self.alpha, fieldNumber: 1)
    }
    if self.beta != 0 {
      try visitor.visitSingularFloatField(value: self.beta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClampedReLULayerParams, rhs: ClampedReLULayerParams) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.beta != rhs.beta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArgSortLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArgSortLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "descending"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.descending) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.descending != false {
      try visitor.visitSingularBoolField(value: self.descending, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArgSortLayerParams, rhs: ArgSortLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.descending != rhs.descending {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SliceBySizeLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SliceBySizeLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "size"),
    3: .same(proto: "axis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 2)
    }
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SliceBySizeLayerParams, rhs: SliceBySizeLayerParams) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.axis != rhs.axis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NeuralNetworkClassifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkClassifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
    5: .same(proto: "arrayInputShapeMapping"),
    6: .same(proto: "imageInputShapeMapping"),
    10: .same(proto: "updateParams"),
    100: .same(proto: "stringClassLabels"),
    101: .same(proto: "int64ClassLabels"),
    200: .same(proto: "labelProbabilityLayerName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.preprocessing) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.arrayInputShapeMapping) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.imageInputShapeMapping) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._updateParams) }()
      case 100: try {
        var v: StringVector?
        var hadOneofValue = false
        if let current = self.classLabels {
          hadOneofValue = true
          if case .stringClassLabels(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.classLabels = .stringClassLabels(v)
        }
      }()
      case 101: try {
        var v: Int64Vector?
        var hadOneofValue = false
        if let current = self.classLabels {
          hadOneofValue = true
          if case .int64ClassLabels(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.classLabels = .int64ClassLabels(v)
        }
      }()
      case 200: try { try decoder.decodeSingularStringField(value: &self.labelProbabilityLayerName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    if !self.preprocessing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preprocessing, fieldNumber: 2)
    }
    if self.arrayInputShapeMapping != .rank5ArrayMapping {
      try visitor.visitSingularEnumField(value: self.arrayInputShapeMapping, fieldNumber: 5)
    }
    if self.imageInputShapeMapping != .rank5ImageMapping {
      try visitor.visitSingularEnumField(value: self.imageInputShapeMapping, fieldNumber: 6)
    }
    try { if let v = self._updateParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    switch self.classLabels {
    case .stringClassLabels?: try {
      guard case .stringClassLabels(let v)? = self.classLabels else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .int64ClassLabels?: try {
      guard case .int64ClassLabels(let v)? = self.classLabels else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case nil: break
    }
    if !self.labelProbabilityLayerName.isEmpty {
      try visitor.visitSingularStringField(value: self.labelProbabilityLayerName, fieldNumber: 200)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NeuralNetworkClassifier, rhs: NeuralNetworkClassifier) -> Bool {
    if lhs.layers != rhs.layers {return false}
    if lhs.preprocessing != rhs.preprocessing {return false}
    if lhs.arrayInputShapeMapping != rhs.arrayInputShapeMapping {return false}
    if lhs.imageInputShapeMapping != rhs.imageInputShapeMapping {return false}
    if lhs._updateParams != rhs._updateParams {return false}
    if lhs.classLabels != rhs.classLabels {return false}
    if lhs.labelProbabilityLayerName != rhs.labelProbabilityLayerName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OneHotLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OneHotLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oneHotVectorSize"),
    2: .same(proto: "axis"),
    3: .same(proto: "onValue"),
    4: .same(proto: "offValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.oneHotVectorSize) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.onValue) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.offValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oneHotVectorSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.oneHotVectorSize, fieldNumber: 1)
    }
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 2)
    }
    if self.onValue != 0 {
      try visitor.visitSingularFloatField(value: self.onValue, fieldNumber: 3)
    }
    if self.offValue != 0 {
      try visitor.visitSingularFloatField(value: self.offValue, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OneHotLayerParams, rhs: OneHotLayerParams) -> Bool {
    if lhs.oneHotVectorSize != rhs.oneHotVectorSize {return false}
    if lhs.axis != rhs.axis {return false}
    if lhs.onValue != rhs.onValue {return false}
    if lhs.offValue != rhs.offValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CumSumLayerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CumSumLayerParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "excludeFinalSum"),
    3: .same(proto: "reverse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.axis) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.excludeFinalSum) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reverse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.axis != 0 {
      try visitor.visitSingularInt64Field(value: self.axis, fieldNumber: 1)
    }
    if self.excludeFinalSum != false {
      try visitor.visitSingularBoolField(value: self.excludeFinalSum, fieldNumber: 2)
    }
    if self.reverse != false {
      try visitor.visitSingularBoolField(value: self.reverse, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CumSumLayerParams, rhs: CumSumLayerParams) -> Bool {
    if lhs.axis != rhs.axis {return false}
    if lhs.excludeFinalSum != rhs.excludeFinalSum {return false}
    if lhs.reverse != rhs.reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NeuralNetworkRegressor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NeuralNetworkRegressor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
    2: .same(proto: "preprocessing"),
    5: .same(proto: "arrayInputShapeMapping"),
    6: .same(proto: "imageInputShapeMapping"),
    10: .same(proto: "updateParams"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.preprocessing) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.arrayInputShapeMapping) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.imageInputShapeMapping) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._updateParams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    if !self.preprocessing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preprocessing, fieldNumber: 2)
    }
    if self.arrayInputShapeMapping != .rank5ArrayMapping {
      try visitor.visitSingularEnumField(value: self.arrayInputShapeMapping, fieldNumber: 5)
    }
    if self.imageInputShapeMapping != .rank5ImageMapping {
      try visitor.visitSingularEnumField(value: self.imageInputShapeMapping, fieldNumber: 6)
    }
    try { if let v = self._updateParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NeuralNetworkRegressor, rhs: NeuralNetworkRegressor) -> Bool {
    if lhs.layers != rhs.layers {return false}
    if lhs.preprocessing != rhs.preprocessing {return false}
    if lhs.arrayInputShapeMapping != rhs.arrayInputShapeMapping {return false}
    if lhs.imageInputShapeMapping != rhs.imageInputShapeMapping {return false}
    if lhs._updateParams != rhs._updateParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NetworkUpdateParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkUpdateParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lossLayers"),
    2: .same(proto: "optimizer"),
    3: .same(proto: "epochs"),
    10: .same(proto: "shuffle"),
    20: .same(proto: "seed"),
  ]

  fileprivate class _StorageClass {
    var _lossLayers: [LossLayer] = []
    var _optimizer: Optimizer? = nil
    var _epochs: Int64Parameter? = nil
    var _shuffle: BoolParameter? = nil
    var _seed: Int64Parameter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lossLayers = source._lossLayers
      _optimizer = source._optimizer
      _epochs = source._epochs
      _shuffle = source._shuffle
      _seed = source._seed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._lossLayers) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._optimizer) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._epochs) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._shuffle) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._seed) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._lossLayers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._lossLayers, fieldNumber: 1)
      }
      try { if let v = _storage._optimizer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._epochs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._shuffle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._seed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NetworkUpdateParameters, rhs: NetworkUpdateParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lossLayers != rhs_storage._lossLayers {return false}
        if _storage._optimizer != rhs_storage._optimizer {return false}
        if _storage._epochs != rhs_storage._epochs {return false}
        if _storage._shuffle != rhs_storage._shuffle {return false}
        if _storage._seed != rhs_storage._seed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LossLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LossLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    10: .same(proto: "categoricalCrossEntropyLossLayer"),
    11: .same(proto: "meanSquaredErrorLossLayer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 10: try {
        var v: CategoricalCrossEntropyLossLayer?
        var hadOneofValue = false
        if let current = self.lossLayerType {
          hadOneofValue = true
          if case .categoricalCrossEntropyLossLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.lossLayerType = .categoricalCrossEntropyLossLayer(v)
        }
      }()
      case 11: try {
        var v: MeanSquaredErrorLossLayer?
        var hadOneofValue = false
        if let current = self.lossLayerType {
          hadOneofValue = true
          if case .meanSquaredErrorLossLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.lossLayerType = .meanSquaredErrorLossLayer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.lossLayerType {
    case .categoricalCrossEntropyLossLayer?: try {
      guard case .categoricalCrossEntropyLossLayer(let v)? = self.lossLayerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .meanSquaredErrorLossLayer?: try {
      guard case .meanSquaredErrorLossLayer(let v)? = self.lossLayerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LossLayer, rhs: LossLayer) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.lossLayerType != rhs.lossLayerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CategoricalCrossEntropyLossLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CategoricalCrossEntropyLossLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.input) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.target) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.input.isEmpty {
      try visitor.visitSingularStringField(value: self.input, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CategoricalCrossEntropyLossLayer, rhs: CategoricalCrossEntropyLossLayer) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeanSquaredErrorLossLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MeanSquaredErrorLossLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.input) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.target) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.input.isEmpty {
      try visitor.visitSingularStringField(value: self.input, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MeanSquaredErrorLossLayer, rhs: MeanSquaredErrorLossLayer) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Optimizer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Optimizer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "sgdOptimizer"),
    11: .same(proto: "adamOptimizer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try {
        var v: SGDOptimizer?
        var hadOneofValue = false
        if let current = self.optimizerType {
          hadOneofValue = true
          if case .sgdOptimizer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.optimizerType = .sgdOptimizer(v)
        }
      }()
      case 11: try {
        var v: AdamOptimizer?
        var hadOneofValue = false
        if let current = self.optimizerType {
          hadOneofValue = true
          if case .adamOptimizer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.optimizerType = .adamOptimizer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.optimizerType {
    case .sgdOptimizer?: try {
      guard case .sgdOptimizer(let v)? = self.optimizerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .adamOptimizer?: try {
      guard case .adamOptimizer(let v)? = self.optimizerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Optimizer, rhs: Optimizer) -> Bool {
    if lhs.optimizerType != rhs.optimizerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SGDOptimizer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SGDOptimizer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "learningRate"),
    2: .same(proto: "miniBatchSize"),
    3: .same(proto: "momentum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._learningRate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._miniBatchSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._momentum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._learningRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._miniBatchSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._momentum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SGDOptimizer, rhs: SGDOptimizer) -> Bool {
    if lhs._learningRate != rhs._learningRate {return false}
    if lhs._miniBatchSize != rhs._miniBatchSize {return false}
    if lhs._momentum != rhs._momentum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AdamOptimizer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdamOptimizer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "learningRate"),
    2: .same(proto: "miniBatchSize"),
    3: .same(proto: "beta1"),
    4: .same(proto: "beta2"),
    5: .same(proto: "eps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._learningRate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._miniBatchSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._beta1) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._beta2) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._eps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._learningRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._miniBatchSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._beta1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._beta2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._eps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AdamOptimizer, rhs: AdamOptimizer) -> Bool {
    if lhs._learningRate != rhs._learningRate {return false}
    if lhs._miniBatchSize != rhs._miniBatchSize {return false}
    if lhs._beta1 != rhs._beta1 {return false}
    if lhs._beta2 != rhs._beta2 {return false}
    if lhs._eps != rhs._eps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
