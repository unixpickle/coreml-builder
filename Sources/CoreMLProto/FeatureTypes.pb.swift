// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: FeatureTypes.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// The 64-bit integer feature type.
public struct Int64FeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// The double-precision floating point number feature type.
public struct DoubleFeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// The string feature type.
public struct StringFeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SizeRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lowerBound: UInt64 = 0

  /// negative value means unbound otherwise upperbound is included in range
  public var upperBound: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// The image feature type.
public struct ImageFeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Int64 = 0

  public var height: Int64 = 0

  public var sizeFlexibility: ImageFeatureType.OneOf_SizeFlexibility? = nil

  public var enumeratedSizes: ImageFeatureType.EnumeratedImageSizes {
    get {
      if case .enumeratedSizes(let v)? = sizeFlexibility {return v}
      return ImageFeatureType.EnumeratedImageSizes()
    }
    set {sizeFlexibility = .enumeratedSizes(newValue)}
  }

  public var imageSizeRange: ImageFeatureType.ImageSizeRange {
    get {
      if case .imageSizeRange(let v)? = sizeFlexibility {return v}
      return ImageFeatureType.ImageSizeRange()
    }
    set {sizeFlexibility = .imageSizeRange(newValue)}
  }

  public var colorSpace: ImageFeatureType.ColorSpace = .invalidColorSpace

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SizeFlexibility: Equatable {
    case enumeratedSizes(ImageFeatureType.EnumeratedImageSizes)
    case imageSizeRange(ImageFeatureType.ImageSizeRange)

  #if !swift(>=4.1)
    public static func ==(lhs: ImageFeatureType.OneOf_SizeFlexibility, rhs: ImageFeatureType.OneOf_SizeFlexibility) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.enumeratedSizes, .enumeratedSizes): return {
        guard case .enumeratedSizes(let l) = lhs, case .enumeratedSizes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imageSizeRange, .imageSizeRange): return {
        guard case .imageSizeRange(let l) = lhs, case .imageSizeRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Assumes raw (decompressed) format
  public enum ColorSpace: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case invalidColorSpace // = 0

    ///  8 bits per pixel
    case grayscale // = 10

    /// 32 bits per pixel: RGBA with A channel ignored
    case rgb // = 20

    /// 32 bits per pixel: BGRA with A channel ignored
    case bgr // = 30

    /// 16 bits float per pixel
    case grayscaleFloat16 // = 40
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalidColorSpace
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalidColorSpace
      case 10: self = .grayscale
      case 20: self = .rgb
      case 30: self = .bgr
      case 40: self = .grayscaleFloat16
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalidColorSpace: return 0
      case .grayscale: return 10
      case .rgb: return 20
      case .bgr: return 30
      case .grayscaleFloat16: return 40
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct ImageSize {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var width: UInt64 = 0

    public var height: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct EnumeratedImageSizes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sizes: [ImageFeatureType.ImageSize] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ImageSizeRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var widthRange: SizeRange {
      get {return _widthRange ?? SizeRange()}
      set {_widthRange = newValue}
    }
    /// Returns true if `widthRange` has been explicitly set.
    public var hasWidthRange: Bool {return self._widthRange != nil}
    /// Clears the value of `widthRange`. Subsequent reads from it will return its default value.
    public mutating func clearWidthRange() {self._widthRange = nil}

    public var heightRange: SizeRange {
      get {return _heightRange ?? SizeRange()}
      set {_heightRange = newValue}
    }
    /// Returns true if `heightRange` has been explicitly set.
    public var hasHeightRange: Bool {return self._heightRange != nil}
    /// Clears the value of `heightRange`. Subsequent reads from it will return its default value.
    public mutating func clearHeightRange() {self._heightRange = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _widthRange: SizeRange? = nil
    fileprivate var _heightRange: SizeRange? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension ImageFeatureType.ColorSpace: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ImageFeatureType.ColorSpace] = [
    .invalidColorSpace,
    .grayscale,
    .rgb,
    .bgr,
    .grayscaleFloat16,
  ]
}

#endif  // swift(>=4.2)

///
/// The array feature type.
public struct ArrayFeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shape: [Int64] = []

  public var dataType: ArrayFeatureType.ArrayDataType = .invalidArrayDataType

  public var shapeFlexibility: ArrayFeatureType.OneOf_ShapeFlexibility? = nil

  public var enumeratedShapes: ArrayFeatureType.EnumeratedShapes {
    get {
      if case .enumeratedShapes(let v)? = shapeFlexibility {return v}
      return ArrayFeatureType.EnumeratedShapes()
    }
    set {shapeFlexibility = .enumeratedShapes(newValue)}
  }

  public var shapeRange: ArrayFeatureType.ShapeRange {
    get {
      if case .shapeRange(let v)? = shapeFlexibility {return v}
      return ArrayFeatureType.ShapeRange()
    }
    set {shapeFlexibility = .shapeRange(newValue)}
  }

  public var defaultOptionalValue: ArrayFeatureType.OneOf_DefaultOptionalValue? = nil

  public var intDefaultValue: Int32 {
    get {
      if case .intDefaultValue(let v)? = defaultOptionalValue {return v}
      return 0
    }
    set {defaultOptionalValue = .intDefaultValue(newValue)}
  }

  public var floatDefaultValue: Float {
    get {
      if case .floatDefaultValue(let v)? = defaultOptionalValue {return v}
      return 0
    }
    set {defaultOptionalValue = .floatDefaultValue(newValue)}
  }

  public var doubleDefaultValue: Double {
    get {
      if case .doubleDefaultValue(let v)? = defaultOptionalValue {return v}
      return 0
    }
    set {defaultOptionalValue = .doubleDefaultValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ShapeFlexibility: Equatable {
    case enumeratedShapes(ArrayFeatureType.EnumeratedShapes)
    case shapeRange(ArrayFeatureType.ShapeRange)

  #if !swift(>=4.1)
    public static func ==(lhs: ArrayFeatureType.OneOf_ShapeFlexibility, rhs: ArrayFeatureType.OneOf_ShapeFlexibility) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.enumeratedShapes, .enumeratedShapes): return {
        guard case .enumeratedShapes(let l) = lhs, case .enumeratedShapes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shapeRange, .shapeRange): return {
        guard case .shapeRange(let l) = lhs, case .shapeRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_DefaultOptionalValue: Equatable {
    case intDefaultValue(Int32)
    case floatDefaultValue(Float)
    case doubleDefaultValue(Double)

  #if !swift(>=4.1)
    public static func ==(lhs: ArrayFeatureType.OneOf_DefaultOptionalValue, rhs: ArrayFeatureType.OneOf_DefaultOptionalValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.intDefaultValue, .intDefaultValue): return {
        guard case .intDefaultValue(let l) = lhs, case .intDefaultValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.floatDefaultValue, .floatDefaultValue): return {
        guard case .floatDefaultValue(let l) = lhs, case .floatDefaultValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleDefaultValue, .doubleDefaultValue): return {
        guard case .doubleDefaultValue(let l) = lhs, case .doubleDefaultValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ArrayDataType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case invalidArrayDataType // = 0

    /// 0x10000 | 32
    case float32 // = 65568

    /// 0x10000 | 64
    case double // = 65600

    /// 0x20000 | 32
    case int32 // = 131104

    /// 0x10000 | 16
    case float16 // = 65552
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalidArrayDataType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalidArrayDataType
      case 65552: self = .float16
      case 65568: self = .float32
      case 65600: self = .double
      case 131104: self = .int32
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalidArrayDataType: return 0
      case .float16: return 65552
      case .float32: return 65568
      case .double: return 65600
      case .int32: return 131104
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Shape {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var shape: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct EnumeratedShapes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var shapes: [ArrayFeatureType.Shape] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ShapeRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// sizeRanges.size() must be length 1 or 3
    /// sizeRanges[d] specifies the allowed range for dimension d
    public var sizeRanges: [SizeRange] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension ArrayFeatureType.ArrayDataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ArrayFeatureType.ArrayDataType] = [
    .invalidArrayDataType,
    .float32,
    .double,
    .int32,
    .float16,
  ]
}

#endif  // swift(>=4.2)

///
/// The dictionary feature type.
public struct DictionaryFeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///  Key/value type tags, with the following restrictions:
  ///  - ``keyType`` must be a hashable type
  ///  - ``valueType`` is assumed to be a ``double``
  public var keyType: DictionaryFeatureType.OneOf_KeyType? = nil

  public var int64KeyType: Int64FeatureType {
    get {
      if case .int64KeyType(let v)? = keyType {return v}
      return Int64FeatureType()
    }
    set {keyType = .int64KeyType(newValue)}
  }

  public var stringKeyType: StringFeatureType {
    get {
      if case .stringKeyType(let v)? = keyType {return v}
      return StringFeatureType()
    }
    set {keyType = .stringKeyType(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  ///  Key/value type tags, with the following restrictions:
  ///  - ``keyType`` must be a hashable type
  ///  - ``valueType`` is assumed to be a ``double``
  public enum OneOf_KeyType: Equatable {
    case int64KeyType(Int64FeatureType)
    case stringKeyType(StringFeatureType)

  #if !swift(>=4.1)
    public static func ==(lhs: DictionaryFeatureType.OneOf_KeyType, rhs: DictionaryFeatureType.OneOf_KeyType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.int64KeyType, .int64KeyType): return {
        guard case .int64KeyType(let l) = lhs, case .int64KeyType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringKeyType, .stringKeyType): return {
        guard case .stringKeyType(let l) = lhs, case .stringKeyType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///
/// The Sequence feature type.
public struct SequenceFeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Currently only categorical int64 and String sequences are supported
  public var type: SequenceFeatureType.OneOf_Type? = nil

  public var int64Type: Int64FeatureType {
    get {
      if case .int64Type(let v)? = type {return v}
      return Int64FeatureType()
    }
    set {type = .int64Type(newValue)}
  }

  public var stringType: StringFeatureType {
    get {
      if case .stringType(let v)? = type {return v}
      return StringFeatureType()
    }
    set {type = .stringType(newValue)}
  }

  /// Range of allowed size/length/count of sequence
  public var sizeRange: SizeRange {
    get {return _sizeRange ?? SizeRange()}
    set {_sizeRange = newValue}
  }
  /// Returns true if `sizeRange` has been explicitly set.
  public var hasSizeRange: Bool {return self._sizeRange != nil}
  /// Clears the value of `sizeRange`. Subsequent reads from it will return its default value.
  public mutating func clearSizeRange() {self._sizeRange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Currently only categorical int64 and String sequences are supported
  public enum OneOf_Type: Equatable {
    case int64Type(Int64FeatureType)
    case stringType(StringFeatureType)

  #if !swift(>=4.1)
    public static func ==(lhs: SequenceFeatureType.OneOf_Type, rhs: SequenceFeatureType.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.int64Type, .int64Type): return {
        guard case .int64Type(let l) = lhs, case .int64Type(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringType, .stringType): return {
        guard case .stringType(let l) = lhs, case .stringType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _sizeRange: SizeRange? = nil
}

public struct StateFeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: StateFeatureType.OneOf_Type? = nil

  public var arrayType: ArrayFeatureType {
    get {
      if case .arrayType(let v)? = type {return v}
      return ArrayFeatureType()
    }
    set {type = .arrayType(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case arrayType(ArrayFeatureType)

  #if !swift(>=4.1)
    public static func ==(lhs: StateFeatureType.OneOf_Type, rhs: StateFeatureType.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.arrayType, .arrayType): return {
        guard case .arrayType(let l) = lhs, case .arrayType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

///
/// A feature, which may be optional.
public struct FeatureType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: FeatureType.OneOf_Type? = nil

  public var int64Type: Int64FeatureType {
    get {
      if case .int64Type(let v)? = type {return v}
      return Int64FeatureType()
    }
    set {type = .int64Type(newValue)}
  }

  public var doubleType: DoubleFeatureType {
    get {
      if case .doubleType(let v)? = type {return v}
      return DoubleFeatureType()
    }
    set {type = .doubleType(newValue)}
  }

  public var stringType: StringFeatureType {
    get {
      if case .stringType(let v)? = type {return v}
      return StringFeatureType()
    }
    set {type = .stringType(newValue)}
  }

  public var imageType: ImageFeatureType {
    get {
      if case .imageType(let v)? = type {return v}
      return ImageFeatureType()
    }
    set {type = .imageType(newValue)}
  }

  public var multiArrayType: ArrayFeatureType {
    get {
      if case .multiArrayType(let v)? = type {return v}
      return ArrayFeatureType()
    }
    set {type = .multiArrayType(newValue)}
  }

  public var dictionaryType: DictionaryFeatureType {
    get {
      if case .dictionaryType(let v)? = type {return v}
      return DictionaryFeatureType()
    }
    set {type = .dictionaryType(newValue)}
  }

  public var sequenceType: SequenceFeatureType {
    get {
      if case .sequenceType(let v)? = type {return v}
      return SequenceFeatureType()
    }
    set {type = .sequenceType(newValue)}
  }

  public var stateType: StateFeatureType {
    get {
      if case .stateType(let v)? = type {return v}
      return StateFeatureType()
    }
    set {type = .stateType(newValue)}
  }

  public var isOptional: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case int64Type(Int64FeatureType)
    case doubleType(DoubleFeatureType)
    case stringType(StringFeatureType)
    case imageType(ImageFeatureType)
    case multiArrayType(ArrayFeatureType)
    case dictionaryType(DictionaryFeatureType)
    case sequenceType(SequenceFeatureType)
    case stateType(StateFeatureType)

  #if !swift(>=4.1)
    public static func ==(lhs: FeatureType.OneOf_Type, rhs: FeatureType.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.int64Type, .int64Type): return {
        guard case .int64Type(let l) = lhs, case .int64Type(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleType, .doubleType): return {
        guard case .doubleType(let l) = lhs, case .doubleType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringType, .stringType): return {
        guard case .stringType(let l) = lhs, case .stringType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imageType, .imageType): return {
        guard case .imageType(let l) = lhs, case .imageType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multiArrayType, .multiArrayType): return {
        guard case .multiArrayType(let l) = lhs, case .multiArrayType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dictionaryType, .dictionaryType): return {
        guard case .dictionaryType(let l) = lhs, case .dictionaryType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sequenceType, .sequenceType): return {
        guard case .sequenceType(let l) = lhs, case .sequenceType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stateType, .stateType): return {
        guard case .stateType(let l) = lhs, case .stateType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Int64FeatureType: @unchecked Sendable {}
extension DoubleFeatureType: @unchecked Sendable {}
extension StringFeatureType: @unchecked Sendable {}
extension SizeRange: @unchecked Sendable {}
extension ImageFeatureType: @unchecked Sendable {}
extension ImageFeatureType.OneOf_SizeFlexibility: @unchecked Sendable {}
extension ImageFeatureType.ColorSpace: @unchecked Sendable {}
extension ImageFeatureType.ImageSize: @unchecked Sendable {}
extension ImageFeatureType.EnumeratedImageSizes: @unchecked Sendable {}
extension ImageFeatureType.ImageSizeRange: @unchecked Sendable {}
extension ArrayFeatureType: @unchecked Sendable {}
extension ArrayFeatureType.OneOf_ShapeFlexibility: @unchecked Sendable {}
extension ArrayFeatureType.OneOf_DefaultOptionalValue: @unchecked Sendable {}
extension ArrayFeatureType.ArrayDataType: @unchecked Sendable {}
extension ArrayFeatureType.Shape: @unchecked Sendable {}
extension ArrayFeatureType.EnumeratedShapes: @unchecked Sendable {}
extension ArrayFeatureType.ShapeRange: @unchecked Sendable {}
extension DictionaryFeatureType: @unchecked Sendable {}
extension DictionaryFeatureType.OneOf_KeyType: @unchecked Sendable {}
extension SequenceFeatureType: @unchecked Sendable {}
extension SequenceFeatureType.OneOf_Type: @unchecked Sendable {}
extension StateFeatureType: @unchecked Sendable {}
extension StateFeatureType.OneOf_Type: @unchecked Sendable {}
extension FeatureType: @unchecked Sendable {}
extension FeatureType.OneOf_Type: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension Int64FeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Int64FeatureType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Int64FeatureType, rhs: Int64FeatureType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DoubleFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleFeatureType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DoubleFeatureType, rhs: DoubleFeatureType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StringFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringFeatureType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StringFeatureType, rhs: StringFeatureType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SizeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SizeRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lowerBound"),
    2: .same(proto: "upperBound"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.lowerBound) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.upperBound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lowerBound != 0 {
      try visitor.visitSingularUInt64Field(value: self.lowerBound, fieldNumber: 1)
    }
    if self.upperBound != 0 {
      try visitor.visitSingularInt64Field(value: self.upperBound, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SizeRange, rhs: SizeRange) -> Bool {
    if lhs.lowerBound != rhs.lowerBound {return false}
    if lhs.upperBound != rhs.upperBound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageFeatureType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    21: .same(proto: "enumeratedSizes"),
    31: .same(proto: "imageSizeRange"),
    3: .same(proto: "colorSpace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.colorSpace) }()
      case 21: try {
        var v: ImageFeatureType.EnumeratedImageSizes?
        var hadOneofValue = false
        if let current = self.sizeFlexibility {
          hadOneofValue = true
          if case .enumeratedSizes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sizeFlexibility = .enumeratedSizes(v)
        }
      }()
      case 31: try {
        var v: ImageFeatureType.ImageSizeRange?
        var hadOneofValue = false
        if let current = self.sizeFlexibility {
          hadOneofValue = true
          if case .imageSizeRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sizeFlexibility = .imageSizeRange(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.width != 0 {
      try visitor.visitSingularInt64Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.colorSpace != .invalidColorSpace {
      try visitor.visitSingularEnumField(value: self.colorSpace, fieldNumber: 3)
    }
    switch self.sizeFlexibility {
    case .enumeratedSizes?: try {
      guard case .enumeratedSizes(let v)? = self.sizeFlexibility else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .imageSizeRange?: try {
      guard case .imageSizeRange(let v)? = self.sizeFlexibility else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageFeatureType, rhs: ImageFeatureType) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.sizeFlexibility != rhs.sizeFlexibility {return false}
    if lhs.colorSpace != rhs.colorSpace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageFeatureType.ColorSpace: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_COLOR_SPACE"),
    10: .same(proto: "GRAYSCALE"),
    20: .same(proto: "RGB"),
    30: .same(proto: "BGR"),
    40: .same(proto: "GRAYSCALE_FLOAT16"),
  ]
}

extension ImageFeatureType.ImageSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageFeatureType.protoMessageName + ".ImageSize"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt64Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageFeatureType.ImageSize, rhs: ImageFeatureType.ImageSize) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageFeatureType.EnumeratedImageSizes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageFeatureType.protoMessageName + ".EnumeratedImageSizes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sizes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sizes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sizes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sizes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageFeatureType.EnumeratedImageSizes, rhs: ImageFeatureType.EnumeratedImageSizes) -> Bool {
    if lhs.sizes != rhs.sizes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageFeatureType.ImageSizeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ImageFeatureType.protoMessageName + ".ImageSizeRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "widthRange"),
    2: .same(proto: "heightRange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._widthRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._heightRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._widthRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._heightRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageFeatureType.ImageSizeRange, rhs: ImageFeatureType.ImageSizeRange) -> Bool {
    if lhs._widthRange != rhs._widthRange {return false}
    if lhs._heightRange != rhs._heightRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArrayFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArrayFeatureType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "dataType"),
    21: .same(proto: "enumeratedShapes"),
    31: .same(proto: "shapeRange"),
    41: .same(proto: "intDefaultValue"),
    51: .same(proto: "floatDefaultValue"),
    61: .same(proto: "doubleDefaultValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.shape) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dataType) }()
      case 21: try {
        var v: ArrayFeatureType.EnumeratedShapes?
        var hadOneofValue = false
        if let current = self.shapeFlexibility {
          hadOneofValue = true
          if case .enumeratedShapes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.shapeFlexibility = .enumeratedShapes(v)
        }
      }()
      case 31: try {
        var v: ArrayFeatureType.ShapeRange?
        var hadOneofValue = false
        if let current = self.shapeFlexibility {
          hadOneofValue = true
          if case .shapeRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.shapeFlexibility = .shapeRange(v)
        }
      }()
      case 41: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.defaultOptionalValue != nil {try decoder.handleConflictingOneOf()}
          self.defaultOptionalValue = .intDefaultValue(v)
        }
      }()
      case 51: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.defaultOptionalValue != nil {try decoder.handleConflictingOneOf()}
          self.defaultOptionalValue = .floatDefaultValue(v)
        }
      }()
      case 61: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.defaultOptionalValue != nil {try decoder.handleConflictingOneOf()}
          self.defaultOptionalValue = .doubleDefaultValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.shape, fieldNumber: 1)
    }
    if self.dataType != .invalidArrayDataType {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 2)
    }
    switch self.shapeFlexibility {
    case .enumeratedShapes?: try {
      guard case .enumeratedShapes(let v)? = self.shapeFlexibility else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .shapeRange?: try {
      guard case .shapeRange(let v)? = self.shapeFlexibility else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case nil: break
    }
    switch self.defaultOptionalValue {
    case .intDefaultValue?: try {
      guard case .intDefaultValue(let v)? = self.defaultOptionalValue else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
    }()
    case .floatDefaultValue?: try {
      guard case .floatDefaultValue(let v)? = self.defaultOptionalValue else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 51)
    }()
    case .doubleDefaultValue?: try {
      guard case .doubleDefaultValue(let v)? = self.defaultOptionalValue else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 61)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArrayFeatureType, rhs: ArrayFeatureType) -> Bool {
    if lhs.shape != rhs.shape {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs.shapeFlexibility != rhs.shapeFlexibility {return false}
    if lhs.defaultOptionalValue != rhs.defaultOptionalValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArrayFeatureType.ArrayDataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_ARRAY_DATA_TYPE"),
    65552: .same(proto: "FLOAT16"),
    65568: .same(proto: "FLOAT32"),
    65600: .same(proto: "DOUBLE"),
    131104: .same(proto: "INT32"),
  ]
}

extension ArrayFeatureType.Shape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ArrayFeatureType.protoMessageName + ".Shape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.shape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.shape, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArrayFeatureType.Shape, rhs: ArrayFeatureType.Shape) -> Bool {
    if lhs.shape != rhs.shape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArrayFeatureType.EnumeratedShapes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ArrayFeatureType.protoMessageName + ".EnumeratedShapes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shapes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shapes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shapes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shapes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArrayFeatureType.EnumeratedShapes, rhs: ArrayFeatureType.EnumeratedShapes) -> Bool {
    if lhs.shapes != rhs.shapes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArrayFeatureType.ShapeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ArrayFeatureType.protoMessageName + ".ShapeRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sizeRanges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sizeRanges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sizeRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sizeRanges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArrayFeatureType.ShapeRange, rhs: ArrayFeatureType.ShapeRange) -> Bool {
    if lhs.sizeRanges != rhs.sizeRanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DictionaryFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DictionaryFeatureType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "int64KeyType"),
    2: .same(proto: "stringKeyType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64FeatureType?
        var hadOneofValue = false
        if let current = self.keyType {
          hadOneofValue = true
          if case .int64KeyType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.keyType = .int64KeyType(v)
        }
      }()
      case 2: try {
        var v: StringFeatureType?
        var hadOneofValue = false
        if let current = self.keyType {
          hadOneofValue = true
          if case .stringKeyType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.keyType = .stringKeyType(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.keyType {
    case .int64KeyType?: try {
      guard case .int64KeyType(let v)? = self.keyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stringKeyType?: try {
      guard case .stringKeyType(let v)? = self.keyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DictionaryFeatureType, rhs: DictionaryFeatureType) -> Bool {
    if lhs.keyType != rhs.keyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SequenceFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SequenceFeatureType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "int64Type"),
    3: .same(proto: "stringType"),
    101: .same(proto: "sizeRange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64FeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .int64Type(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .int64Type(v)
        }
      }()
      case 3: try {
        var v: StringFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .stringType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .stringType(v)
        }
      }()
      case 101: try { try decoder.decodeSingularMessageField(value: &self._sizeRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .int64Type?: try {
      guard case .int64Type(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stringType?: try {
      guard case .stringType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._sizeRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SequenceFeatureType, rhs: SequenceFeatureType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._sizeRange != rhs._sizeRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StateFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateFeatureType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arrayType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ArrayFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .arrayType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .arrayType(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .arrayType(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StateFeatureType, rhs: StateFeatureType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeatureType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "int64Type"),
    2: .same(proto: "doubleType"),
    3: .same(proto: "stringType"),
    4: .same(proto: "imageType"),
    5: .same(proto: "multiArrayType"),
    6: .same(proto: "dictionaryType"),
    7: .same(proto: "sequenceType"),
    8: .same(proto: "stateType"),
    1000: .same(proto: "isOptional"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64FeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .int64Type(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .int64Type(v)
        }
      }()
      case 2: try {
        var v: DoubleFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .doubleType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .doubleType(v)
        }
      }()
      case 3: try {
        var v: StringFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .stringType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .stringType(v)
        }
      }()
      case 4: try {
        var v: ImageFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .imageType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .imageType(v)
        }
      }()
      case 5: try {
        var v: ArrayFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .multiArrayType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .multiArrayType(v)
        }
      }()
      case 6: try {
        var v: DictionaryFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .dictionaryType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .dictionaryType(v)
        }
      }()
      case 7: try {
        var v: SequenceFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .sequenceType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .sequenceType(v)
        }
      }()
      case 8: try {
        var v: StateFeatureType?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .stateType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .stateType(v)
        }
      }()
      case 1000: try { try decoder.decodeSingularBoolField(value: &self.isOptional) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .int64Type?: try {
      guard case .int64Type(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .doubleType?: try {
      guard case .doubleType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stringType?: try {
      guard case .stringType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .imageType?: try {
      guard case .imageType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .multiArrayType?: try {
      guard case .multiArrayType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .dictionaryType?: try {
      guard case .dictionaryType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .sequenceType?: try {
      guard case .sequenceType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .stateType?: try {
      guard case .stateType(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    if self.isOptional != false {
      try visitor.visitSingularBoolField(value: self.isOptional, fieldNumber: 1000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FeatureType, rhs: FeatureType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.isOptional != rhs.isOptional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
