// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: MIL.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2019, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

//
// - A Program is the container with following information
//     - set of functions: Function defines a program block to be executed
//     - A model can have multiple functions defined and will have a single point of entry.
// - A Function consists of
//     - List of named inputs and output types
//     - A block defining scope for a function - similar to a function in C/C++
// - A Block consists of
//     - List of named inputs and output names
//     - Topologically sorted Ops
// - A Op consists of
//     - List of named inputs and outputs (name, type) pair
//     - Optionally, blocks for Control-Flow
//
// Programs, functions, blocks, ops, and tensor types all can contain an optional set of attributes.
//
// == Identifiers ==
// Identifiers, generally used for names and keys, must match the
// regular expression [A-Za-z\_][A-Za-z0-9\_@]*

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Supported data types
public enum MILSpec_DataType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 0-10 reserved for special types
  case unusedType // = 0
  case bool // = 1

  /// arbitrary sequence of bytes
  case string // = 2

  /// Floats
  case float8E4M3Fn // = 40
  case float8E5M2 // = 41
  case float16 // = 10
  case float32 // = 11
  case float64 // = 12
  case bfloat16 // = 13

  /// Ints
  case int8 // = 21
  case int16 // = 22
  case int32 // = 23
  case int64 // = 24
  case int4 // = 25

  /// UInts
  case uint8 // = 31
  case uint16 // = 32
  case uint32 // = 33
  case uint64 // = 34
  case uint4 // = 35
  case uint2 // = 36
  case uint1 // = 37
  case uint6 // = 38
  case uint3 // = 39
  case UNRECOGNIZED(Int)

  public init() {
    self = .unusedType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unusedType
    case 1: self = .bool
    case 2: self = .string
    case 10: self = .float16
    case 11: self = .float32
    case 12: self = .float64
    case 13: self = .bfloat16
    case 21: self = .int8
    case 22: self = .int16
    case 23: self = .int32
    case 24: self = .int64
    case 25: self = .int4
    case 31: self = .uint8
    case 32: self = .uint16
    case 33: self = .uint32
    case 34: self = .uint64
    case 35: self = .uint4
    case 36: self = .uint2
    case 37: self = .uint1
    case 38: self = .uint6
    case 39: self = .uint3
    case 40: self = .float8E4M3Fn
    case 41: self = .float8E5M2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unusedType: return 0
    case .bool: return 1
    case .string: return 2
    case .float16: return 10
    case .float32: return 11
    case .float64: return 12
    case .bfloat16: return 13
    case .int8: return 21
    case .int16: return 22
    case .int32: return 23
    case .int64: return 24
    case .int4: return 25
    case .uint8: return 31
    case .uint16: return 32
    case .uint32: return 33
    case .uint64: return 34
    case .uint4: return 35
    case .uint2: return 36
    case .uint1: return 37
    case .uint6: return 38
    case .uint3: return 39
    case .float8E4M3Fn: return 40
    case .float8E5M2: return 41
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [MILSpec_DataType] = [
    .unusedType,
    .bool,
    .string,
    .float8E4M3Fn,
    .float8E5M2,
    .float16,
    .float32,
    .float64,
    .bfloat16,
    .int8,
    .int16,
    .int32,
    .int64,
    .int4,
    .uint8,
    .uint16,
    .uint32,
    .uint64,
    .uint4,
    .uint2,
    .uint1,
    .uint6,
    .uint3,
  ]

}

/// The top level container.
public struct MILSpec_Program: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Int64 = 0

  /// Must be unique within the containing program
  /// Names must be valid identifiers as described above.
  public var functions: Dictionary<String,MILSpec_Function> = [:]

  public var docString: String = String()

  /// Any other attributes not described by other fields.
  /// Keys must be valid identifiers as described above.
  public var attributes: Dictionary<String,MILSpec_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A program-level function.
public struct MILSpec_Function: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Function inputs are unordered (name, ValueType) pairs.
  /// Inputs intended to process images must be rank-4 Float32 tensors. Dimensions
  /// are interpreted as NCHW, with N == 1 and C being 1 for grayscale and 3 for RGB.
  /// Names must be valid identifiers as described above.
  public var inputs: [MILSpec_NamedValueType] = []

  /// The active block is drawn from this named specialization.
  /// This key must exist in `block_specializations`.
  public var opset: String = String()

  /// Named specializations of this function.
  ///
  /// Specialization keys are the name of the opset that the
  /// function specialization is written in. They must be valid
  /// identifiers as described above.
  ///
  /// Outputs from all blocks must match. They define the outputs
  /// of the function.
  /// Each block inherits the lexical scope from the function.
  public var blockSpecializations: Dictionary<String,MILSpec_Block> = [:]

  /// Any other attributes not described by other fields.
  /// Keys must be valid identifiers as described above.
  public var attributes: Dictionary<String,MILSpec_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A basic block with a single entry and exit in SSA form.
public struct MILSpec_Block: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Infrequently used, these are for operators that may need to give
  /// block-local names to input values (e.g. while_loop).
  public var inputs: [MILSpec_NamedValueType] = []

  /// The names to give to values returned by this block. They must be
  /// identifiers as described above.
  ///
  /// ValueType of outputs[i] is Operation[j].outputs[k].type where
  /// i, j and k are indices of block output, block Operation and
  /// jth operation's output respectively.
  /// this is due to
  /// 1. An operation can have more than one output
  /// 2. Any one of operation's output could be potentially block's output
  public var outputs: [String] = []

  public var operations: [MILSpec_Operation] = []

  /// Any other attributes not described by other fields.
  /// Keys must be valid identifiers as described above.
  public var attributes: Dictionary<String,MILSpec_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Argument is list of Binding to either name or value
public struct MILSpec_Argument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var arguments: [MILSpec_Argument.Binding] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Binding: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var binding: MILSpec_Argument.Binding.OneOf_Binding? = nil

    /// The name of a previously defined value.
    public var name: String {
      get {
        if case .name(let v)? = binding {return v}
        return String()
      }
      set {binding = .name(newValue)}
    }

    /// A compile time constant.
    public var value: MILSpec_Value {
      get {
        if case .value(let v)? = binding {return v}
        return MILSpec_Value()
      }
      set {binding = .value(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Binding: Equatable, Sendable {
      /// The name of a previously defined value.
      case name(String)
      /// A compile time constant.
      case value(MILSpec_Value)

    }

    public init() {}
  }

  public init() {}
}

/// A single operation/node/layer.
public struct MILSpec_Operation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Examples: "convolution", "cropResize". Operation type defines the
  /// expected inputs and output.
  public var type: String = String()

  /// Operator arguments
  ///
  /// Key: parameter name
  /// Value: Argument (list of bindings)
  ///
  /// Value is list of argument binding to given parameter
  /// Binding can be a string name (previous operation output or input given to model/block/function)
  ///             or a Value (known compile time value for given operation)
  /// Argument can be of length 1 (general) or variable length (e.g. concat layer)
  /// e.g. {'stride' : ['input_01']}
  /// e.g. {'x' : ['input_01', 'input_02', 'input_03', false]}
  public var inputs: Dictionary<String,MILSpec_Argument> = [:]

  /// Names to which to bind values returned by this operation.
  /// Names must be:
  ///  (*) valid identifiers as described above; and
  ///  (*) unique within the current scope.
  public var outputs: [MILSpec_NamedValueType] = []

  /// Nested blocks for loops and conditionals. For example,
  /// a conditional block will have two entries here.
  public var blocks: [MILSpec_Block] = []

  /// Any other information not captured by other fields.
  /// Keys must be valid identifiers as described above.
  public var attributes: Dictionary<String,MILSpec_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Named Value parameters
/// (name, type) pair
public struct MILSpec_NamedValueType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of this parameter; must be a valid identifier as described above.
  public var name: String = String()

  /// This parameter's required type.
  public var type: MILSpec_ValueType {
    get {return _type ?? MILSpec_ValueType()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: MILSpec_ValueType? = nil
}

/// A type of any kind
public struct MILSpec_ValueType: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var tensorType: MILSpec_TensorType {
    get {
      if case .tensorType(let v)? = _storage._type {return v}
      return MILSpec_TensorType()
    }
    set {_uniqueStorage()._type = .tensorType(newValue)}
  }

  public var listType: MILSpec_ListType {
    get {
      if case .listType(let v)? = _storage._type {return v}
      return MILSpec_ListType()
    }
    set {_uniqueStorage()._type = .listType(newValue)}
  }

  public var tupleType: MILSpec_TupleType {
    get {
      if case .tupleType(let v)? = _storage._type {return v}
      return MILSpec_TupleType()
    }
    set {_uniqueStorage()._type = .tupleType(newValue)}
  }

  public var dictionaryType: MILSpec_DictionaryType {
    get {
      if case .dictionaryType(let v)? = _storage._type {return v}
      return MILSpec_DictionaryType()
    }
    set {_uniqueStorage()._type = .dictionaryType(newValue)}
  }

  public var stateType: MILSpec_StateType {
    get {
      if case .stateType(let v)? = _storage._type {return v}
      return MILSpec_StateType()
    }
    set {_uniqueStorage()._type = .stateType(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case tensorType(MILSpec_TensorType)
    case listType(MILSpec_ListType)
    case tupleType(MILSpec_TupleType)
    case dictionaryType(MILSpec_DictionaryType)
    case stateType(MILSpec_StateType)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MILSpec_TensorType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The data type stored in a tensor of this type
  public var dataType: MILSpec_DataType = .unusedType

  /// The number of dimensions in the tensor shape. rank == -1 implies
  /// variable (not fixed) rank
  public var rank: Int64 = 0

  /// Tensor shape values; must be of length "rank"
  public var dimensions: [MILSpec_Dimension] = []

  /// Any other tensor type attributes not described by other fields.
  /// Keys must be valid identifiers in MIL text syntax.
  public var attributes: Dictionary<String,MILSpec_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MILSpec_TupleType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Recursively define TupleType from ValueType.
  public var types: [MILSpec_ValueType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MILSpec_ListType: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of element stored in a list of this type
  public var type: MILSpec_ValueType {
    get {return _storage._type ?? MILSpec_ValueType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// The number of elements in a list of this type. May be unknown (variable length)
  public var length: MILSpec_Dimension {
    get {return _storage._length ?? MILSpec_Dimension()}
    set {_uniqueStorage()._length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  public var hasLength: Bool {return _storage._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  public mutating func clearLength() {_uniqueStorage()._length = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An unordered key-value mapping
public struct MILSpec_DictionaryType: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyType: MILSpec_ValueType {
    get {return _storage._keyType ?? MILSpec_ValueType()}
    set {_uniqueStorage()._keyType = newValue}
  }
  /// Returns true if `keyType` has been explicitly set.
  public var hasKeyType: Bool {return _storage._keyType != nil}
  /// Clears the value of `keyType`. Subsequent reads from it will return its default value.
  public mutating func clearKeyType() {_uniqueStorage()._keyType = nil}

  public var valueType: MILSpec_ValueType {
    get {return _storage._valueType ?? MILSpec_ValueType()}
    set {_uniqueStorage()._valueType = newValue}
  }
  /// Returns true if `valueType` has been explicitly set.
  public var hasValueType: Bool {return _storage._valueType != nil}
  /// Clears the value of `valueType`. Subsequent reads from it will return its default value.
  public mutating func clearValueType() {_uniqueStorage()._valueType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MILSpec_StateType: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var wrappedType: MILSpec_ValueType {
    get {return _storage._wrappedType ?? MILSpec_ValueType()}
    set {_uniqueStorage()._wrappedType = newValue}
  }
  /// Returns true if `wrappedType` has been explicitly set.
  public var hasWrappedType: Bool {return _storage._wrappedType != nil}
  /// Clears the value of `wrappedType`. Subsequent reads from it will return its default value.
  public mutating func clearWrappedType() {_uniqueStorage()._wrappedType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MILSpec_Dimension: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dimension: MILSpec_Dimension.OneOf_Dimension? = nil

  public var constant: MILSpec_Dimension.ConstantDimension {
    get {
      if case .constant(let v)? = dimension {return v}
      return MILSpec_Dimension.ConstantDimension()
    }
    set {dimension = .constant(newValue)}
  }

  public var unknown: MILSpec_Dimension.UnknownDimension {
    get {
      if case .unknown(let v)? = dimension {return v}
      return MILSpec_Dimension.UnknownDimension()
    }
    set {dimension = .unknown(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Dimension: Equatable, Sendable {
    case constant(MILSpec_Dimension.ConstantDimension)
    case unknown(MILSpec_Dimension.UnknownDimension)

  }

  public struct ConstantDimension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var size: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct UnknownDimension: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var variadic: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// See Variable vs Value primer above.
public struct MILSpec_Value: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// optional human-readable texts.
  public var docString: String = String()

  public var type: MILSpec_ValueType {
    get {return _type ?? MILSpec_ValueType()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var value: MILSpec_Value.OneOf_Value? = nil

  public var immediateValue: MILSpec_Value.ImmediateValue {
    get {
      if case .immediateValue(let v)? = value {return v}
      return MILSpec_Value.ImmediateValue()
    }
    set {value = .immediateValue(newValue)}
  }

  public var blobFileValue: MILSpec_Value.BlobFileValue {
    get {
      if case .blobFileValue(let v)? = value {return v}
      return MILSpec_Value.BlobFileValue()
    }
    set {value = .blobFileValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable, Sendable {
    case immediateValue(MILSpec_Value.ImmediateValue)
    case blobFileValue(MILSpec_Value.BlobFileValue)

  }

  /// An immediate value stored within the proto
  public struct ImmediateValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: MILSpec_Value.ImmediateValue.OneOf_Value? = nil

    public var tensor: MILSpec_TensorValue {
      get {
        if case .tensor(let v)? = value {return v}
        return MILSpec_TensorValue()
      }
      set {value = .tensor(newValue)}
    }

    public var tuple: MILSpec_TupleValue {
      get {
        if case .tuple(let v)? = value {return v}
        return MILSpec_TupleValue()
      }
      set {value = .tuple(newValue)}
    }

    public var list: MILSpec_ListValue {
      get {
        if case .list(let v)? = value {return v}
        return MILSpec_ListValue()
      }
      set {value = .list(newValue)}
    }

    public var dictionary: MILSpec_DictionaryValue {
      get {
        if case .dictionary(let v)? = value {return v}
        return MILSpec_DictionaryValue()
      }
      set {value = .dictionary(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Value: Equatable, Sendable {
      case tensor(MILSpec_TensorValue)
      case tuple(MILSpec_TupleValue)
      case list(MILSpec_ListValue)
      case dictionary(MILSpec_DictionaryValue)

    }

    public init() {}
  }

  /// Reference to a "blob v2" storage file
  public struct BlobFileValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// name of file
    public var fileName: String = String()

    /// byte offset to metadata
    public var offset: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _type: MILSpec_ValueType? = nil
}

public struct MILSpec_TensorValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: MILSpec_TensorValue.OneOf_Value? = nil

  public var floats: MILSpec_TensorValue.RepeatedFloats {
    get {
      if case .floats(let v)? = value {return v}
      return MILSpec_TensorValue.RepeatedFloats()
    }
    set {value = .floats(newValue)}
  }

  public var ints: MILSpec_TensorValue.RepeatedInts {
    get {
      if case .ints(let v)? = value {return v}
      return MILSpec_TensorValue.RepeatedInts()
    }
    set {value = .ints(newValue)}
  }

  public var bools: MILSpec_TensorValue.RepeatedBools {
    get {
      if case .bools(let v)? = value {return v}
      return MILSpec_TensorValue.RepeatedBools()
    }
    set {value = .bools(newValue)}
  }

  public var strings: MILSpec_TensorValue.RepeatedStrings {
    get {
      if case .strings(let v)? = value {return v}
      return MILSpec_TensorValue.RepeatedStrings()
    }
    set {value = .strings(newValue)}
  }

  public var longInts: MILSpec_TensorValue.RepeatedLongInts {
    get {
      if case .longInts(let v)? = value {return v}
      return MILSpec_TensorValue.RepeatedLongInts()
    }
    set {value = .longInts(newValue)}
  }

  public var doubles: MILSpec_TensorValue.RepeatedDoubles {
    get {
      if case .doubles(let v)? = value {return v}
      return MILSpec_TensorValue.RepeatedDoubles()
    }
    set {value = .doubles(newValue)}
  }

  public var bytes: MILSpec_TensorValue.RepeatedBytes {
    get {
      if case .bytes(let v)? = value {return v}
      return MILSpec_TensorValue.RepeatedBytes()
    }
    set {value = .bytes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable, Sendable {
    case floats(MILSpec_TensorValue.RepeatedFloats)
    case ints(MILSpec_TensorValue.RepeatedInts)
    case bools(MILSpec_TensorValue.RepeatedBools)
    case strings(MILSpec_TensorValue.RepeatedStrings)
    case longInts(MILSpec_TensorValue.RepeatedLongInts)
    case doubles(MILSpec_TensorValue.RepeatedDoubles)
    case bytes(MILSpec_TensorValue.RepeatedBytes)

  }

  public struct RepeatedFloats: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Float] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RepeatedDoubles: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Double] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RepeatedInts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Int32] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RepeatedLongInts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RepeatedBools: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Bool] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RepeatedStrings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RepeatedBytes: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct MILSpec_TupleValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Comment: TupleValue is recursively defined from Value.
  public var values: [MILSpec_Value] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MILSpec_ListValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [MILSpec_Value] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MILSpec_DictionaryValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [MILSpec_DictionaryValue.KeyValuePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct KeyValuePair: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: MILSpec_Value {
      get {return _key ?? MILSpec_Value()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {self._key = nil}

    public var value: MILSpec_Value {
      get {return _value ?? MILSpec_Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _key: MILSpec_Value? = nil
    fileprivate var _value: MILSpec_Value? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification.MILSpec"

extension MILSpec_DataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED_TYPE"),
    1: .same(proto: "BOOL"),
    2: .same(proto: "STRING"),
    10: .same(proto: "FLOAT16"),
    11: .same(proto: "FLOAT32"),
    12: .same(proto: "FLOAT64"),
    13: .same(proto: "BFLOAT16"),
    21: .same(proto: "INT8"),
    22: .same(proto: "INT16"),
    23: .same(proto: "INT32"),
    24: .same(proto: "INT64"),
    25: .same(proto: "INT4"),
    31: .same(proto: "UINT8"),
    32: .same(proto: "UINT16"),
    33: .same(proto: "UINT32"),
    34: .same(proto: "UINT64"),
    35: .same(proto: "UINT4"),
    36: .same(proto: "UINT2"),
    37: .same(proto: "UINT1"),
    38: .same(proto: "UINT6"),
    39: .same(proto: "UINT3"),
    40: .same(proto: "FLOAT8E4M3FN"),
    41: .same(proto: "FLOAT8E5M2"),
  ]
}

extension MILSpec_Program: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Program"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "functions"),
    3: .same(proto: "docString"),
    4: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Function>.self, value: &self.functions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.functions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Function>.self, value: self.functions, fieldNumber: 2)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 3)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: self.attributes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Program, rhs: MILSpec_Program) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.functions != rhs.functions {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Function: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Function"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "opset"),
    3: .standard(proto: "block_specializations"),
    4: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.opset) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Block>.self, value: &self.blockSpecializations) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.opset.isEmpty {
      try visitor.visitSingularStringField(value: self.opset, fieldNumber: 2)
    }
    if !self.blockSpecializations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Block>.self, value: self.blockSpecializations, fieldNumber: 3)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: self.attributes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Function, rhs: MILSpec_Function) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.opset != rhs.opset {return false}
    if lhs.blockSpecializations != rhs.blockSpecializations {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "outputs"),
    3: .same(proto: "operations"),
    4: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.outputs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputs, fieldNumber: 2)
    }
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 3)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: self.attributes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Block, rhs: MILSpec_Block) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Argument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Argument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arguments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.arguments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Argument, rhs: MILSpec_Argument) -> Bool {
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Argument.Binding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_Argument.protoMessageName + ".Binding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.binding != nil {try decoder.handleConflictingOneOf()}
          self.binding = .name(v)
        }
      }()
      case 2: try {
        var v: MILSpec_Value?
        var hadOneofValue = false
        if let current = self.binding {
          hadOneofValue = true
          if case .value(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.binding = .value(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.binding {
    case .name?: try {
      guard case .name(let v)? = self.binding else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .value?: try {
      guard case .value(let v)? = self.binding else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Argument.Binding, rhs: MILSpec_Argument.Binding) -> Bool {
    if lhs.binding != rhs.binding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "inputs"),
    3: .same(proto: "outputs"),
    4: .same(proto: "blocks"),
    5: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Argument>.self, value: &self.inputs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Argument>.self, value: self.inputs, fieldNumber: 2)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 3)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 4)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: self.attributes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Operation, rhs: MILSpec_Operation) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_NamedValueType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedValueType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_NamedValueType, rhs: MILSpec_NamedValueType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_ValueType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tensorType"),
    2: .same(proto: "listType"),
    3: .same(proto: "tupleType"),
    4: .same(proto: "dictionaryType"),
    5: .same(proto: "stateType"),
  ]

  fileprivate class _StorageClass {
    var _type: MILSpec_ValueType.OneOf_Type?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: MILSpec_TensorType?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .tensorType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .tensorType(v)
          }
        }()
        case 2: try {
          var v: MILSpec_ListType?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .listType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .listType(v)
          }
        }()
        case 3: try {
          var v: MILSpec_TupleType?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .tupleType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .tupleType(v)
          }
        }()
        case 4: try {
          var v: MILSpec_DictionaryType?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .dictionaryType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .dictionaryType(v)
          }
        }()
        case 5: try {
          var v: MILSpec_StateType?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .stateType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .stateType(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._type {
      case .tensorType?: try {
        guard case .tensorType(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .listType?: try {
        guard case .listType(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .tupleType?: try {
        guard case .tupleType(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .dictionaryType?: try {
        guard case .dictionaryType(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .stateType?: try {
        guard case .stateType(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_ValueType, rhs: MILSpec_ValueType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TensorType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataType"),
    2: .same(proto: "rank"),
    3: .same(proto: "dimensions"),
    4: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dataType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.rank) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.dimensions) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dataType != .unusedType {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 1)
    }
    if self.rank != 0 {
      try visitor.visitSingularInt64Field(value: self.rank, fieldNumber: 2)
    }
    if !self.dimensions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dimensions, fieldNumber: 3)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,MILSpec_Value>.self, value: self.attributes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorType, rhs: MILSpec_TensorType) -> Bool {
    if lhs.dataType != rhs.dataType {return false}
    if lhs.rank != rhs.rank {return false}
    if lhs.dimensions != rhs.dimensions {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TupleType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TupleType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.types) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.types.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.types, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TupleType, rhs: MILSpec_TupleType) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_ListType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "length"),
  ]

  fileprivate class _StorageClass {
    var _type: MILSpec_ValueType? = nil
    var _length: MILSpec_Dimension? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _length = source._length
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._length) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._length {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_ListType, rhs: MILSpec_ListType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._length != rhs_storage._length {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_DictionaryType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DictionaryType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyType"),
    2: .same(proto: "valueType"),
  ]

  fileprivate class _StorageClass {
    var _keyType: MILSpec_ValueType? = nil
    var _valueType: MILSpec_ValueType? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _keyType = source._keyType
      _valueType = source._valueType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._keyType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._valueType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._keyType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._valueType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_DictionaryType, rhs: MILSpec_DictionaryType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyType != rhs_storage._keyType {return false}
        if _storage._valueType != rhs_storage._valueType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_StateType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wrappedType"),
  ]

  fileprivate class _StorageClass {
    var _wrappedType: MILSpec_ValueType? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _wrappedType = source._wrappedType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._wrappedType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._wrappedType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_StateType, rhs: MILSpec_StateType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._wrappedType != rhs_storage._wrappedType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Dimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dimension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "constant"),
    2: .same(proto: "unknown"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MILSpec_Dimension.ConstantDimension?
        var hadOneofValue = false
        if let current = self.dimension {
          hadOneofValue = true
          if case .constant(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dimension = .constant(v)
        }
      }()
      case 2: try {
        var v: MILSpec_Dimension.UnknownDimension?
        var hadOneofValue = false
        if let current = self.dimension {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dimension = .unknown(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.dimension {
    case .constant?: try {
      guard case .constant(let v)? = self.dimension else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unknown?: try {
      guard case .unknown(let v)? = self.dimension else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Dimension, rhs: MILSpec_Dimension) -> Bool {
    if lhs.dimension != rhs.dimension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Dimension.ConstantDimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_Dimension.protoMessageName + ".ConstantDimension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Dimension.ConstantDimension, rhs: MILSpec_Dimension.ConstantDimension) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Dimension.UnknownDimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_Dimension.protoMessageName + ".UnknownDimension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variadic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.variadic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.variadic != false {
      try visitor.visitSingularBoolField(value: self.variadic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Dimension.UnknownDimension, rhs: MILSpec_Dimension.UnknownDimension) -> Bool {
    if lhs.variadic != rhs.variadic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Value"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "docString"),
    2: .same(proto: "type"),
    3: .same(proto: "immediateValue"),
    5: .same(proto: "blobFileValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 3: try {
        var v: MILSpec_Value.ImmediateValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .immediateValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .immediateValue(v)
        }
      }()
      case 5: try {
        var v: MILSpec_Value.BlobFileValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .blobFileValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .blobFileValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 1)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.value {
    case .immediateValue?: try {
      guard case .immediateValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .blobFileValue?: try {
      guard case .blobFileValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Value, rhs: MILSpec_Value) -> Bool {
    if lhs.docString != rhs.docString {return false}
    if lhs._type != rhs._type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Value.ImmediateValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_Value.protoMessageName + ".ImmediateValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tensor"),
    2: .same(proto: "tuple"),
    3: .same(proto: "list"),
    4: .same(proto: "dictionary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MILSpec_TensorValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .tensor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .tensor(v)
        }
      }()
      case 2: try {
        var v: MILSpec_TupleValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .tuple(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .tuple(v)
        }
      }()
      case 3: try {
        var v: MILSpec_ListValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .list(v)
        }
      }()
      case 4: try {
        var v: MILSpec_DictionaryValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .dictionary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .dictionary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .tensor?: try {
      guard case .tensor(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .tuple?: try {
      guard case .tuple(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .list?: try {
      guard case .list(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dictionary?: try {
      guard case .dictionary(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Value.ImmediateValue, rhs: MILSpec_Value.ImmediateValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_Value.BlobFileValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_Value.protoMessageName + ".BlobFileValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileName"),
    2: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt64Field(value: self.offset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_Value.BlobFileValue, rhs: MILSpec_Value.BlobFileValue) -> Bool {
    if lhs.fileName != rhs.fileName {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TensorValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "floats"),
    2: .same(proto: "ints"),
    3: .same(proto: "bools"),
    4: .same(proto: "strings"),
    5: .same(proto: "longInts"),
    6: .same(proto: "doubles"),
    7: .same(proto: "bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MILSpec_TensorValue.RepeatedFloats?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .floats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .floats(v)
        }
      }()
      case 2: try {
        var v: MILSpec_TensorValue.RepeatedInts?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .ints(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .ints(v)
        }
      }()
      case 3: try {
        var v: MILSpec_TensorValue.RepeatedBools?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .bools(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .bools(v)
        }
      }()
      case 4: try {
        var v: MILSpec_TensorValue.RepeatedStrings?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .strings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .strings(v)
        }
      }()
      case 5: try {
        var v: MILSpec_TensorValue.RepeatedLongInts?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .longInts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .longInts(v)
        }
      }()
      case 6: try {
        var v: MILSpec_TensorValue.RepeatedDoubles?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .doubles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .doubles(v)
        }
      }()
      case 7: try {
        var v: MILSpec_TensorValue.RepeatedBytes?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .bytes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .bytes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .floats?: try {
      guard case .floats(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ints?: try {
      guard case .ints(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bools?: try {
      guard case .bools(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .strings?: try {
      guard case .strings(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .longInts?: try {
      guard case .longInts(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .doubles?: try {
      guard case .doubles(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bytes?: try {
      guard case .bytes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorValue, rhs: MILSpec_TensorValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorValue.RepeatedFloats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_TensorValue.protoMessageName + ".RepeatedFloats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedFloatField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorValue.RepeatedFloats, rhs: MILSpec_TensorValue.RepeatedFloats) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorValue.RepeatedDoubles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_TensorValue.protoMessageName + ".RepeatedDoubles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedDoubleField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorValue.RepeatedDoubles, rhs: MILSpec_TensorValue.RepeatedDoubles) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorValue.RepeatedInts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_TensorValue.protoMessageName + ".RepeatedInts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedInt32Field(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorValue.RepeatedInts, rhs: MILSpec_TensorValue.RepeatedInts) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorValue.RepeatedLongInts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_TensorValue.protoMessageName + ".RepeatedLongInts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedInt64Field(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorValue.RepeatedLongInts, rhs: MILSpec_TensorValue.RepeatedLongInts) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorValue.RepeatedBools: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_TensorValue.protoMessageName + ".RepeatedBools"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedBoolField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorValue.RepeatedBools, rhs: MILSpec_TensorValue.RepeatedBools) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorValue.RepeatedStrings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_TensorValue.protoMessageName + ".RepeatedStrings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorValue.RepeatedStrings, rhs: MILSpec_TensorValue.RepeatedStrings) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TensorValue.RepeatedBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_TensorValue.protoMessageName + ".RepeatedBytes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitSingularBytesField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TensorValue.RepeatedBytes, rhs: MILSpec_TensorValue.RepeatedBytes) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_TupleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TupleValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_TupleValue, rhs: MILSpec_TupleValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_ListValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_ListValue, rhs: MILSpec_ListValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_DictionaryValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DictionaryValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_DictionaryValue, rhs: MILSpec_DictionaryValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MILSpec_DictionaryValue.KeyValuePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MILSpec_DictionaryValue.protoMessageName + ".KeyValuePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MILSpec_DictionaryValue.KeyValuePair, rhs: MILSpec_DictionaryValue.KeyValuePair) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
