// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ItemSimilarityRecommender.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Item Similarity Recommender
///
///  The Item Similarity recommender takes as input a list of items and scores,
///  then uses that information and a table of item similarities to predict similarity
///  scores for all items.  By default, the items predicted are most similar to the given
///  items but not part of that item set.
///
///  The predicted score for a given item k is
///    sum_(i in observed items)   sim_(k,i) * (score_i - shift_k)
///
///  Because only the most similar scores for each item i are stored,
///  sim_(k,i) is often zero.
///
///  For many models, the score adjustment parameter shift_j is zero -- it's occasionally used
///  to counteract global biases for popular items.
///
///
///  References:
public struct ItemSimilarityRecommender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itemItemSimilarities: [ItemSimilarityRecommender.SimilarItems] = []

  /// One or none of these are given.  If none are given, then the items must number 0, 1, ..., num_items - 1.
  ///  If either is given, the length must be exactly num_items.
  public var itemStringIds: StringVector {
    get {return _itemStringIds ?? StringVector()}
    set {_itemStringIds = newValue}
  }
  /// Returns true if `itemStringIds` has been explicitly set.
  public var hasItemStringIds: Bool {return self._itemStringIds != nil}
  /// Clears the value of `itemStringIds`. Subsequent reads from it will return its default value.
  public mutating func clearItemStringIds() {self._itemStringIds = nil}

  public var itemInt64Ids: Int64Vector {
    get {return _itemInt64Ids ?? Int64Vector()}
    set {_itemInt64Ids = newValue}
  }
  /// Returns true if `itemInt64Ids` has been explicitly set.
  public var hasItemInt64Ids: Bool {return self._itemInt64Ids != nil}
  /// Clears the value of `itemInt64Ids`. Subsequent reads from it will return its default value.
  public mutating func clearItemInt64Ids() {self._itemInt64Ids = nil}

  /// Input parameter names specifying different possible inputs to the recommender.
  public var itemInputFeatureName: String = String()

  /// Optional; defaults to all items if not given.
  public var numRecommendationsInputFeatureName: String = String()

  /// Optional. 
  public var itemRestrictionInputFeatureName: String = String()

  /// Optional; defaults to input item list if not given. 
  public var itemExclusionInputFeatureName: String = String()

  /// The predicted outputs.  At least one of these must be specified.
  public var recommendedItemListOutputFeatureName: String = String()

  public var recommendedItemScoreOutputFeatureName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The items similar to a given base item.
  public struct ConnectedItem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var itemID: UInt64 = 0

    public var similarityScore: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///  The formula for the score of a given model as given above, with shift_k
  ///   parameter given by itemScoreAdjustment, and the similar item list filling in
  ///   all the known sim(k,i) scores for i given by itemID and k given by the itemID parameter in
  ///   the similarItemList.
  public struct SimilarItems {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var itemID: UInt64 = 0

    public var similarItemList: [ItemSimilarityRecommender.ConnectedItem] = []

    public var itemScoreAdjustment: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _itemStringIds: StringVector? = nil
  fileprivate var _itemInt64Ids: Int64Vector? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ItemSimilarityRecommender: @unchecked Sendable {}
extension ItemSimilarityRecommender.ConnectedItem: @unchecked Sendable {}
extension ItemSimilarityRecommender.SimilarItems: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension ItemSimilarityRecommender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ItemSimilarityRecommender"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemItemSimilarities"),
    2: .same(proto: "itemStringIds"),
    3: .same(proto: "itemInt64Ids"),
    10: .same(proto: "itemInputFeatureName"),
    11: .same(proto: "numRecommendationsInputFeatureName"),
    12: .same(proto: "itemRestrictionInputFeatureName"),
    13: .same(proto: "itemExclusionInputFeatureName"),
    20: .same(proto: "recommendedItemListOutputFeatureName"),
    21: .same(proto: "recommendedItemScoreOutputFeatureName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.itemItemSimilarities) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._itemStringIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._itemInt64Ids) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.itemInputFeatureName) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.numRecommendationsInputFeatureName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.itemRestrictionInputFeatureName) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.itemExclusionInputFeatureName) }()
      case 20: try { try decoder.decodeSingularStringField(value: &self.recommendedItemListOutputFeatureName) }()
      case 21: try { try decoder.decodeSingularStringField(value: &self.recommendedItemScoreOutputFeatureName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.itemItemSimilarities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemItemSimilarities, fieldNumber: 1)
    }
    try { if let v = self._itemStringIds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._itemInt64Ids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.itemInputFeatureName.isEmpty {
      try visitor.visitSingularStringField(value: self.itemInputFeatureName, fieldNumber: 10)
    }
    if !self.numRecommendationsInputFeatureName.isEmpty {
      try visitor.visitSingularStringField(value: self.numRecommendationsInputFeatureName, fieldNumber: 11)
    }
    if !self.itemRestrictionInputFeatureName.isEmpty {
      try visitor.visitSingularStringField(value: self.itemRestrictionInputFeatureName, fieldNumber: 12)
    }
    if !self.itemExclusionInputFeatureName.isEmpty {
      try visitor.visitSingularStringField(value: self.itemExclusionInputFeatureName, fieldNumber: 13)
    }
    if !self.recommendedItemListOutputFeatureName.isEmpty {
      try visitor.visitSingularStringField(value: self.recommendedItemListOutputFeatureName, fieldNumber: 20)
    }
    if !self.recommendedItemScoreOutputFeatureName.isEmpty {
      try visitor.visitSingularStringField(value: self.recommendedItemScoreOutputFeatureName, fieldNumber: 21)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ItemSimilarityRecommender, rhs: ItemSimilarityRecommender) -> Bool {
    if lhs.itemItemSimilarities != rhs.itemItemSimilarities {return false}
    if lhs._itemStringIds != rhs._itemStringIds {return false}
    if lhs._itemInt64Ids != rhs._itemInt64Ids {return false}
    if lhs.itemInputFeatureName != rhs.itemInputFeatureName {return false}
    if lhs.numRecommendationsInputFeatureName != rhs.numRecommendationsInputFeatureName {return false}
    if lhs.itemRestrictionInputFeatureName != rhs.itemRestrictionInputFeatureName {return false}
    if lhs.itemExclusionInputFeatureName != rhs.itemExclusionInputFeatureName {return false}
    if lhs.recommendedItemListOutputFeatureName != rhs.recommendedItemListOutputFeatureName {return false}
    if lhs.recommendedItemScoreOutputFeatureName != rhs.recommendedItemScoreOutputFeatureName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ItemSimilarityRecommender.ConnectedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ItemSimilarityRecommender.protoMessageName + ".ConnectedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemId"),
    2: .same(proto: "similarityScore"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.itemID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.similarityScore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itemID != 0 {
      try visitor.visitSingularUInt64Field(value: self.itemID, fieldNumber: 1)
    }
    if self.similarityScore != 0 {
      try visitor.visitSingularDoubleField(value: self.similarityScore, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ItemSimilarityRecommender.ConnectedItem, rhs: ItemSimilarityRecommender.ConnectedItem) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.similarityScore != rhs.similarityScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ItemSimilarityRecommender.SimilarItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ItemSimilarityRecommender.protoMessageName + ".SimilarItems"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemId"),
    2: .same(proto: "similarItemList"),
    3: .same(proto: "itemScoreAdjustment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.itemID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.similarItemList) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.itemScoreAdjustment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itemID != 0 {
      try visitor.visitSingularUInt64Field(value: self.itemID, fieldNumber: 1)
    }
    if !self.similarItemList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.similarItemList, fieldNumber: 2)
    }
    if self.itemScoreAdjustment != 0 {
      try visitor.visitSingularDoubleField(value: self.itemScoreAdjustment, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ItemSimilarityRecommender.SimilarItems, rhs: ItemSimilarityRecommender.SimilarItems) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.similarItemList != rhs.similarItemList {return false}
    if lhs.itemScoreAdjustment != rhs.itemScoreAdjustment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
